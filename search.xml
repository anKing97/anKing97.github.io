<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>搭建samab服务器</title>
      <link href="/2023/06/04/%E6%90%AD%E5%BB%BAsamab%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2023/06/04/%E6%90%AD%E5%BB%BAsamab%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-搭建samba服务器"><a href="#1-搭建samba服务器" class="headerlink" title="1.搭建samba服务器"></a>1.搭建samba服务器</h1><p>服务器系统：Ubuntu22.04</p><ol><li><p>安装samba软件包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install samba</span><br></pre></td></tr></table></figure></li><li><p>配置Samba共享</p><ul><li><p>编辑Samba配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/samba/smb.conf</span><br></pre></td></tr></table></figure></li><li><p>在文件的末尾添加共享配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[share]</span><br><span class="line">comment = Shared Folder</span><br><span class="line">path = /path/to/shared/folder</span><br><span class="line">browseable = <span class="built_in">yes</span></span><br><span class="line">create mask = 0777</span><br><span class="line">directory mask = 0777</span><br><span class="line">valid <span class="built_in">users</span> =  your_username</span><br><span class="line">public = <span class="built_in">yes</span></span><br><span class="line"><span class="built_in">read</span> only = no</span><br><span class="line">available = <span class="built_in">yes</span></span><br><span class="line">writable = <span class="built_in">yes</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>创建Samba用户：</p><ul><li><p>使用以下命令创建一个samba用户（与系统用户相关联）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo smbpasswd -a your_username</span><br></pre></td></tr></table></figure><p>将 <code>your_username</code> 替换为要创建的Samba用户的用户名</p></li></ul></li><li><p>重启Samba服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart smbd.service</span><br></pre></td></tr></table></figure></li></ol><p>至此，Samba服务器就已经搭建完成了，其他设备可以通过ip和共享文件夹名称访问Samba.</p><h1 id="2-Ubuntu连接Samba服务器"><a href="#2-Ubuntu连接Samba服务器" class="headerlink" title="2.Ubuntu连接Samba服务器"></a>2.Ubuntu连接Samba服务器</h1><ol><li><p>确保已经安装了 <code>cifs-utils</code> 软件包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install cifs-utils</span><br></pre></td></tr></table></figure></li><li><p>创建用于挂在Samba共享的本地目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> /mnt/smbshare</span><br></pre></td></tr></table></figure><p>可以选择在其他位置创建目录，只需确保目录存在并且有足够的权限。</p></li><li><p>挂载Samba共享：<br>用以下命令来挂载Samba共享：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -t cifs //server_ip/share_name /mnt/smbshare -o username=samba_username,password=samba_password</span><br></pre></td></tr></table></figure><ul><li>将<code>server_ip</code> 替换为Samba服务器的IP地址。</li><li>将<code>share_name</code>替换为Samba服务器上的共享名称。</li><li>将<code>samba_username</code>和<code>samba_password</code>替换为具有访问权限的Samba用户名和密码。</li></ul></li><li><p>输入密码（如果需要）。</p></li><li><p>现在，就可以通过访问 <code>/mnt/smbshare</code> 目录来访问Samba共享中的文件。</p></li></ol><blockquote><p>这种挂载方法会存在问题：在ubuntu中访问共享文件时需要root权限才能写入数据，普通用户无法进行修改写入。</p></blockquote><p><strong><em>解决方法：</em></strong></p><p>在挂载Samba共享时制定其他用户的访问权限：</p><ol><li><p>打开终端并使用root权限编辑<code>/etc/fstab</code>文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/fstab</span><br></pre></td></tr></table></figure></li><li><p>在文件的末尾添加一行来定义Samba共享的挂载选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//&lt;samba_server_ip&gt;/share /mnt/smbshare cifs username=&lt;samba_username&gt;,password=&lt;samba_password&gt;,uid=&lt;your_username&gt;,gid=&lt;your_group&gt;,iocharset=utf8,vers=3.0 0 0</span><br></pre></td></tr></table></figure><ul><li>将<code>&lt;samba_server_ip&gt;</code>替换为Samba服务器的ip</li><li>将<code>&lt;samba_username&gt;</code> 替换为Samba共享的用户名</li><li>将<code>&lt;samba_password&gt;</code>替换为密码</li><li>将<code>/mnt/smbshare</code>替换为想要挂载的本地目录</li><li>将<code>&lt;your_username&gt;</code>替换为自己的用户名</li><li>将<code>&lt;your_group&gt;</code>替换为所在的用户组</li></ul></li><li><p>保存并关闭<code>/etc/fstab</code>文件。</p></li><li><p>使用如下命令重新挂载文件系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -a</span><br></pre></td></tr></table></figure></li></ol><p>现在就能够以普通用户在Samba共享文件系统中写入文件。</p><h1 id="3-Windows连接Samba服务器"><a href="#3-Windows连接Samba服务器" class="headerlink" title="3. Windows连接Samba服务器"></a>3. Windows连接Samba服务器</h1><ol><li><p>在<code>Windows功能</code> 中启用 <code>SMB</code> 功能。<br> <img src="image-20230604150827730.png" alt="image-20230604150827730"></p></li><li><p>通过<code>\\+ip</code> 的方式访问：<br> <img src="image-20230604151220908.png" alt="image-20230604151220908"></p></li><li><p>回车后输入用户名和密码就可以看到共享文件夹。</p></li><li><p>映射到磁盘：<br> <img src="image-20230604151340784.png" alt="image-20230604151340784"></p><p> 写入：<img src="image-20230604151439573.png" alt="image-20230604151439573"></p></li><li><p>点击完成，就可以在计算机界面看见映射成功的磁盘了。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Nas </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Samba </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu系统实践</title>
      <link href="/2023/02/12/Ubuntu%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/"/>
      <url>/2023/02/12/Ubuntu%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>免费的服务器： <strong><em>render</em></strong> </p><h1 id="1、软件安装"><a href="#1、软件安装" class="headerlink" title="1、软件安装"></a>1、软件安装</h1><p><a href="https://zhuanlan.zhihu.com/p/56253982">Linux玩家必备：Ubuntu完全配置指南</a><br><a href="https://zhuanlan.zhihu.com/p/176977192">Ubuntu 20.04 桌面美化</a> </p><h2 id="1-1、安装Docker"><a href="#1-1、安装Docker" class="headerlink" title="1.1、安装Docker"></a>1.1、安装Docker</h2><p><a href="https://www.runoob.com/docker/ubuntu-docker-install.html">Ubuntu Docker 安装</a></p><h3 id="卸载旧版本："><a href="#卸载旧版本：" class="headerlink" title="卸载旧版本："></a>卸载旧版本：</h3><p>首先需要卸载 Docker 的旧版本， <code>docker</code> ， <code>[docker.io](http://docker.io)</code> 和  <code>docker-engine</code> 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get remove docker docker-engine docker.io containerd runc</span><br></pre></td></tr></table></figure><h3 id="设置存储库："><a href="#设置存储库：" class="headerlink" title="设置存储库："></a>设置存储库：</h3><p>1、更新 <code>apt</code> 包索引并且安装包允许 <code>apt</code> 通过 HTTPS 使用存储库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line">$ sudo apt-get install \</span><br><span class="line">ca-certificates \</span><br><span class="line">curl \</span><br><span class="line">gnupg \</span><br><span class="line">lsb-release</span><br></pre></td></tr></table></figure><p>2、添加 Docker 的官方 GPG 密钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSl https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -</span><br></pre></td></tr></table></figure><p>3、设置稳定的存储库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">&quot;deb [arch=<span class="subst">$(dpkg --print-architecture)</span> signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">  <span class="subst">$(lsb_release -cs)</span> stable nightly&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></pre></td></tr></table></figure><h3 id="安装-Docker-引擎"><a href="#安装-Docker-引擎" class="headerlink" title="安装 Docker 引擎"></a>安装 Docker 引擎</h3><p>安装最新版的 <code>Docker Engine</code> 、 <code>containerd</code> 和 <code>Docker Compose</code> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure><h3 id="卸载-Docker-引擎"><a href="#卸载-Docker-引擎" class="headerlink" title="卸载 Docker 引擎"></a>卸载 Docker 引擎</h3><p>1、卸载 <code>Docker Engine</code> 、 <code>CLI</code> <code>containerd</code> 和 <code>Docker Compose</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get purge docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure><p>2、主机上的映像、容器、卷或自定义配置文件不会自动删除。要删除所有映像、容器和卷：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="built_in">rm</span> -rf /var/lib/docker</span><br><span class="line">$ sudo <span class="built_in">rm</span> -rf /var/lib/containerd</span><br></pre></td></tr></table></figure><h2 id="1-2、安装-wine-（运行原生的windows应用）"><a href="#1-2、安装-wine-（运行原生的windows应用）" class="headerlink" title="1.2、安装 wine （运行原生的windows应用）"></a>1.2、安装 wine （运行原生的windows应用）</h2><p>首先安装依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install wine</span><br><span class="line">$ sudo apt install winetricks</span><br></pre></td></tr></table></figure><p>然后执行 <code>winetricks</code> 来修复 bug</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ winetricks riched20</span><br></pre></td></tr></table></figure><p>此方法相当于在 ubuntu 中运行 Windows 子系统，想要安装 QQ 或者 微信，只需在官网下载 <code>.exe</code> 安装包，然后执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wine WeChatSetup.exe</span><br></pre></td></tr></table></figure><p>具体应用的列表可以在 <code>.wine/drive_c/Program Files(x86)/</code> 中查看，比如安装的 微信： <code>.wine/drive_c/Program Files(x86)/Tencent/WeChat</code></p><h2 id="1-3、安装搜狗输入法"><a href="#1-3、安装搜狗输入法" class="headerlink" title="1.3、安装搜狗输入法"></a>1.3、安装搜狗输入法</h2><p>首先在搜狗输入法官网 <code>https://pinyin.sougou.com/linux/</code> 下载 linux 版本的输入法 <code>.deb</code> 文件，然后安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dpkg -i sogoupinyin_4.0.1.2123_amd64.deb</span><br><span class="line"><span class="comment"># 安装相关的依赖</span></span><br><span class="line">$ sudo apt-get install -f</span><br></pre></td></tr></table></figure><p>接下来需要更新 linux 的软件仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo add-apt-repository ppa:fcitx-team/nightly</span><br><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来安装依赖包：</span></span><br><span class="line">$ sudo apt install libqt5qml5 libqt5quick5 libqt5quickwidgets5 qml-module-qtquick2</span><br><span class="line">$ sudo apt install libgsettings-qt1</span><br></pre></td></tr></table></figure><p>接下来在 <code>language supporting</code> 中将 <code>keyboard input method system:</code> 改为 <code>fcitx</code> 。最后配置文件，讲 <code>sougoupinyin</code> 加入列表。</p><h2 id="1-4、安装Typora"><a href="#1-4、安装Typora" class="headerlink" title="1.4、安装Typora"></a>1.4、安装Typora</h2><p>ubuntu 可以安装最后一个不收费版本的 Typora：直接在 <code>release</code> 界面找：</p><p><a href="https://www.typora.io/releases/all">Typora - macOS release channel</a></p><h2 id="1-5、安装QQ"><a href="#1-5、安装QQ" class="headerlink" title="1.5、安装QQ"></a>1.5、安装QQ</h2><p>目前比较好用的一个QQ版本是 <code>github</code> 上面的:</p><p><a href="https://github.com/Icalingua-plus-plus/Icalingua-plus-plus">GitHub - Icalingua-plus-plus/Icalingua-plus-plus: A client for QQ and more.</a></p><p><img src="Untitled%2011-1683541470273-3.png" alt="Untitled 11"></p><p>目前其他版本的QQ可以向 linux 上面传文件，但是 linux 上面不能往外边传</p><h2 id="1-6、安装-navicat"><a href="#1-6、安装-navicat" class="headerlink" title="1.6、安装 navicat"></a>1.6、安装 navicat</h2><ol><li>直接在官网下载 AppImage 文件，并移动到合适的文件夹下，然后在 <strong><em>zsh</em></strong> 中执行：  <code>chmod +x navicat16-premium-en.AppImage</code>   以及 <code>./navicat16-premium-en.AppImage</code></li><li>在到期时，直接删除 <code>~/.config/dconf/user</code> 和 <code>~/.config/navicat</code> 两个文件夹即可。</li></ol><h1 id="2、系统配置"><a href="#2、系统配置" class="headerlink" title="2、系统配置"></a>2、系统配置</h1><h2 id="2-1、配置连接校园网："><a href="#2-1、配置连接校园网：" class="headerlink" title="2.1、配置连接校园网："></a>2.1、配置连接校园网：</h2><blockquote><p>[!info] 更新<br>更简单的方法： <code>nm-connection-editor</code>  直接配置即可</p></blockquote><p>针对于深澜系统，通过 <code>DSL</code> 连接西北工业大学校园网：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ nmcli con edit <span class="built_in">type</span> pppoe con-name <span class="string">&quot;校园网&quot;</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">set</span> pppoe.username 用户名</span><br><span class="line">$ <span class="built_in">set</span> pppoe.password 密码</span><br></pre></td></tr></table></figure><p>用户名和密码输入完成之后，继续输入 <code>save</code> ， 然后 <code>quit</code> 。之后，网络连接中就会出现以 校园网 命名的 <code>DSL</code> <code>PPPOE</code> 网络连接。</p><p>然后在网络设置中，将连接的上级接口改为 <code>ens4</code> </p><p><strong>删除某一网络连接：</strong></p><p>直接在 高级网络配置 中进行更改。</p><h2 id="2-2、配置-FTP-服务器"><a href="#2-2、配置-FTP-服务器" class="headerlink" title="2.2、配置 FTP 服务器"></a>2.2、配置 FTP 服务器</h2><p>这里选择 <code>vsftpd</code> 为 ubuntu 上的服务器，首先先下载软件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install vsftpd</span><br></pre></td></tr></table></figure><p>然后创建用户并配置密码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo useradd -m ftp用户名</span><br><span class="line">$ sudo passwd ftp用户名</span><br><span class="line">New password:</span><br><span class="line">Retype new password:</span><br><span class="line">passwd:password update successfully</span><br></pre></td></tr></table></figure><p>此步之后，会在 <code>/home</code> 路径内创建一个 <code>ftp用户名</code> 的文件夹，接着，修改文件夹的权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="built_in">chmod</span> -R 777 /home/ftp用户名</span><br></pre></td></tr></table></figure><p>然后修改配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gedit /etc/vsftpd.conf</span><br></pre></td></tr></table></figure><p>将其修改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">listen=NO</span><br><span class="line">listen_ipv6=YES</span><br><span class="line">anonymous_enable=NO</span><br><span class="line">local_enable=YES</span><br><span class="line">write_enable=YES</span><br><span class="line">local_umask=022</span><br><span class="line">dirmessage_enable=YES</span><br><span class="line">use_localtime=YES</span><br><span class="line">xferlog_enable=YES</span><br><span class="line">connect_from_port_20=YES</span><br><span class="line">chroot_local_user=YES</span><br><span class="line">secure_chroot_dir=/var/run/vsftpd/empty</span><br><span class="line">pam_service_name=vsftpd</span><br><span class="line">rsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem</span><br><span class="line">rsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.key</span><br><span class="line">ssl_enable=NO</span><br><span class="line">pasv_enable=Yes</span><br><span class="line">pasv_min_port=10000</span><br><span class="line">pasv_max_port=10100</span><br><span class="line">allow_writeable_chroot=YES</span><br><span class="line">local_root=/home/ftp用户名</span><br></pre></td></tr></table></figure><p>随后重启 ftp 服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service vsftpd restart</span><br></pre></td></tr></table></figure><p>至此，就可以在其他电脑上访问ubuntu机器上的 ftp 服务器了。</p><blockquote><p>注：两台电脑必须处于同一个局域网内，比如校园网，不可以在校园网范围外访问校园网内的服务器。</p></blockquote><p>另外，还可以设置多个用户，这时，需要创建一个 <code>userlist_file</code> ，用来存储所有创建的用户名，不在 <code>userlist_file</code> 内的用户即使同处于一个局域网内，也无法访问服务器。同样在 <code>/etc/vsftpd.conf</code> 内配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">userlist_deny=NO</span><br><span class="line">userlist_file=/etc/allowed_users</span><br><span class="line">seccomp_sandbox=NO</span><br><span class="line">local_root=/home/ftp用户名</span><br></pre></td></tr></table></figure><p>在增加了ftp用户之后，只需要在 <code>/etc/allowed_users</code> 文件内写入新增加的用户名。</p><h2 id="2-3、内网穿透"><a href="#2-3、内网穿透" class="headerlink" title="2.3、内网穿透"></a>2.3、内网穿透</h2><p><strong><em>穿透工具：</em></strong> ittun, frp</p><p><strong><em>frp演示示例：</em></strong> <a href="https://github.com/fatedier/frp">frp Demo</a>  (示例很清晰，直接按照这个操作就可以，需要什么直接配置)<br><strong><em>使用 frp 进行内网穿透</em></strong>：<a href="https://itlanyan.com/frp-tunnel-tutorial/">frp内网穿透教程 - tlanyan</a> </p><h2 id="2-4、NAS服务器"><a href="#2-4、NAS服务器" class="headerlink" title="2.4、NAS服务器"></a>2.4、NAS服务器</h2><p>启发：<a href="https://www.bilibili.com/video/BV1sP4y1D7Gn/?spm_id_from=333.1007.top_right_bar_window_view_later.content.click&amp;vd_source=a7a1e61bb0348aaf12b5c40afdecb042">关于我把笔记本电脑改造为家用NAS服务器的事儿 -【DIY教程】_哔哩哔哩_bilibili</a> </p><h1 id="3、问题记录"><a href="#3、问题记录" class="headerlink" title="3、问题记录"></a>3、问题记录</h1><h2 id="3-1、有线网络问题"><a href="#3-1、有线网络问题" class="headerlink" title="3.1、有线网络问题"></a>3.1、有线网络问题</h2><p>ubuntu 有线网不停的重复连接，首先是 <code>/etc/network/interfaces</code> 配置文件出错，正常情况下不需要进行修改，原文件内容为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># interfaces(5) file used by ifup(8) and ifdown(8)</span></span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br></pre></td></tr></table></figure><p>如果没有特殊原因，应该保持上面的配置文件为原样。</p><h2 id="3-2、U盘启动盘有写保护问题："><a href="#3-2、U盘启动盘有写保护问题：" class="headerlink" title="3.2、U盘启动盘有写保护问题："></a>3.2、U盘启动盘有写保护问题：</h2><p>在装完 Ubuntu 之后，启动盘格式化的时候，会出现u盘有写保护，无法格式化，此时，可以进行如下操作，去除写保护：</p><ol><li>按 <code>win</code> + <code>R</code> ，并在其中输入 <code>diskpart</code> 。</li><li>输入 <code>list disk</code> ，列出所有的磁盘，然后选择需要去除写保护的磁盘：</li><li>比如 1 号磁盘为目标磁盘。然后输入 <code>select disk 1</code> 。</li><li>接下来输入 <code>attributes disk clear readonly</code> ，这一命令可以清楚磁盘的写保护状态。</li><li>接下来输入 <code>clean</code> 可以清楚 u 盘内的所有数据，然后输入 <code>exit</code> 退出命令框。</li><li>接下来在 文件资源管理器中直接将 u 盘进行格式化即可。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Docker </tag>
            
            <tag> Wine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nas实践</title>
      <link href="/2023/02/10/Nas%E5%AE%9E%E8%B7%B5/"/>
      <url>/2023/02/10/Nas%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p><strong><em>系统选择</em></strong>：ubuntu server 22.04.1<br><strong><em>软件：</em></strong> Nextcloud   Aria2   Transmission  jellyfin  RClone  CasaOS  Caddy</p><h1 id="一、软件安装"><a href="#一、软件安装" class="headerlink" title="一、软件安装"></a>一、软件安装</h1><h2 id="1、webmin"><a href="#1、webmin" class="headerlink" title="1、webmin"></a>1、webmin</h2><p>可视化 linux 管理界面<img src="image-20230508181614280.png" alt="image-20230508181614280"></p><p>安装：</p><ul><li>首先升级软件包列表，并且安装依赖软件：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install software-properties-common apt-transport-https wget</span><br></pre></td></tr></table></figure><ul><li>导入 Webmin 的 GPG key 并且将 Webmin 软件源添加到系统软件源</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget -q http://www.webmin.com/jcameron-key.asc -O- | sudo apt-key add -</span><br><span class="line">sudo add-apt-repository &quot;deb [arch=amd64] http://download.webmin.com/download/repository sarge contrib&quot;</span><br></pre></td></tr></table></figure><ul><li>安装最新版的 Webmin </li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install webmin</span><br></pre></td></tr></table></figure><ul><li>调整防火墙：默认情况下，Webmin 再所有网络接口上监听端口 1000. 需要再防火墙上打开这个端口，以便通过互联网访问 Webmin 。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw allow 10000/tcp</span><br></pre></td></tr></table></figure><ul><li>访问 Webmin 网络界面：在浏览器中输入如下</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://ip_or_hostname:10000</span><br></pre></td></tr></table></figure><h2 id="2、安装-clash-for-linux"><a href="#2、安装-clash-for-linux" class="headerlink" title="2、安装 clash for linux"></a>2、安装 clash for linux</h2><ol><li>从 <a href="https://github.com/Dreamacro/clash/releases">clash官网</a> 下载文件 <code>clash-linux-amd64</code> </li><li>将 windows 中的 clash 的配置文件 <code>.yaml</code> 和 <code>Country.mmdb</code> 复制到 ubuntu 的 <code>~/.config/clash/</code> 目录下。</li><li>修改 <code>.yaml</code> 文件如下：<img src="image-20230508181636454.png" alt="image-20230508181636454"></li><li>赋予 <code>clash-linux-amd64</code> 可执行权限：<code>chmod +x clash-linux-amd64</code> </li><li>运行 <code>clash-linux-amd64</code> : <code>./clash-linux-amd64</code> </li><li>配置全局代理：<code>bash export https_proxy= http://127.0.0.1:7890 http_proxy= http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1: 7890</code><br> 接下来配置 clash 自启动：在 <code>/etc/systed/system</code> 下新建 <code>clash.service</code> 文件，然后写入：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Clash service</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=anking</span><br><span class="line">ExecStart=/home/anking/clash/clash-linux-amd64</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartPreventExitStatus=23</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>然后配置定时更新订阅：先在 <code>~/.config/clash</code> 目录下新建一个 <code>subscribe</code> 文件，并写入订阅链接。然后在 <code>~/clash</code> 下新建 <code>subscribe.sh</code> 文件并写入如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">set -e</span><br><span class="line"># 设置clash路径</span><br><span class="line">clash_path = &quot;/home/anking/clash/clash-linux-amd64&quot;</span><br><span class="line">config_path= &quot;/home/anking/.config/clash&quot;</span><br><span class="line"></span><br><span class="line"># 停止clash</span><br><span class="line">echo &quot;stop clash service&quot;</span><br><span class="line">sudo systemctl stop clash</span><br><span class="line"></span><br><span class="line"># 加载最新订阅配置</span><br><span class="line">echo &quot;download latest config&quot;</span><br><span class="line">weget -O $config_path/config.yaml.new `cat $config_path/subscribe`</span><br><span class="line"># 备份原订阅配置</span><br><span class="line">if [ ! -d &quot;$config_path/backup&quot; ]; then</span><br><span class="line">        echo &quot;create backup directory&quot;</span><br><span class="line">        mkdir $config_path/backup</span><br><span class="line">fi</span><br><span class="line">echo &quot;move config.yaml to $config_path/backup&quot;</span><br><span class="line">mv $config_path/config.yaml $config_path/backup/config_`date &#x27;+%Y%m%d%H%M%S&#x27;`</span><br><span class="line"></span><br><span class="line"># 替换配置</span><br><span class="line">echo &quot;replace config.yaml to $config_path/config.yaml&quot;</span><br><span class="line"></span><br><span class="line"># 重启clash</span><br><span class="line">echo &quot;restart clash service&quot;</span><br><span class="line">sudo systemctl restart clash</span><br></pre></td></tr></table></figure><p>接着设置定时任务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo crontab -e</span><br><span class="line"></span><br><span class="line"># 添加脚本 每星期更新一次</span><br><span class="line">30 0 * * 0 sh /home/anking/clash/subscribe.sh</span><br></pre></td></tr></table></figure><p>然后重启定时服务 ：<code>sudo systemctl restart cron.service</code></p><hr><p>网页版 clash<br>使用 docker 安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 拉取yacd镜像</span><br><span class="line">docker pull haishanh/yacd</span><br><span class="line"># 运行yacd</span><br><span class="line">docker run -p 1234:80 -d --name clash-dashboard haishanh/yacd</span><br></pre></td></tr></table></figure><p>这里需要在 <code>.yaml</code> 中配置一点东西：<img src="image-20230508181707077.png" alt="image-20230508181707077"></p><p>接着就可以在浏览器中输入：<code>ip:1234</code> 访问界面：<img src="image-20230508181724380.png" alt="image-20230508181724380"></p><h2 id="3、Nextcloud"><a href="#3、Nextcloud" class="headerlink" title="3、Nextcloud"></a>3、Nextcloud</h2><p>安装教程：<a href="https://www.higgs.xyz/archives/6/">可能是最完美的Nextcloud搭建指南 - 禾奈</a> </p><h2 id="4、宝塔-linux"><a href="#4、宝塔-linux" class="headerlink" title="4、宝塔 linux"></a>4、宝塔 linux</h2><h1 id="二、系统设置"><a href="#二、系统设置" class="headerlink" title="二、系统设置"></a>二、系统设置</h1><h2 id="1、frp-开机自启动"><a href="#1、frp-开机自启动" class="headerlink" title="1、frp 开机自启动"></a>1、frp 开机自启动</h2><p>在 <code>/etc/systemd/system</code> 中新建文件：<code>frpc.service</code> 并写入如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Frpc</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=anking</span><br><span class="line">ExecStart=/opt/frp/frpc -c /opt/frp/frpc.ini</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartPreventExitStatus=24</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>然后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable frpc</span><br><span class="line">sudo systemctl start frpc</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Nas </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Nas </tag>
            
            <tag> Nextcloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为nextcloud安装face recongition</title>
      <link href="/2023/02/09/%E4%B8%BAnextcloud%E5%AE%89%E8%A3%85face-recogniition/"/>
      <url>/2023/02/09/%E4%B8%BAnextcloud%E5%AE%89%E8%A3%85face-recogniition/</url>
      
        <content type="html"><![CDATA[<h1 id="FaceRecognition介绍"><a href="#FaceRecognition介绍" class="headerlink" title="FaceRecognition介绍"></a>FaceRecognition介绍</h1><p>FaceRecognition 是一个 Nextcloud 应用程序，其目标是识别、分析和汇总用户图像中的面部数据，并在这些信息之上提供额外的功能，所有这些都具有 Nextcloud 的内置隐私。想象一下 Google 相册，但仅用于人脸（不检测物体……），并且您的图像永远不会离开您的 Nextcloud 实例。</p><p>该应用程序监听新图像文件的创建，并将它们排队以供以后分析。计划任务（或按需管理员）获取此队列，并分析图像中的面孔，并在可能的情况下按相似性对它们进行分组。</p><p>官网：<a href="https://github.com/matiasdelellis/facerecognition">Face Recognition</a> </p><p>官方百科：<a href="https://github.com/matiasdelellis/facerecognition/wiki">https://github.com/matiasdelellis/facerecognition/wiki</a></p><h1 id="安装所需的环境"><a href="#安装所需的环境" class="headerlink" title="安装所需的环境"></a>安装所需的环境</h1><p>Requirements：</p><ul><li>Nextcloud 22+</li><li><a href="https://github.com/goodspb/pdlib">Dlib PHP bindings</a></li><li><a href="https://www.php.net/manual/en/book.bzip2.php">PHP Bzip2</a></li><li>1GB of RAM</li></ul><p>如果安装普通版本的，即利用CPU进行人脸识别，那么主要需要安装两个<code>Dlib</code>和<code>Bzip2</code></p><p>如果服务器上有GPU,想利用GPU加速，那么还需要额外的操作，安装CUDA和cuDNN。</p><h2 id="安装GPU环境"><a href="#安装GPU环境" class="headerlink" title="安装GPU环境"></a>安装GPU环境</h2><h3 id="安装显卡驱动"><a href="#安装显卡驱动" class="headerlink" title="安装显卡驱动"></a>安装显卡驱动</h3><p>在命令行中输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubuntu-drivers devices</span><br></pre></td></tr></table></figure><p>可以查看在当前版本支持的驱动<img src="image-20230609153304408.png" alt="image-20230609153304408"></p><p>如果要安装特定版本的驱动（例如：510）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install nvidia-driver-510</span><br></pre></td></tr></table></figure><p>或者可以安装推荐驱动（适用于大多数用户）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ubuntu-drivers autoinstall</span><br></pre></td></tr></table></figure><p>等待安装完成，然后重启服务器。</p><p>在<code>terminal</code>中输入 <code>nvidia-smi</code>查看cuda版本，正常情况下会返回如下：</p><p><img src="image-20230609153755020.png" alt="image-20230609153755020"></p><p>可以看到，当前的cuda版本为12.1。 接下来就按照12.1版本的安装。</p><h3 id="安装CUDA"><a href="#安装CUDA" class="headerlink" title="安装CUDA"></a>安装CUDA</h3><p>打开官网：<a href="https://developer.nvidia.com/cuda-downloads">CUDA下载</a> </p><p>选择 <code>CUDA 12.x</code> 然后根据自己的服务器情况选择：</p><p><img src="image-20230609154032867.png" alt="image-20230609154032867"></p><p>官网会给出两条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">get https://developer.download.nvidia.com/compute/cuda/12.1.1/local_installers/cuda_12.1.1_530.30.02_linux.run</span><br><span class="line">sudo sh cuda_12.1.1_530.30.02_linux.run</span><br></pre></td></tr></table></figure><p>依次在终端中输入。</p><p>运行第二条命令<code>sudo sh cuda_12.1.1_530.30.02_linux.run</code>时，因为我们已经安装了显卡驱动，所以这次不需要再安装驱动了，直接<code>continue</code>，接受协议后，将<code>Driver</code>前面的勾去掉，然后点击<code>Install</code></p><p>安装完成之后，打开终端，配置环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line"><span class="comment"># 在.bashrc后面写入：</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/local/cuda-12.1/bin</span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/usr/local/cuda-12.1/lib64</span><br></pre></td></tr></table></figure><p>退出后，让<code>.bashrc</code>文件生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p>最后在终端输入<code>nvcc -V</code>可查看CUDA的版本</p><p><img src="image-20230609154640316.png" alt="image-20230609154640316"></p><h3 id="安装cuDNN"><a href="#安装cuDNN" class="headerlink" title="安装cuDNN"></a>安装cuDNN</h3><p>打开并登陆 <a href="https://developer.nvidia.com/rdp/cudnn-download">官网</a> 下载安装文件。按照实际情况选择要下载的文件，比如我的系统是<code>ubuntu22.04</code>，cuda版为为<code>cuda 12.1</code>，因此我会选择这两个文件：</p><p><img src="image-20230609160344478.png" alt="image-20230609160344478"></p><p>然后可以打开 <a href="https://docs.nvidia.com/deeplearning/cudnn/install-guide/index.html">cuDNN安装步骤</a> 这里面有具体的安装方法，下边的安装方法是特例：</p><p>首先，如果系统还没有安装<code>zlib</code>包，可以先<code>sudo apt-get install zlib1g</code> 安装一下。</p><p>在下载的安装文件目录下，运行如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i cudnn-local-repo-$(OS)-8.x.x.x_1.0-1_amd64.deb</span><br></pre></td></tr></table></figure><p>安装完成后，根据终端中的提示导入<code>CUDA GPG key</code><img src="image-20230609160932959.png" alt="image-20230609160932959"></p><p>即运行上面图片中的<code>sudo cp ....</code>命令。</p><p>接着刷新库：<code>sudo apt update</code></p><p>然后安装下面三个库：</p><ul><li><code>sudo apt install libcudnn8=8.9.2.26-1+cuda12.1</code></li><li><code>sudo apt install libcudnn8-dev=8.9.2.26-1+cuda12.1</code></li><li><code>sudo apt install libcudnn8-samples=8.9.2.26-1+cuda12.1</code></li></ul><blockquote><p>这里的libcudnn8和cuda版本的配对是指定的，可通过<code>apt-cache policy libcudnn8</code>命令查看。</p><p>可以在输入到<code>=</code>后按<code>tab</code>键自动填充后面的版本</p></blockquote><p><img src="image-20230609161257193.png" alt="image-20230609161257193"></p><p>检验是否安装成功，可在终端中输入如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r /usr/src/cudnn_samples_v8/ <span class="variable">$HOME</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$HOME</span>/cudnn_samples_v8/mnistCUDNN</span><br><span class="line">make clean &amp;&amp; make</span><br><span class="line">./mnistCUDNN</span><br></pre></td></tr></table></figure><p>如果上面的<code>make</code>命令提示缺少<code>FreeImage.h</code>，则运行：<code>sudo apt-get install libfreeimage3 libfreeimage-dev</code> 安装即可。</p><p>到此，GPU环境已经搭建完成。</p><h2 id="安装PDlib-Dlib的PHP扩展"><a href="#安装PDlib-Dlib的PHP扩展" class="headerlink" title="安装PDlib-Dlib的PHP扩展"></a>安装PDlib-Dlib的PHP扩展</h2><p>官方文档：<a href="https://github.com/goodspb/pdlib">https://github.com/goodspb/pdlib</a></p><p>如果不是用GPU,直接使用CPU识别人脸，那么只需要按照官方文档中的步骤顺序安装即可。</p><p>但若要启用GPU,则需要做一些修改。</p><p>在官方文档中，安装<code>Dlib</code>作为共享库时，是这样操作的，这种是没有GPU的安装方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/davisking/dlib.git</span><br><span class="line"><span class="built_in">cd</span> dlib/dlib</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake -DBUILD_SHARED_LIBS=ON ..</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>修改为支持GPU的方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/davisking/dlib.git</span><br><span class="line"><span class="built_in">cd</span> dlib/dlib</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">sudo cmake -DBUILD_SHARED_LIBS=ON -DDLIB_USE_CUDA=1 ..</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>其他操作都与官方文档中的一样。</p><h3 id="修改PHP内存限制"><a href="#修改PHP内存限制" class="headerlink" title="修改PHP内存限制"></a>修改PHP内存限制</h3><p>由于Face Recognition至少需要1G的内存，但是内存大小与聚类质量和速度都有关系，因此，推荐的内存大小为2～4G。下面将PHP内存限制修改为3G</p><p>编辑<code>php.ini</code>文件，如果使用的是Apache代理Nextcloud,那么需要编辑两个地方：<code>/etc/php/8.1/apache2/php.ini</code>以及<code>/etc/php/8.1/cli/php.ini</code>在其中搜索<code>memory_limit</code>将其修改为<code>3096M</code></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">memory_limit</span> = <span class="number">3096</span>M</span><br></pre></td></tr></table></figure><h1 id="在Nextcloud中安装FaceRecognition应用"><a href="#在Nextcloud中安装FaceRecognition应用" class="headerlink" title="在Nextcloud中安装FaceRecognition应用"></a>在Nextcloud中安装FaceRecognition应用</h1><p>打开Nextcloud应用市场，在<code>Multimedia</code>中搜索 <code>Face Recognition</code>并安装，安装完成后，在管理设置中更改具体的设置<img src="image-20230609162429502.png" alt="image-20230609162429502"></p><p>其中，对临时文件的更改是必须的。</p><p>随后在个人的面部识别中打开分析选项<img src="image-20230609162536942.png" alt="image-20230609162536942"></p><p>到此Face Recognition已经安装完成。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>在服务器的nextcloud的安装目录下，一般为<code>/var/www/html/nextcloud</code>，利用<code>occ</code>命令进行人脸的识别聚类。</p><ol><li><p>初始化内存大小和要使用的模型：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启用人脸识别</span></span><br><span class="line">sudo -u www-data php occ app:<span class="built_in">enable</span> facerecognition</span><br><span class="line"><span class="comment"># 设置允许使用的内存大小</span></span><br><span class="line">sudo -u www-data php occ face:setup -M 3096M</span><br><span class="line"><span class="comment"># 设置使用的模型</span></span><br><span class="line">sudo -u www-data php occ face:setup -m 1</span><br></pre></td></tr></table></figure><p>下面是四个模型的比较：</p><p>| 比较       | 模型 1 (CNN5)                        | 模型 2 (CNN68)                                          | 型号 3（生猪）                                  | 模型 4 (CNN5HOG)                                             |<br>| ————— | —————————————————— | ———————————————————————————- | ———————————————————————- | —————————————————————————————— |<br>| 检测到人脸 | 可以找到图像非常小的人脸。           | 它使用与模型 1 相同的人脸检测器，因此具有相同的结果。   | 需要更大的图像才能获得相同的结果。              | 它使用与模型 1 相同的人脸检测器，因此具有相同的结果。        |<br>| 内存消耗   | 内存消耗根据所用图像的大小线性增加。 | 内存消耗根据所用图像的大小线性增加。与模型 1 完全相同。 | 无论分析何种图像，内存消耗都稳定在 100Mb 左右。 | 内存消耗根据所用图像的大小线性增加。与模型 1 完全相同。      |<br>| 处理时间   | 处理时间根据图像的面积线性增加       | 它与模型 1 完全相同                                     | 它比模型 1 和 2 略小                            | 该模型对图像进行了两次分析，使用 CNN 并用 HOG 对其进行补充，因此它的速度实际上是原来的两倍， |<br>| 集群质量   | 高（某些侧面可能有一些错误）         | 低（非正面的面部可能会有更多错误。）                    | 非常高（只找到相当正面的面孔）                  | 非常高（类似于模型 3，但面孔更多）                           |</p></li><li><p>人脸分析：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u www-data php occ face:background_job [-u|--user_id USER_ID] [-t|--<span class="built_in">timeout</span> TIMEOUT] [--defer-clustering] [-M|--max_image_area MAX_IMAGE_AREA]</span><br></pre></td></tr></table></figure><p>此命令将完成所有工作。它负责搜索图像、分析图像并将图像中发现的人脸聚类到相似的人群中。</p><p>请注意，此命令会占用大量 CPU 和内存！在将其放入 cron 作业之前，建议先手动尝试，以确保满足所有要求并且计算机上有足够的资源。</p><p>命令旨在连续运行，因此您需要使用 cron 安排它每隔一段时间执行一次，并指定超时时间。它可以每 15 分钟运行一次，超时为<code>-t 900</code>（因此，它会在 15 分钟后自动停止，cron 将再次启动它），或者每天运行一次，超时为 2 小时，例如<code>-t 7200</code>.</p><p>如果<code>USER_ID</code>提供，它将只循环遍历给定用户的文件。请记住，每个用户都必须单独启用分析，否则此命令将忽略该用户。</p><p>如果<code>TIMEOUT</code>提供，它将在指定的秒数后停止，并在下一次执行中继续。将此值与计划任务的时间结合使用，以在一天中分配系统负载。</p><p>如果<code>MAX_IMAGE_AREA</code>提供，则限制要馈送到神经网络的图像的最大区域（以像素 ^2 为单位），从而有效地降低所需的内存。如果面部检测随机崩溃，请使用此选项。</p><p>如果使用该<code>--defer-clustering</code>选项，它会更改进程的执行顺序，在分析结束时延迟面部聚类，以便让人员简单地执行命令。</p><p>配置完成后可以利用该命令启动人脸识别，</p><p>并且可以设置定时任务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo crontab -e</span><br><span class="line"><span class="comment"># 在其中输入如下内容</span></span><br><span class="line">*/15 * * * * <span class="built_in">cd</span> /var/www/html/nextcloud &amp;&amp; sudo -u www-data php occ face:background_job -u anking &gt;&gt; log_file_path 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>这将每15分钟执行一次人脸识别聚类任务</p></li><li><p>重置信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">occ face:reset [--all] [--model] [--image-errors] [--clustering] [-u|--user_id USER_ID]</span><br></pre></td></tr></table></figure><p>该命令可以彻底清除所有图像、人脸和人群。如果您想出于任何原因从头开始，这是理想的选择。</p><p>您必须指定是否要完全重置数据库<code>[--all]</code>或仅重置当前模型<code>[--model]</code>并且必须再次分析所有图像，或者您可以仅重置人员的聚类<code>[--clustering]</code>并且只需要再次进行聚类，或者仅重置具有的图像错误 <code>[--image-errors]</code>尝试再次分析它们。</p><p>如果<code>USER_ID</code>提供，它只会重置特定用户的信息。</p></li><li><p>统计数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">occ face:stats [-u|--user_id USER_ID] [-j|--json]</span><br></pre></td></tr></table></figure><p>此命令返回找到的图像、面孔和人员数量的摘要。</p><p>如果<code>USER_ID</code>提供，则只返回给定用户的统计信息。</p><p>如果使用<code>--json</code>参数，它会以更适合用其他工具解析的 json 格式打印统计信息。</p></li><li><p>迁移模型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">occ face:migrate [-m|--model_id MODEL_ID] [-u|--user_id USER_ID]</span><br></pre></td></tr></table></figure><p>此命令允许将模型中获得的面迁移到新的面。请注意，人员姓名不会迁移，用户必须重新命名。Always 建议从头开始分析任何已配置的模型，但迁移它可以节省大量时间。</p><p>您必须使用该选项指定要迁移的模型<code>MODEL_ID</code>。</p><p>如果<code>USER_ID</code>提供，只需迁移给定用户的面孔。</p></li></ol><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>官方：<a href="https://github.com/matiasdelellis/facerecognition/wiki/FAQ">https://github.com/matiasdelellis/facerecognition/wiki/FAQ</a></p><p>里面有一些常见的问题，有用的就是设置不想分析的图像，让人脸检测的时候忽略并跳过他们：</p><p>在想忽略的文件的根目录下创建一个<code>.nomedia</code>文件即可。</p>]]></content>
      
      
      <categories>
          
          <category> Nas </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Nextcloud </tag>
            
            <tag> 人脸检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>frp内网穿透</title>
      <link href="/2023/02/08/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
      <url>/2023/02/08/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="frp介绍"><a href="#frp介绍" class="headerlink" title="frp介绍"></a>frp介绍</h1><p>frp 是一种快速反向代理，允许您将位于 NAT 或防火墙后面的本地服务器暴露给 Internet。它目前支持<strong>TCP</strong>和<strong>UDP</strong>，以及<strong>HTTP</strong>和<strong>HTTPS</strong>协议，可以通过域名将请求转发到内部服务。</p><p>frp 还提供了 P2P 连接模式。</p><p>官方网站：<a href="https://github.com/fatedier/frp">frp官网</a> </p><p>frp官网上有很多详细的介绍，比如搭建SSH、HTTP、HTTPS等穿透。可以按照官方的文档按自己的需要修改配置文件。</p><p>这篇文章主要解决如何用frp配置转发多个HTTP站点。</p><p>由于frp的HTTP只能配置一个<code>vhost_http_port</code> ，因此如果想直接配置多HTTP转发，那就需要配置多个子域名或者自定义域名。而正常的腾讯云的域名解析只允许配置两个免费额度的域名解析。因此，只能换一种解决方法。有钱任性的请绕道。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>利用TCP协议，即：</p><p><code>frps.ini</code>正常配置即可</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">token</span>=your_token</span><br><span class="line"><span class="attr">vhost_http_port</span> = <span class="number">8080</span></span><br><span class="line"><span class="attr">vhost_https_port</span> = <span class="number">7002</span></span><br><span class="line"><span class="attr">dashboard_port</span> = <span class="number">7500</span></span><br><span class="line"><span class="attr">dashboard_user</span> = username</span><br><span class="line"><span class="attr">dashboard_pwd</span> = password</span><br></pre></td></tr></table></figure><p><code>frpc.ini</code>配置</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = server_ip</span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="attr">token</span>=you_token</span><br><span class="line"></span><br><span class="line"><span class="section">[ssh]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">22</span></span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">6000</span></span><br><span class="line"></span><br><span class="line"><span class="section">[web01]</span></span><br><span class="line"><span class="attr">type</span> = http</span><br><span class="line"><span class="attr">local_port</span> = <span class="number">80</span></span><br><span class="line"><span class="attr">custom_domains</span> = www.example.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将type改为tcp，设置local_port以及remote_port</span></span><br><span class="line"><span class="section">[web02]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">3000</span></span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">8083</span></span><br><span class="line"></span><br><span class="line"><span class="section">[web03]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">local_port</span> = <span class="number">3001</span></span><br><span class="line"><span class="attr">remote_port</span> = <span class="number">8084</span></span><br></pre></td></tr></table></figure><p>此时就可以同时访问三个http服务</p><p><a href="http://www.example.com:8080">http://www.example.com:8080</a> =&gt; localhost:80</p><p><a href="http://www.example.com:8083">http://www.example.com:8083</a> =&gt; localhost:3000</p><p><a href="http://www.example.com:8084">http://www.example.com:8084</a> =&gt; localhost:3001</p><h1 id="设置frp开机自启动"><a href="#设置frp开机自启动" class="headerlink" title="设置frp开机自启动"></a>设置frp开机自启动</h1><p>在 <code>/etc/systemd/system</code> 中新建文件：<code>frpc.service</code> 并写入如下内容：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=Frpc</span><br><span class="line"><span class="attr">After</span>=network.target</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Type</span>=simple</span><br><span class="line"><span class="attr">User</span>=anking</span><br><span class="line"><span class="attr">ExecStart</span>=/opt/frp/frpc -c /opt/frp/frpc.ini</span><br><span class="line"><span class="attr">Restart</span>=<span class="literal">on</span>-failure</span><br><span class="line"><span class="attr">RestartPreventExitStatus</span>=<span class="number">24</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure><p>然后：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> frpc</span><br><span class="line">sudo systemctl start frpc</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Frp </tag>
            
            <tag> 内网穿透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建私人照片服务器LibrePhotos</title>
      <link href="/2023/02/08/%E6%90%AD%E5%BB%BA%E7%A7%81%E4%BA%BA%E7%85%A7%E7%89%87%E6%9C%8D%E5%8A%A1%E5%99%A8LibrePhotos/"/>
      <url>/2023/02/08/%E6%90%AD%E5%BB%BA%E7%A7%81%E4%BA%BA%E7%85%A7%E7%89%87%E6%9C%8D%E5%8A%A1%E5%99%A8LibrePhotos/</url>
      
        <content type="html"><![CDATA[<h1 id="LibrePhotos简单介绍"><a href="#LibrePhotos简单介绍" class="headerlink" title="LibrePhotos简单介绍"></a>LibrePhotos简单介绍</h1><p>官网：<a href="https://docs.librephotos.com/">LibrePhotos官网</a> </p><blockquote><p>LibrePhotos 将您的所有照片和数据保存在您的本地计算机上，您的数据永远不会发送或存储在第 3 方服务器上，在避免个人数据和隐私泄露的情况下获得与那些商业软件相似的服务体验。它具有以下特点：<br>1、支持所有类型的照片，包括raw，支持视频<br>2、具备时间线视图<br>3、扫描文件夹内的图片<br>4、支持多用户使用<br>5、可以生成照片专辑<br>6、人脸识别/人脸分类<br>7、支持地理编码<br>8、物体/场景检测<br>9、语义图像搜索<br>10、按元数据搜索</p></blockquote><h1 id="Docker方式安装"><a href="#Docker方式安装" class="headerlink" title="Docker方式安装"></a>Docker方式安装</h1><p>建议您使用 docker compose，因为它最适合演示和开发环境。需要 x86 或 ARM64 处理器，建议配备 4GB 内存。由于内存和处理能力有限，ARM64 不会那么快。将需要至少 10 GB 的 HDD 空间用于 docker 映像。由于机器学习模型，它需要那个空间。Librephotos 还将创建一个数据库和缩略图，这将需要额外的空间。</p><ol><li><p>克隆仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/LibrePhotos/librephotos-docker.git</span><br><span class="line"><span class="built_in">cd</span> librephotos-docker</span><br></pre></td></tr></table></figure></li><li><p>复制模板变量文件（包含照片位置等选项）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> librephotos.env .<span class="built_in">env</span></span><br></pre></td></tr></table></figure></li><li><p>修改其中的内容。主要需要在其中添加如下行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shhhKey=shadow<span class="comment"># 密钥</span></span><br><span class="line">adminEmail=your_email</span><br><span class="line">userName=your_username</span><br><span class="line">userPass=your_password</span><br><span class="line">allowUpload=<span class="literal">true</span></span><br><span class="line">HEAVYWEIGHT_PROCESS=2</span><br></pre></td></tr></table></figure></li><li><p>在<code>.env</code>文件中添加了<code>shhhKey</code>后直接运行还是会出现错误，因此需要修改<code>docker-compose.yml</code>文件：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DO NOT EDIT</span></span><br><span class="line"><span class="comment"># The .env file has everything you need to edit.</span></span><br><span class="line"><span class="comment"># Run options:</span></span><br><span class="line"><span class="comment"># 1. Use prebuilt images (preferred method):</span></span><br><span class="line"><span class="comment">#   run cmd: docker-compose up -d</span></span><br><span class="line"><span class="comment"># 2. Build images on your own machine:</span></span><br><span class="line"><span class="comment">#   build cmd: COMPOSE_DOCKER_CLI_BUILD=1 DOCKER_BUILDKIT=1 docker-compose build</span></span><br><span class="line"><span class="comment">#   run cmd: docker-compose up -d</span></span><br><span class="line"></span><br><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">proxy:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">reallibrephotos/librephotos-proxy:$&#123;tag&#125;</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">proxy</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$&#123;scanDirectory&#125;:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$&#123;data&#125;/protected_media:/protected_media</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$&#123;httpPort&#125;:80</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">backend</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">frontend</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres:13</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">db</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">POSTGRES_USER=$&#123;dbUser&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">POSTGRES_PASSWORD=$&#123;dbPass&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">POSTGRES_DB=$&#123;dbName&#125;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$&#123;data&#125;/db:/var/lib/postgresql/data</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">postgres</span> <span class="string">-c</span> <span class="string">fsync=off</span> <span class="string">-c</span> <span class="string">synchronous_commit=off</span> <span class="string">-c</span> <span class="string">full_page_writes=off</span> <span class="string">-c</span> <span class="string">random_page_cost=1.0</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> <span class="string">psql</span> <span class="string">-U</span> <span class="string">$&#123;dbUser&#125;</span> <span class="string">-d</span> <span class="string">$&#123;dbName&#125;</span> <span class="string">-c</span> <span class="string">&quot;SELECT 1;&quot;</span></span><br><span class="line">      <span class="attr">interval:</span> <span class="string">5s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">5s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">frontend:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">reallibrephotos/librephotos-frontend:$&#123;tag&#125;</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">frontend</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    </span><br><span class="line">  <span class="attr">backend:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">reallibrephotos/librephotos:$&#123;tag&#125;</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">backend</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$&#123;scanDirectory&#125;:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$&#123;data&#125;/protected_media:/protected_media</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$&#123;data&#125;/logs:/logs</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$&#123;data&#125;/cache:/root/.cache</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">    <span class="comment"># 将shhhKey修改为如下</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SECRET_KEY=$&#123;shhhhKey:-shadow934.&#125;</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">BACKEND_HOST=backend</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ADMIN_EMAIL=$&#123;adminEmail:-&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ADMIN_USERNAME=$&#123;userName:-&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ADMIN_PASSWORD=$&#123;userPass:-&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_BACKEND=postgresql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_NAME=$&#123;dbName&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_USER=$&#123;dbUser&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_PASS=$&#123;dbPass&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_HOST=$&#123;dbHost&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_PORT=5432</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REDIS_HOST=redis</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REDIS_PORT=6379</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MAPBOX_API_KEY=$&#123;mapApiKey:-&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">WEB_CONCURRENCY=$&#123;gunniWorkers:-1&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SKIP_PATTERNS=$&#123;skipPatterns:-&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ALLOW_UPLOAD=$&#123;allowUpload:-false&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DEBUG=0</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">HEAVYWEIGHT_PROCESS=$&#123;HEAVYWEIGHT_PROCESS:-&#125;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="attr">db:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line">      <span class="attr">redis:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:6</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [ <span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;redis-cli&quot;</span>, <span class="string">&quot;--raw&quot;</span>, <span class="string">&quot;incr&quot;</span>, <span class="string">&quot;ping&quot;</span> ]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">5s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">5s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">12</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>接下来运行<code>docker-compose</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo docker-compose down</span><br><span class="line">sudo docker-compose -f docker-compose.yml up -d</span><br></pre></td></tr></table></figure></li><li><p>等待容器创建完成，验证容器正常运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker-compose ps</span><br></pre></td></tr></table></figure><p><img src="image-20230608135721749.png" alt="image-20230608135721749"></p></li></ol><p>到此，LibrePhotos搭建完成，输入<a href="http://ip:端口">http://ip:端口</a> 即可访问。</p><h1 id="同步nextcloud中的照片"><a href="#同步nextcloud中的照片" class="headerlink" title="同步nextcloud中的照片"></a>同步nextcloud中的照片</h1><p>登陆LibrePhotos后，在此页面输入Nextcloud的服务器地址、用户名、密码信息，点击<code>update Nextcloud crendentials</code> </p><p><img src="image-20230608140142970.png" alt="image-20230608140142970"></p><p>随后点击<code>change</code>，并选择需要同步照片的Nextcloud文件夹：<img src="image-20230608140235108.png" alt="image-20230608140235108"></p><p>点击<code>update</code> 。</p><p>然后点击<code>Scan photos</code><br><img src="image-20230608140352650.png" alt="image-20230608140352650"></p>]]></content>
      
      
      <categories>
          
          <category> Nas </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Docker </tag>
            
            <tag> LibrePhotos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建nextcloud文件同步服务器</title>
      <link href="/2023/02/07/%E6%90%AD%E5%BB%BAnextcloud%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2023/02/07/%E6%90%AD%E5%BB%BAnextcloud%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建-Nextcloud-服务器"><a href="#搭建-Nextcloud-服务器" class="headerlink" title="搭建 Nextcloud 服务器"></a>搭建 Nextcloud 服务器</h1><p>服务器版本：Ubuntu22.04</p><h2 id="安装-Nextcloud"><a href="#安装-Nextcloud" class="headerlink" title="安装 Nextcloud"></a>安装 Nextcloud</h2><ol><li><p>更新软件包索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">sudo apt update</span><br></pre></td></tr></table></figure></li><li><p>安装 Apache、MySQL、PHP<br>Nextcloud 需要一个 Web 服务器，这里使用 Apache, 一个数据库服务器，MariaDB 或者 MySQL，以及 PHP, 可以使用以下命令安装所需的组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">sudo apt install apache2</span><br><span class="line">sudo apt install mysql-server</span><br><span class="line">sudo apt install php-fpm php-mysql php-zip php-gd php-mbstring php-curl php-xml php-imagick</span><br></pre></td></tr></table></figure><blockquote><p>修改状态：sudo systemctl status|start|stop|restart|enable|disable apache2</p><p>站点目录：/var/www</p><p>安装目录：/etc/apache2</p><p>全局配置：/etc/apache2/apache2.conf</p><p>坚挺端口：/etc/apache2/ports.conf</p></blockquote></li><li><p>创建 Nextcloud 的数据库和用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">sudo mysql -u root -p</span><br></pre></td></tr></table></figure><p>进入数据库后执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SQL</span><br><span class="line"># 创建新用户</span><br><span class="line">CREATE USER &#x27;username&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;password&#x27;;</span><br><span class="line"># 创建nextcloud数据库</span><br><span class="line">CREATE DATABASE nextcloud;</span><br><span class="line"># 给用户nextcloud全部权限</span><br><span class="line">GRANT ALL PRIVILEGES ON nextcloud.* TO &#x27;username&#x27;@&#x27;localhost&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line">exit;</span><br></pre></td></tr></table></figure></li><li><p>配置 Apache</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">sudo vim /etc/apache2/apache2.conf</span><br></pre></td></tr></table></figure><p>在最后面添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">AddType application/x-httpd-php .php .html .htm</span><br><span class="line">AddDefaultCharset UTF-8</span><br></pre></td></tr></table></figure><p>然后重启服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">sudo systemctl restart apache2</span><br></pre></td></tr></table></figure></li><li><p>下载 Nextcloud 服务器版</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">cd /var/www/html</span><br><span class="line">sudo wget https://download.nextcloud.com/server/releases/latest.zip</span><br><span class="line">sudo unzip latest.zip</span><br><span class="line">sudo chown -R www-data:www-data nextcloud/</span><br><span class="line">sudo chmod 777 nextcloud -Rf</span><br><span class="line">sudo rm latest.zip</span><br></pre></td></tr></table></figure></li><li><p>接下来重启 Apache，然后输入 <code>http://server_ip/nextcloud</code> 就可以访问 Nextcloud。</p></li></ol><p><img src="image-20230606152855294.png" alt="image-20230606152855294"></p><h2 id="修改-Nextcloud-数据的存放位置"><a href="#修改-Nextcloud-数据的存放位置" class="headerlink" title="修改 Nextcloud 数据的存放位置"></a>修改 Nextcloud 数据的存放位置</h2><ol><li><p>停止 Apache 服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">sudo systemctl stop apache2</span><br></pre></td></tr></table></figure></li><li><p>将现有数据目录复制到新的位置。假设当前数据目录位于 <code>/var/www/html/nextcloud/data</code> 将其复制到新的位置（例如：<code>/new/data/path</code>）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">sudo cp -rp /var/www/html/nextcloud/data /new/data/path</span><br></pre></td></tr></table></figure></li><li><p>修改 Nextcloud 的配置文件 <code>config.php</code> 将数据目录路径更新为新的位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">sudo vim /var/www/html/nextcloud/config/config.php</span><br></pre></td></tr></table></figure><p>在 <code>config.php</code> 文件中，找到 <code>datadirectory</code> 参数，并将其值修改为新的数据目录的路径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">&#x27;datadirectory&#x27; =&gt; &#x27;/new/data/path&#x27;,</span><br></pre></td></tr></table></figure><p>保存并关闭文件</p></li><li><p>更新文件权限和所有权，确保 Nextcloud 可以访问新的数据目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">sudo chown -R www-data:www-data /new/data/path</span><br><span class="line">sudo chmod -R 750 /new/data/path</span><br></pre></td></tr></table></figure><p>这将将新的数据目录设置为 Nextcloud 用户（通常为 <code>www-data</code>）的所有权，并设置适当的权限。</p></li><li><p>启动 Nextcloud 服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">sudo systemctl start apache2</span><br></pre></td></tr></table></figure></li></ol><h1 id="优化-Nextcloud"><a href="#优化-Nextcloud" class="headerlink" title="优化 Nextcloud"></a>优化 Nextcloud</h1><h2 id="启用缓存"><a href="#启用缓存" class="headerlink" title="启用缓存"></a>启用缓存</h2><p>同时开启 <code>APCu</code> 和 <code>Redis</code> 缓存</p><ol><li><p>安装和配置 APCu：</p><ul><li><p>安装 APCu 扩展：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install php-apcu</span><br></pre></td></tr></table></figure></li><li><p>配置 APCu 扩展：</p><p>编辑 PHP 配置文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">sudo nano /etc/php/&lt;version&gt;/apache2/php.ini   # 如果使用 Apache 服务器</span><br><span class="line">sudo nano /etc/php/&lt;version&gt;/fpm/php.ini       # 如果使用 PHP-FPM 或 Nginx 服务器</span><br></pre></td></tr></table></figure><p>添加或修改一下行来启用 APCu：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">extension=apcu.so</span><br><span class="line">apc.enable_cli=1</span><br></pre></td></tr></table></figure><p>保存并关闭文件</p></li></ul></li><li><p>安装和配置 Redis：</p><ul><li><p>安装 Redis 服务器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">sudo apt install redis-server</span><br></pre></td></tr></table></figure></li><li><p>配置 Redis 服务器：<br>编辑 Redis 配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">sudo vim /etc/redis/redis.conf</span><br></pre></td></tr></table></figure><p>在文件中找到 <code>supervised</code> 行，将其值改为 <code>systemd</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">supervised systemd</span><br></pre></td></tr></table></figure></li><li><p>重启 Redis 服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">sudo systemctl restart redis-server</span><br></pre></td></tr></table></figure></li><li><p>安装 Redis PHP 扩展</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">sudo apt install php-redis</span><br></pre></td></tr></table></figure></li></ul></li><li><p>配置 Nextcloud 使用 APCu 和 Redis：<br>编辑 Nextcloud 的配置文件 <code>config.php</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">sudo vim /var/www/html/nextcloud/config/config.php</span><br></pre></td></tr></table></figure><p>添加以下行来配置 APCu 和 Redis</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PHP</span><br><span class="line">&#x27;memcache.local&#x27; =&gt; &#x27;\\OC\\Memcache\\APCu&#x27;,</span><br><span class="line">&#x27;memcache.distributed&#x27; =&gt; &#x27;\\OC\\Memcache\\Redis&#x27;,</span><br><span class="line">&#x27;redis&#x27; =&gt; array(</span><br><span class="line">      &#x27;host&#x27; =&gt; &#x27;localhost&#x27;,</span><br><span class="line">      &#x27;port&#x27; =&gt; 6379,</span><br><span class="line">      &#x27;password&#x27; =&gt; &#x27;Shadow934.&#x27;,</span><br><span class="line">      &#x27;read_timeout&#x27; =&gt; 0.0,</span><br><span class="line">      &#x27;dbindex&#x27; =&gt; 0,</span><br><span class="line">),</span><br></pre></td></tr></table></figure></li><li><p>重启 Web 服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">sudo systemctl restart apache2</span><br></pre></td></tr></table></figure></li></ol><h2 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h2><ol><li><p>启用文件缓存：<br>在 Nextcloud 的配置文件 <code>config.php</code> 中，设置 <code>&#39;filelocking.enabled&#39; =&gt; true, &#39;memcache.locking&#39; =&gt; &#39;\OC\Memcache\Redis&#39;,</code>。这将启用文件锁定并将其存储在 Redis 中，提高并发访问时的性能。</p></li><li><p>调整文件扫描间隔：<br>在 Nextcloud 的配置文件 <code>config.php</code> 中，设置 <code>&#39;filesystem_check_changes&#39; =&gt; 1,</code>。这将减小文件扫描的时间间隔，使 Nextcloud 更快地检测到外部文件系统的更改。</p></li><li><p>使用固态硬盘（SSD）：<br>将 Nextcloud 的数据目录和数据库放在固态硬盘上，以提高读写性能和响应速度。</p></li><li><p>配置缓存和压缩选项：<br>在 Nextcloud 的配置文件 <code>config.php</code> 中，启用 <code>&#39;enable_previews&#39; =&gt; true, &#39;enable_avatars&#39; =&gt; true, &#39;enable_local_caching&#39; =&gt; true,</code>。这将启用缓存和预览功能，提高文件和图像访问速度。</p></li><li><p>定期优化数据库：<br>使用数据库优化工具，如 phpMyAdmin 或 MySQLTuner，对 Nextcloud 使用的数据库进行定期优化，以提高数据库性能和查询速度。</p></li><li><p>配置 Web 服务器：<br>针对 Nextcloud 进行适当的 Web 服务器（如 Apache 或 Nginx）配置优化，例如启用压缩、启用缓存、调整并发连接等，以提高 Web 服务器的性能和响应速度。</p></li><li><p>启用 opcache, 提高 PHP 的运行速度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">sudo vim /etc/php/8.1/apache2/php.ini</span><br></pre></td></tr></table></figure><p>编辑 <code>php.ini</code> 文件，添加如下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">INI</span><br><span class="line">opcache.enable=1</span><br><span class="line">opcache.interned_strings_buffer=8</span><br><span class="line">opcache.max_accelerated_files=10000</span><br><span class="line">opcache.memory_consumption=128</span><br><span class="line">opcache.save_comments=1</span><br><span class="line">opcache.revalidate_freq=1</span><br></pre></td></tr></table></figure></li></ol><p>最终添加的 <code>config.php</code> 文件配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PHP</span><br><span class="line">&#x27;filelocking.enabled&#x27; =&gt; true,</span><br><span class="line">&#x27;memcache.locking&#x27; =&gt; &#x27;\\OC\\Memcache\\Redis&#x27;,</span><br><span class="line">&#x27;filesystem_check_changes&#x27; =&gt; 1,</span><br><span class="line">&#x27;enable_previews&#x27; =&gt; true,</span><br><span class="line">&#x27;enable_local_caching&#x27; =&gt; true,</span><br><span class="line">&#x27;memcache.local&#x27; =&gt; &#x27;\\OC\\Memcache\\APCu&#x27;,</span><br><span class="line">&#x27;memcache.distributed&#x27; =&gt; &#x27;\\OC\\Memcache\\Redis&#x27;,</span><br><span class="line">&#x27;redis&#x27; =&gt; array(</span><br><span class="line">      &#x27;host&#x27; =&gt; &#x27;localhost&#x27;,</span><br><span class="line">      &#x27;port&#x27; =&gt; 6379,</span><br><span class="line">      &#x27;password&#x27; =&gt; &#x27;password&#x27;,</span><br><span class="line">      &#x27;read_timeout&#x27; =&gt; 0.0,</span><br><span class="line">      &#x27;dbindex&#x27; =&gt; 0,</span><br><span class="line">),</span><br></pre></td></tr></table></figure><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="trusted-domains-问题"><a href="#trusted-domains-问题" class="headerlink" title="trusted_domains 问题"></a>trusted_domains 问题</h2><p>当服务器 ip 或域名变化之后，需要修改 <code>config.php</code> 文件中的 <code>trusted_domains</code> 将旧的域名或 ip 修改为新的，或者直接加入新的 ip 或域名。</p><hr><h1 id="Ubuntu-连接-Nextcloud-服务"><a href="#Ubuntu-连接-Nextcloud-服务" class="headerlink" title="Ubuntu 连接 Nextcloud 服务"></a>Ubuntu 连接 Nextcloud 服务</h1><ol><li><p>下载 Linux 版本的 Nextcloud<img src="image-20230606152358579.png" alt="image-20230606152358579"></p></li><li><p>赋予 Nextcloud 可执行权限，并运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">sudo chmod +x Nextcloud-3.8.2-x86_64.AppImage</span><br><span class="line">./Nextcloud-3.8.2-x86_64.AppImage</span><br></pre></td></tr></table></figure></li><li><p>登陆并配置同步文件夹<img src="image-20230606152651265.png" alt="image-20230606152651265"></p></li><li><p>可以设置忽略同步的文件：<img src="image-20230606153023780.png" alt="image-20230606153023780"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Nas </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Nextcloud </tag>
            
            <tag> Apache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WSL实践</title>
      <link href="/2023/01/13/WSL%E5%AE%9E%E8%B7%B5/"/>
      <url>/2023/01/13/WSL%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="1、将子系统移动至其他硬盘"><a href="#1、将子系统移动至其他硬盘" class="headerlink" title="1、将子系统移动至其他硬盘"></a>1、将子系统移动至其他硬盘</h1><ol><li>首先查看所有 wsl 子系统：</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">-l</span> <span class="literal">--all</span> <span class="literal">-v</span></span><br></pre></td></tr></table></figure><ol><li>导出分发版为 tar 文件到 d 盘：</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">--export</span> Ubuntu<span class="literal">-20</span>.<span class="number">04</span> d:\wsl<span class="literal">-ubuntu20</span>.<span class="number">04</span>.tar</span><br></pre></td></tr></table></figure><ol><li>注销当前分发版：</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">--unregister</span> Ubuntu<span class="literal">-20</span>.<span class="number">04</span></span><br></pre></td></tr></table></figure><ol><li>重新导入并安装 wsl 在指定的文件夹：</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">--import</span> Ubuntu<span class="literal">-20</span>.<span class="number">04</span> D:\ProgramApp\wsl\Ubuntu<span class="literal">-22</span>.<span class="number">04</span> d:\wsl<span class="literal">-ubuntu20</span>.<span class="number">04</span>.tar <span class="literal">--version</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><ol><li>设置默认登陆用户为安装时的用户名：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubuntu2004 config --default-user zw</span><br></pre></td></tr></table></figure><ol><li>删除 tar 文件：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del d:\wsl-ubuntu20.04.tar</span><br></pre></td></tr></table></figure><h1 id="2、配置wsl使用主机代理"><a href="#2、配置wsl使用主机代理" class="headerlink" title="2、配置wsl使用主机代理"></a>2、配置wsl使用主机代理</h1><p>首先在 <code>Clash for Windows</code> 中打开 <code>allow lan</code> 按钮，然后鼠标移动到上面会出现指定的 ip 地址：<img src="Pasted%20image%2020220622162802.png" alt="Pasted image 20220622162802"></p><p>此时记住 WSL 的 IP 地址：172.20.0.1，以及配置的端口号：7890<br>一般情况下，上面的 WSL IP 地址都会变化，所以，可以在 Ubuntu 中采用自动获取 IP 地址的方法：<br>接着在 WSL 中 输入：<code>sudo gedit ~/.bashrc</code> ，然后在末行写入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> hostip=$(<span class="built_in">cat</span> /etc/resolv.conf |grep -oP <span class="string">&#x27;(?&lt;=nameserver\ ).*&#x27;</span>)</span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">&quot;http://<span class="variable">$&#123;hostip&#125;</span>:7890&quot;</span></span><br><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">&quot;http://<span class="variable">$&#123;hostip&#125;</span>:7890&quot;</span></span><br></pre></td></tr></table></figure><p>到此配置完毕，可以利用 <code>wget google.com</code> 进行测试。</p><h1 id="3、配置-zsh-终端"><a href="#3、配置-zsh-终端" class="headerlink" title="3、配置 zsh 终端"></a>3、配置 zsh 终端</h1><ol><li>安装 zsh<br> <code>sudo apt install zsh</code></li><li>设置 zsh 为默认 shell<br> <code>chsh -s /bin/zsh</code></li><li>安装 ohmyzsh，默认下载文件夹为： <code>~/.oh-my-zsh</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure><ol><li>安装插件：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 语法高亮插件 </span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting </span><br><span class="line"><span class="comment"># 自动提示插件 </span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 autojump 自动跳转插件</span></span><br><span class="line">sudo apt install autojump</span><br></pre></td></tr></table></figure><ol><li>配置 <code>~/.zshrc</code> ： <code>gedit ~/.zshrc</code> 并搜索 <code>plugins</code> ，之后写入所有插件名：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plugins=(</span><br><span class="line">git</span><br><span class="line">z</span><br><span class="line">extract <span class="comment"># 快速解压缩</span></span><br><span class="line">zsh-autosuggestions</span><br><span class="line">zsh-syntax-highlighting</span><br><span class="line">autojump</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol><li>之后输入 <code>source ~/zshrc</code>  让其生效。</li></ol><h1 id="4、安装-anaconda"><a href="#4、安装-anaconda" class="headerlink" title="4、安装 anaconda"></a>4、安装 anaconda</h1><p>直接在 anaconda 官网下载 <code>.sh</code> 文件，然后复制到 <code>/tmp</code> 文件夹下，接着运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh Anaconda3-2022.05-Linux-x86_64.sh</span><br></pre></td></tr></table></figure><p>或者直接在 <code>zsh</code> 中运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://repo.anaconda.com/archive/Anaconda3-2022.05-Linux-x86_64.sh</span><br><span class="line"></span><br><span class="line">sh Anaconda3-2022.05-Linux-x86_64.sh</span><br></pre></td></tr></table></figure><h1 id="5、配置-GNOME-桌面版-Ubuntu"><a href="#5、配置-GNOME-桌面版-Ubuntu" class="headerlink" title="5、配置 GNOME 桌面版 Ubuntu"></a>5、配置 GNOME 桌面版 Ubuntu</h1><p><a href="https://os.51cto.com/article/698844.html">Windows中WSL2 配置运行GNOME桌面版 Ubuntu-51CTO.COM</a></p><h1 id="Centos87"><a href="#Centos87" class="headerlink" title="==Centos87=="></a>==Centos87==</h1><h2 id="1、卸载-Centos7"><a href="#1、卸载-Centos7" class="headerlink" title="1、卸载 Centos7"></a>1、卸载 Centos7</h2><p>在 <code>PowerShell</code> 中切换到 <code>Centos7</code> 的安装目录下，运行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./Centos8.exe clean</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> WSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3总结</title>
      <link href="/2023/01/07/Vue3%E6%80%BB%E7%BB%93/"/>
      <url>/2023/01/07/Vue3%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>学习视频：<a href="https://www.bilibili.com/video/BV1j5411o7xH?p=1&amp;vd_source=a7a1e61bb0348aaf12b5c40afdecb042">Vue后台管理系统项目实战/Vue+element-ui</a> </p><h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><p>视频：<a href="https://www.bilibili.com/video/BV1C3411s7bV/?p=3&amp;spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=a7a1e61bb0348aaf12b5c40afdecb042">vue3基础入门</a></p><h2 id="组合式-API"><a href="#组合式-API" class="headerlink" title="组合式 API"></a>组合式 API</h2><h3 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">setup() &#123;</span><br><span class="line">const msg = &#x27;Welcome to Your Vue.js App&#x27;</span><br><span class="line">const arr = [1, 2, 3]</span><br><span class="line">function btn() &#123;</span><br><span class="line">console.log(&#x27;click&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">return &#123;msg,arr,btn&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>vue3 中的 js  的必选项，包裹所有定义的属性和方法，最后需要在 return 中将定义的所有属性和方法 return 出去才能在 \<template\> 中使用<br>两种定义方法的方式：</template\></p><ol><li>常规的 function： <code>function btn()&#123; console.log(&quot;ssss&quot;)&#125;</code> </li><li>箭头函数： <code>const btn = () =&gt;&#123; console.log(&quot;sss&quot;) &#125;</code></li></ol><hr><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>需要引入： <code>import &#123;ref&#125; from &#39;vue&#39;</code> //组合式api</p><ul><li>当 ref 里的值发生改变时，视图层会自动更新</li><li>ref 可操作基本数据类型，也可操作复杂数据类型：对象，数组</li><li><strong>建议：*</strong> ref 用来操作基本数据类型：数字，字符串。</li><li>用法： <code>const name = ref(&quot;zhangsan&quot;)</code> </li><li>在 js 中取值时，语法结构为： <code>name.value = &#39;lisi&#39;</code> </li></ul><hr><h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><p>需要引入： <code>import &#123;reactive&#125; from &#39;vue&#39;</code> </p><ul><li>reactive 同样为值创建了一个响应式的引用</li><li>定义基本普通类型数据<strong><em>不能</em></strong> 用 reactive，必须用 ref</li><li>reactive 主要定义复杂数据类型，比如数组，对象</li><li>reactive 可响应深层次的数据，比如多维数组</li><li>reactive 返回一个响应式的 proxy 对象。</li><li>用法： <code>const product = reactive(&#123;name:&#39;zhangsan&#39;,age:18&#125;)</code></li><li>在 js 中取值时，语法结构为： <code>product.name = &#39;lisi&#39;</code></li></ul><hr><h3 id="toRef"><a href="#toRef" class="headerlink" title="toRef"></a>toRef</h3><p>需要引入： <code>import &#123;toRef&#125; from &#39;vue&#39;</code> </p><ul><li>toRef 也可以创建一个响应式数据</li><li>ref 本质是 <strong>拷贝粘贴</strong> 一份数据，脱离了与原数据的交互</li><li>ref 函数将对象中的属性变成了响应式数据，修改响应式数据是不会影响到原数据，但是会更新视图层</li><li>toRef 的本质是引用，与原始数据有交互，修改响应式数据会影响到原数据，但是不会更新视图层。</li></ul><hr><h3 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs"></a>toRefs</h3><p>需要引入： <code>import &#123;toRefs&#125; from &#39;vue&#39;</code> </p><ul><li>用于批量设计多个数据为响应式数据，主要针对对象，</li><li>toRefs 与原数据有交互，修改响应式数据会影响到原数据，但是不会更新视图层</li><li>toRefs 还可以与其他响应式函数交互，更加方便处理是图层数据</li><li>用法： <code>toRefs(obj)</code> </li></ul><hr><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><p>需要引入： <code>import &#123;computed&#125; from &#39;vue&#39;</code> </p><ul><li>与 vue2 一致，均是用来监听数据变化</li><li>用法：同一个页面可以有多个计算属性</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">const sum = computed(()=&gt;&#123;</span><br><span class="line">return num1.value + num2.value</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="watch-侦听器"><a href="#watch-侦听器" class="headerlink" title="watch 侦听器"></a>watch 侦听器</h3><p>需要引入： <code>import &#123;watch&#125; from &#39;vue&#39;</code> </p><ul><li>与 vue2 一致，均是用来监听数据变化</li><li>用法： 可以有多个侦听器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">const age = ref(18)</span><br><span class="line">const ageWatch = watch(age,(value,oldValue)=&gt;&#123;</span><br><span class="line">console.log(&#x27;新值&#x27;+value,&#x27;旧值&#x27;+oldValue)</span><br><span class="line">if(age&gt;25)&#123;</span><br><span class="line">ageWatch()</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h3><p>需要引入： <code>import &#123;watchEffect&#125; from &#39;vue&#39;</code></p><ul><li>watchEffect 如果存在的话，在组建初始化的时候会执行一次用以收集依赖</li><li>watch 可以获取到新值与旧值（更新前的值），而 watchEffect 获取不到</li><li>watchEffect 不需要指定监听的属性，他会自动收集依赖，只要回调中引用到了响应式的属性，那么当这些属性变更时，这个回调都会执行，而 watch 只能监听指定的属性而作出变更。</li><li>用法：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">const res = watchEffect(()=&gt;&#123;</span><br><span class="line">console.log(&quot;不需要指定监听的属性&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="shallowRef-amp-shallowReactive"><a href="#shallowRef-amp-shallowReactive" class="headerlink" title="shallowRef &amp; shallowReactive"></a>shallowRef &amp; shallowReactive</h3><p>需要引入： <code>import &#123;shallowReactive shallowRef&#125; from &#39;vue&#39;</code></p><ul><li>shallowRef 只处理基本数据类型</li><li>shallowReactive 只处理第一层数据</li><li>用法:</li></ul><hr><h2 id="组件传值"><a href="#组件传值" class="headerlink" title="组件传值"></a>组件传值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">// 第一种，进入页面即刻传值</span><br><span class="line">const p1 = reactive(&#123;name:&#x27;zhangsan&#x27;,age:18&#125;)</span><br><span class="line">provide(&#x27;p&#x27;,p1) //祖传</span><br><span class="line"></span><br><span class="line">const res = inject(&#x27;p&#x27;) //孙收</span><br><span class="line"></span><br><span class="line">// 第二种：点击传值</span><br><span class="line">&lt;vue ref=&quot;val&quot;/&gt; // 引入子组件，使用ref调用该子组件</span><br><span class="line">const val = ref()</span><br><span class="line">const p1 = reactive(&#123;name:&#x27;zhangsan&#x27;,age:18&#125;)</span><br><span class="line">function btn()&#123;</span><br><span class="line">val.value.recaive(p1)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ol><li><strong>onBeforeMount:</strong> 在挂在开始之前被调用</li><li><strong>onMounted:</strong> 组件挂在时调用</li><li><strong>onBeforeUpdate:</strong> 数据更新时调用</li><li><strong>onUpdate:</strong> 数据更改导致的虚拟 DOM 重新渲染。在这之后会调用该钩子</li><li><strong>onBeforeUnmounted:</strong> 在卸载组件实例之前调用</li><li><strong>onUnmounted:</strong> 卸载组件实例后调用</li><li><strong>onErrorCaptured:</strong> 当捕获一个来自子孙组件的错误时被调用</li></ol><h2 id="vue3-的抽离封装"><a href="#vue3-的抽离封装" class="headerlink" title="vue3 的抽离封装"></a>vue3 的抽离封装</h2><p>vue3 中的任何一个组合式 api 都可以单独抽离出去在另一个文件，最后只需要回归到 setup（）中即可。</p><h1 id="一、Vue-准备"><a href="#一、Vue-准备" class="headerlink" title="一、Vue 准备"></a>一、Vue 准备</h1><h2 id="1-项目安装依赖"><a href="#1-项目安装依赖" class="headerlink" title="1. 项目安装依赖"></a>1. 项目安装依赖</h2><h3 id="1-前端依赖"><a href="#1-前端依赖" class="headerlink" title="1. 前端依赖"></a>1. 前端依赖</h3><ol><li>创建 vue 项目： <code>vue create &lt;projectName&gt;</code>  并选择 <strong>Manually select features*</strong> <img src="image-20230508183305910.png" alt="image-20230508183305910"></li><li>安装依赖：<ol><li>网络请求： <code>npm i axios -S</code> </li><li>读取网络请求的参数： <code>npm i querystring -S</code></li><li>图表：<code>npm i echarts -S</code> </li><li>element ui: <code>npm i element-plus -S</code> </li><li>日期格式化： <code>npm i dayjs -S</code>     <code>npm i moment -S</code> </li><li>格式化 css： <code>npm i normalize.css -S</code> </li></ol></li></ol><h3 id="2-后端服务-可根据需要安装"><a href="#2-后端服务-可根据需要安装" class="headerlink" title="2. 后端服务 (可根据需要安装)"></a>2. 后端服务 (可根据需要安装)</h3><ol><li>技术：nodejs+mysql+Express</li><li>Node. js 的 Web 应用架构： <code>npm i express -S</code></li><li>跨域资源共享：<code>npm i cors -S</code></li><li>模拟接口： <code>npm i mockjs -S</code>   <code>npm install mockjs</code><br> .</li></ol><h3 id="3-项目初始化"><a href="#3-项目初始化" class="headerlink" title="3. 项目初始化"></a>3. 项目初始化</h3><ol><li>删除无用的组建</li><li>css 初始化</li><li>iconfont 图标</li><li>axios 请求二次封装</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud后端搭建步骤</title>
      <link href="/2022/12/21/SpringCloud%E5%90%8E%E7%AB%AF%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4/"/>
      <url>/2022/12/21/SpringCloud%E5%90%8E%E7%AB%AF%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<p>springcloud 主要有以下几个需要配置：Nacos、Feign、Gateway、RabbitMQ、ElasticSearch。</p><div class="table-container"><table><thead><tr><th>组件</th><th>作用</th></tr></thead><tbody><tr><td>nacos</td><td>微服务的注册和发现</td></tr><tr><td>Feign</td><td>远程调用微服务</td></tr><tr><td>Gateway</td><td>网关，统一入口、身份认证等</td></tr><tr><td>RabbitMQ</td><td>消息队列，异步调用</td></tr><tr><td>ElasticSearch</td><td>搜索引擎</td></tr></tbody></table></div><hr><h1 id="Nacos搭建"><a href="#Nacos搭建" class="headerlink" title="Nacos搭建"></a>Nacos搭建</h1><p>GitHub主页：<a href="https://github.com/alibaba/nacos">https://github.com/alibaba/nacos</a></p><h2 id="1-Nacos安装"><a href="#1-Nacos安装" class="headerlink" title="1.Nacos安装"></a>1.Nacos安装</h2><ol><li><a href="/2022/12/20/Nacos%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/" title="Nacos安装指南">Nacos安装指南</a></li><li><a href="/2022/12/20/Nacos%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/" title="Nacos集群搭建">Nacos集群搭建</a></li></ol><h2 id="2-在项目中配置-Nacos"><a href="#2-在项目中配置-Nacos" class="headerlink" title="2.在项目中配置 Nacos"></a>2.在项目中配置 Nacos</h2><h3 id="1）引入依赖"><a href="#1）引入依赖" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>在cloud-demo父工程的pom文件中的<code>&lt;dependencyManagement&gt;</code>中引入SpringCloudAlibaba的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在所有需要注册和发现的微服务中的 <code>pom.xml</code> 文件中引入 nacos-discovery 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2）配置-nacos-地址"><a href="#2）配置-nacos-地址" class="headerlink" title="2）配置 nacos 地址"></a>2）配置 nacos 地址</h3><p>在所有需要注册和发现的微服务的 <code>application.yml</code> 中添加 nacos 地址:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#nacos的服务地址，可以是单体服务，也可以是集群服务</span></span><br></pre></td></tr></table></figure><p>然后在浏览器中输入：<a href="http://localhost:8848/nacos">http://localhost:8848/nacos</a> 登录 nacos 管理页面，就可以看到微服务信息。</p><h3 id="3）给微服务配置集群"><a href="#3）给微服务配置集群" class="headerlink" title="3）给微服务配置集群"></a>3）给微服务配置集群</h3><p>当同一微服务有多个实例，并且分布在不同机房时，为了加快两个微服务间的通讯，可以为同一机房的微服务设置相同的集群名称。</p><ol><li>修改同一机房的微服务的 <code>application.yaml</code> 文件：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HZ</span> <span class="comment"># 集群名称</span></span><br></pre></td></tr></table></figure><ol><li>设置同集群有限的负载均衡规则，同样修改同一机房的微服务的 <code>application.yaml</code> 文件：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">userservice:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.alibaba.cloud.nacos.ribbon.NacosRule</span> <span class="comment"># 负载均衡规则 </span></span><br></pre></td></tr></table></figure><h3 id="4）-权重配置"><a href="#4）-权重配置" class="headerlink" title="4）*权重配置"></a>4）*权重配置</h3><p>如果同一微服务有多个实例，可以根据实例所在服务器的硬件信息设置不同的权重，充分发挥服务器的性能。或者当需要对微服务进行升级时，可以先将一个微服务的权重设置为0，然后对其升级，之后再慢慢调大权重，达到微服务版本的平滑过渡。</p><p>在控制台中修改权重，找到要修改的微服务实力列表，点击编辑：</p><p><img src="image-20230507233951897.png" alt="image-20230507233951897"></p><p>在弹出的编辑窗口中修改权重：</p><p><img src="image-20230507234105839.png" alt="image-20230507234105839"></p><blockquote><p>注意：如果权重修改为0，则该实例永远不会被访问</p></blockquote><hr><h1 id="Feign-远程调用"><a href="#Feign-远程调用" class="headerlink" title="Feign 远程调用"></a>Feign 远程调用</h1><p>GitHub地址：<a href="https://github.com/OpenFeign/feign">https://github.com/OpenFeign/feign</a></p><p>Feign 是一个声明式的 http 客户端，作用就是帮助我们优雅的实现 http 请求的发送。</p><p>由于很多微服务都需要调用 Feign，所以可以将 Feign 作为一个模块。</p><ol><li>在 <code>feign-api</code> 模块中引入依赖：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--httpClient的依赖，支持连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>在 <code>application.yaml</code> 中添加配置：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span> <span class="comment"># default全局的配置</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">BASIC</span> <span class="comment"># 日志级别，BASIC就是基本的请求和响应信息</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启feign对HttpClient的支持</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="number">200</span> <span class="comment"># 最大的连接数</span></span><br><span class="line">    <span class="attr">max-connections-per-route:</span> <span class="number">50</span> <span class="comment"># 每个路径的最大连接数</span></span><br></pre></td></tr></table></figure><ol><li>在 <code>feign-api</code> 中写入 client 和 pojo 信息。项目结构如下：</li></ol><p><img src="image-20230507234134811.png" alt="image-20230507234134811"></p><p>其中 <code>UserClient.java</code> 文件为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;userservice&quot;)</span> <span class="comment">// 指定需要连接的服务名</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span>  <span class="comment">// 获取user 信息</span></span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>; <span class="comment">// 指定参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>User.java</code> 为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span> <span class="comment">//主要就是返回值的类型类。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在其他微服务中使用 <code>feign-api</code> ，在这些微服务中的 <code>pom.xml</code> 文件中引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>解决扫描包问题</li></ol><p>方式一：指定 Feign 应该扫描的包，在微服务的启动类上添加如下注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(basePackages = &quot;cn.itcast.feign.clients&quot;)</span></span><br></pre></td></tr></table></figure><p>方式二：指定需要加载的 client 接口，同样在微服务的启动类上添加如下注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(clients = &#123;UserClient.class&#125;)</span></span><br></pre></td></tr></table></figure><hr><h1 id="Gateway-服务网关"><a href="#Gateway-服务网关" class="headerlink" title="Gateway 服务网关"></a>Gateway 服务网关</h1><p>网关的核心功能：</p><ul><li>请求路由</li><li>权限控制</li><li>限流</li></ul><h2 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1.引入依赖"></a>1.引入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--网关--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--nacos服务发现依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-编写启动类"><a href="#2-编写启动类" class="headerlink" title="2.编写启动类"></a>2.编写启动类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.gateway;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GatewayApplication</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">SpringApplication.run(GatewayApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-编写基础配置和路由规则"><a href="#3-编写基础配置和路由规则" class="headerlink" title="3.编写基础配置和路由规则"></a>3.编写基础配置和路由规则</h2><p>在 <code>application.yaml</code>中写入如下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10010</span> <span class="comment"># 网关端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span> <span class="comment"># 网关路由配置</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> <span class="comment"># 路由id，自定义，只要唯一即可</span></span><br><span class="line">          <span class="comment"># uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userservice</span> <span class="comment"># 路由的目标地址 lb就是负载均衡，后面跟服务名称</span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment"># 路由断言，也就是判断请求是否符合路由规则的条件</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span> <span class="comment"># 这个是按照路径匹配，只要以/user/开头就符合要求</span></span><br></pre></td></tr></table></figure><h2 id="4-断言工厂、过滤器工厂"><a href="#4-断言工厂、过滤器工厂" class="headerlink" title="4.断言工厂、过滤器工厂"></a>4.断言工厂、过滤器工厂</h2><ol><li>断言工厂</li><li>一共有31中不同的过滤器工厂</li><li>默认过滤器</li><li><strong>全局过滤器</strong>：主要为了自定义过滤请求</li></ol><h2 id="5-跨域问题"><a href="#5-跨域问题" class="headerlink" title="5.跨域问题"></a>5.跨域问题</h2><p>在 <code>gateway</code> 服务的 <code>application.yml</code> 文件中，添加如下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="comment"># 。。。</span></span><br><span class="line">      <span class="attr">globalcors:</span> <span class="comment"># 全局的跨域处理</span></span><br><span class="line">        <span class="attr">add-to-simple-url-handler-mapping:</span> <span class="literal">true</span> <span class="comment"># 解决options请求被拦截问题</span></span><br><span class="line">        <span class="attr">corsConfigurations:</span></span><br><span class="line">          <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span></span><br><span class="line">            <span class="attr">allowedOrigins:</span> <span class="comment"># 允许哪些网站的跨域请求 </span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;http://localhost:8090&quot;</span></span><br><span class="line">            <span class="attr">allowedMethods:</span> <span class="comment"># 允许的跨域ajax的请求方式</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;GET&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;POST&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;DELETE&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;PUT&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;OPTIONS&quot;</span></span><br><span class="line">            <span class="attr">allowedHeaders:</span> <span class="string">&quot;*&quot;</span> <span class="comment"># 允许在请求中携带的头信息</span></span><br><span class="line">            <span class="attr">allowCredentials:</span> <span class="literal">true</span> <span class="comment"># 是否允许携带cookie</span></span><br><span class="line">            <span class="attr">maxAge:</span> <span class="number">360000</span> <span class="comment"># 这次跨域检测的有效期</span></span><br></pre></td></tr></table></figure><hr><h1 id="RabbitMQ-异步通讯"><a href="#RabbitMQ-异步通讯" class="headerlink" title="RabbitMQ 异步通讯"></a>RabbitMQ 异步通讯</h1><h2 id="1-RabbitMQ部署"><a href="#1-RabbitMQ部署" class="headerlink" title="1.RabbitMQ部署"></a>1.RabbitMQ部署</h2><p>参考 <a href="/2022/12/20/RabbitMQ%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/" title="RabbitMQ搭建指南">RabbitMQ搭建指南</a></p><h2 id="2-RabbitMQ的基本知识"><a href="#2-RabbitMQ的基本知识" class="headerlink" title="2.RabbitMQ的基本知识"></a>2.RabbitMQ的基本知识</h2><h3 id="1）RabbitMQ中的一些角色"><a href="#1）RabbitMQ中的一些角色" class="headerlink" title="1）RabbitMQ中的一些角色"></a>1）RabbitMQ中的一些角色</h3><ul><li>publisher：生产者</li><li>consumer：消费者</li><li>exchange：交换机，负责消息路由</li><li>queue：队列，存储消息</li><li>virtualHost：虚拟主机，隔离不同租户的 exchange、queue、消息的隔离</li></ul><h3 id="2）RabbitMQ消息模型"><a href="#2）RabbitMQ消息模型" class="headerlink" title="2）RabbitMQ消息模型"></a>2）RabbitMQ消息模型</h3><ul><li>基本消息队列（Basic Queue）</li><li>工作消息队列（Work Queue）</li><li>发布订阅（Publish、Subscirbe）<ul><li>Fanout Exchange：广播</li><li>Direct Exchange：路由</li><li>Topic Exchange：主题</li></ul></li></ul><h2 id="3-在微服务中配置RabbitMQ"><a href="#3-在微服务中配置RabbitMQ" class="headerlink" title="3.在微服务中配置RabbitMQ"></a>3.在微服务中配置RabbitMQ</h2><p>spring cloud 中利用 <strong>A</strong>dvanced <strong>M</strong>essage <strong>Q</strong>ueuing <strong>P</strong>rotocol（SpingAMQP） 来配置 RabbitMQ。</p><p>官方地址为：<a href="https://spring.io/projects/spring-amqp">Spring AMQP</a></p><h3 id="1）引入依赖-1"><a href="#1）引入依赖-1" class="headerlink" title="1）引入依赖"></a>1）引入依赖</h3><p>在父工程中引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2）发布-订阅模型"><a href="#2）发布-订阅模型" class="headerlink" title="2）发布/订阅模型"></a>2）发布/订阅模型</h3><p>一般情况下，微服务中都采用 发布/订阅模型。具体实现步骤为：</p><h4 id="1-consumer-配置"><a href="#1-consumer-配置" class="headerlink" title="1.consumer 配置"></a>1.consumer 配置</h4><p>首先在 consumer 的 <code>application.yaml</code> 中添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 主机名</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">itcast</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span> <span class="comment"># 密码</span></span><br><span class="line">    <span class="comment"># 以下是同一微服务存在多个实体时需要的配置</span></span><br><span class="line">  <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span></span><br></pre></td></tr></table></figure><p>在 consumer 中的 constants 包下创建一个 <code>MqConstants</code> 类，声明交换机、队列、RoutingKey 等信息，主要是名字：如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqConstants</span> &#123;</span><br><span class="line"><span class="comment">// 交换机</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">HOTEL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;hotel.topic&quot;</span>;</span><br><span class="line">    <span class="comment">// 新增修改队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">HOTEL_INSERT_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;hotel.insert.queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 删除队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">HOTEL_DELETE_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;hotel.delete.queue&quot;</span>;</span><br><span class="line">    <span class="comment">// 新增或删除的routingKey</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">HOTEL_INSERT_KEY</span> <span class="operator">=</span> <span class="string">&quot;hotel.insert&quot;</span>;</span><br><span class="line">    <span class="comment">// 删除的routingKey</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String HOTEL_DELETE_KEY= <span class="string">&quot;hotel.delete&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 consumer 中的 config 包下创建 <code>MqConfig</code> 类，声明交换机、声明队列以及交换机和队列的绑定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> TopicExchange <span class="title function_">topicExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TopicExchange</span>(MqConstants.HOTEL_EXCHANGE,<span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">insertQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(MqConstants.HOTEL_INSERT_QUEUE,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">deleteQUeue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(MqConstants.HOTEL_DELETE_QUEUE,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定队列和交换机的关系</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">bindingInsertBinding</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(insertQueue()).to(topicExchange()).with(MqConstants.HOTEL_INSERT_KEY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">bindingDeleteBinding</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(deleteQUeue()).to(topicExchange()).with(MqConstants.HOTEL_DELETE_KEY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者可以基于注解声明交换机、队列以及绑定两者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = HotelMqConstants.INSERT_QUEUE_NAME),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = HotelMqConstants.EXCHANGE_NAME, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = HotelMqConstants.INSERT_KEY</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenHotelInsert</span><span class="params">(Long hotelId)</span>&#123;</span><br><span class="line">    <span class="comment">// 新增</span></span><br><span class="line">    hotelService.saveById(hotelId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-publisher-配置"><a href="#2-publisher-配置" class="headerlink" title="2.publisher 配置"></a>2.publisher 配置</h4><p>在 publisher 的 <code>application.yaml</code> 中引入配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 主机名</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">itcast</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123321</span> <span class="comment"># 密码</span></span><br><span class="line">    <span class="comment"># 以下是同一微服务存在多个实体时需要的配置</span></span><br><span class="line">  <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span></span><br></pre></td></tr></table></figure><p>在需要发送消息的类中采用如下方法发送消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先引入 RabbitTemplate</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后在方法中发送消息，如：</span></span><br><span class="line">rabbitTemplate.convertAndSend(HotelMqConstants.EXCHANGE_NAME, HotelMqConstants.DELETE_KEY, id);</span><br></pre></td></tr></table></figure><h3 id="3）配置消息转换器"><a href="#3）配置消息转换器" class="headerlink" title="3）配置消息转换器"></a>3）配置消息转换器</h3><p>由于 Spring 默认的消息序列化的方式效果不好，因此需要配置 JSON 转换器。</p><p>在 publisher 和 consumer 两个服务中都引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在启动类中添加 Bean ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">jsonMessageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nacos </tag>
            
            <tag> RabbitMQ </tag>
            
            <tag> SpingCloud </tag>
            
            <tag> Gateway </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nacos安装指南</title>
      <link href="/2022/12/20/Nacos%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/"/>
      <url>/2022/12/20/Nacos%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Windows安装"><a href="#1-Windows安装" class="headerlink" title="1.Windows安装"></a>1.Windows安装</h1><p>开发阶段采用单机安装即可。</p><h2 id="1-1-下载安装包"><a href="#1-1-下载安装包" class="headerlink" title="1.1.下载安装包"></a>1.1.下载安装包</h2><p>在Nacos的GitHub页面，提供有下载链接，可以下载编译好的Nacos服务端或者源代码：</p><p>GitHub主页：<a href="https://github.com/alibaba/nacos">https://github.com/alibaba/nacos</a></p><p>GitHub的Release下载页：<a href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a></p><p>如图：</p><p><img src="image-20230507235022415.png" alt="image-20230507235022415"></p><p>本课程采用1.4.1.版本的Nacos，课前资料已经准备了安装包：</p><p><img src="image-20230507235046156.png" alt="image-20230507235046156"></p><p>windows版本使用<code>nacos-server-1.4.1.zip</code>包即可。</p><h2 id="1-2-解压"><a href="#1-2-解压" class="headerlink" title="1.2.解压"></a>1.2.解压</h2><p>将这个包解压到任意非中文目录下，如图：</p><p><img src="image-20230507235102282.png" alt="image-20230507235102282"></p><p>目录说明：</p><ul><li>bin：启动脚本</li><li>conf：配置文件</li></ul><h2 id="1-3-端口配置"><a href="#1-3-端口配置" class="headerlink" title="1.3.端口配置"></a>1.3.端口配置</h2><p>Nacos的默认端口是8848，如果你电脑上的其它进程占用了8848端口，请先尝试关闭该进程。</p><p><strong>如果无法关闭占用8848端口的进程</strong>，也可以进入nacos的conf目录，修改配置文件中的端口：</p><p><img src="image-20230507235114625-1683474675434-1.png" alt="image-20230507235114625"></p><p>修改其中的内容：</p><p><img src="image-20230507235127817.png" alt="image-20230507235127817"></p><h2 id="1-4-启动"><a href="#1-4-启动" class="headerlink" title="1.4.启动"></a>1.4.启动</h2><p>启动非常简单，进入bin目录，结构如下：</p><p><img src="image-20230507235139340.png" alt="image-20230507235139340"></p><p>然后执行命令即可：</p><ul><li><p>windows命令：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup.cmd -m standalone</span><br></pre></td></tr></table></figure></li></ul><p>执行后的效果如图：</p><p><img src="image-20230507235150506.png" alt="image-20230507235150506"></p><h2 id="1-5-访问"><a href="#1-5-访问" class="headerlink" title="1.5.访问"></a>1.5.访问</h2><p>在浏览器输入地址：<a href="http://127.0.0.1:8848/nacos即可：">http://127.0.0.1:8848/nacos即可：</a></p><p><img src="image-20230507235202982.png" alt="image-20230507235202982"></p><p>默认的账号和密码都是nacos，进入后：</p><p><img src="image-20230507235214071.png" alt="image-20230507235214071"></p><h1 id="2-Linux安装"><a href="#2-Linux安装" class="headerlink" title="2.Linux安装"></a>2.Linux安装</h1><p>Linux或者Mac安装方式与Windows类似。</p><h2 id="2-1-安装JDK"><a href="#2-1-安装JDK" class="headerlink" title="2.1.安装JDK"></a>2.1.安装JDK</h2><p>Nacos依赖于JDK运行，索引Linux上也需要安装JDK才行。</p><p>上传jdk安装包：</p><p><img src="image-20230507235226975-1683474747926-3.png" alt="image-20230507235226975"></p><p>上传到某个目录，例如：<code>/usr/local/</code></p><p>然后解压缩：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf jdk-8u144-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><p>然后重命名为java</p><p>配置环境变量：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/local/java</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br></pre></td></tr></table></figure><p>设置环境变量：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h2 id="2-2-上传安装包"><a href="#2-2-上传安装包" class="headerlink" title="2.2.上传安装包"></a>2.2.上传安装包</h2><p>如图：</p><p><img src="image-20230507235254065.png" alt="image-20230507235254065"></p><p>也可以直接使用课前资料中的tar.gz：</p><p><img src="image-20230507235305625.png" alt="image-20230507235305625"></p><p>上传到Linux服务器的某个目录，例如<code>/usr/local/src</code>目录下：</p><p><img src="image-20230507235314181.png" alt="image-20230507235314181"></p><h2 id="2-3-解压"><a href="#2-3-解压" class="headerlink" title="2.3.解压"></a>2.3.解压</h2><p>命令解压缩安装包：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf nacos-server-1.4.1.tar.gz</span><br></pre></td></tr></table></figure><p>然后删除安装包：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf nacos-server-1.4.1.tar.gz</span><br></pre></td></tr></table></figure><p>目录中最终样式：</p><p><img src="image-20230507235324974.png" alt="image-20230507235324974"></p><p>目录内部：</p><p><img src="image-20230507235334005.png" alt="image-20230507235334005"></p><h2 id="2-4-端口配置"><a href="#2-4-端口配置" class="headerlink" title="2.4.端口配置"></a>2.4.端口配置</h2><p>与windows中类似</p><h2 id="2-5-启动"><a href="#2-5-启动" class="headerlink" title="2.5.启动"></a>2.5.启动</h2><p>在nacos/bin目录中，输入命令启动Nacos：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh startup.sh -m standalone</span><br></pre></td></tr></table></figure><h1 id="3-Nacos的依赖"><a href="#3-Nacos的依赖" class="headerlink" title="3.Nacos的依赖"></a>3.Nacos的依赖</h1><p>父工程：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- nacos客户端依赖包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Skills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nacos </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nacos集群搭建</title>
      <link href="/2022/12/20/Nacos%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
      <url>/2022/12/20/Nacos%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="1-集群结构图"><a href="#1-集群结构图" class="headerlink" title="1.集群结构图"></a>1.集群结构图</h1><p>官方给出的Nacos集群图：</p><p><img src="image-20230507235730614.png" alt="image-20230507235730614"></p><p>其中包含3个nacos节点，然后一个负载均衡器代理3个Nacos。这里负载均衡器可以使用nginx。</p><p>我们计划的集群结构：</p><p><img src="image-20230507235741471.png" alt="image-20230507235741471"></p><p>三个nacos节点的地址：</p><div class="table-container"><table><thead><tr><th>节点</th><th>ip</th><th>port</th></tr></thead><tbody><tr><td>nacos1</td><td>192.168.150.1</td><td>8845</td></tr><tr><td>nacos2</td><td>192.168.150.1</td><td>8846</td></tr><tr><td>nacos3</td><td>192.168.150.1</td><td>8847</td></tr></tbody></table></div><h1 id="2-搭建集群"><a href="#2-搭建集群" class="headerlink" title="2.搭建集群"></a>2.搭建集群</h1><p>搭建集群的基本步骤：</p><ul><li>搭建数据库，初始化数据库表结构</li><li>下载nacos安装包</li><li>配置nacos</li><li>启动nacos集群</li><li>nginx反向代理</li></ul><h2 id="2-1-初始化数据库"><a href="#2-1-初始化数据库" class="headerlink" title="2.1.初始化数据库"></a>2.1.初始化数据库</h2><p>Nacos默认数据存储在内嵌数据库Derby中，不属于生产可用的数据库。</p><p>官方推荐的最佳实践是使用带有主从的高可用数据库集群，主从模式的高可用数据库可以参考<strong>传智教育</strong>的后续高手课程。</p><p>这里我们以单点的数据库为例来讲解。</p><p>首先新建一个数据库，命名为nacos，而后打开网站：<a href="[nacos/mysql-schema.sql at master · alibaba/nacos · GitHub](https://github.com/alibaba/nacos/blob/master/distribution/conf/mysql-schema.sql">nacos-sql</a>)，复制其中的sql代码运行。</p><h2 id="2-2-下载nacos"><a href="#2-2-下载nacos" class="headerlink" title="2.2.下载nacos"></a>2.2.下载nacos</h2><p>nacos在GitHub上有下载地址：<a href="https://github.com/alibaba/nacos/tags，可以选择任意版本下载。">https://github.com/alibaba/nacos/tags，可以选择任意版本下载。</a></p><p>本例中才用1.4.1版本：</p><p><img src="image-20230507235755355.png" alt="image-20230507235755355"></p><h2 id="2-3-配置Nacos"><a href="#2-3-配置Nacos" class="headerlink" title="2.3.配置Nacos"></a>2.3.配置Nacos</h2><p>将这个包解压到任意非中文目录下，如图：</p><p><img src="image-20230507235805722.png" alt="image-20230507235805722"></p><p>目录说明：</p><ul><li>bin：启动脚本</li><li>conf：配置文件</li></ul><p>进入nacos的conf目录，修改配置文件cluster.conf.example，重命名为cluster.conf：</p><p><img src="image-20230507235816396.png" alt="image-20230507235816396"></p><p>然后添加内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:8845</span><br><span class="line">127.0.0.1.8846</span><br><span class="line">127.0.0.1.8847</span><br></pre></td></tr></table></figure><p>然后修改application.properties文件，添加数据库配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.datasource.platform</span>=<span class="string">mysql</span></span><br><span class="line"></span><br><span class="line"><span class="attr">db.num</span>=<span class="string">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">db.url.0</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC</span></span><br><span class="line"><span class="attr">db.user.0</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">db.password.0</span>=<span class="string">123</span></span><br></pre></td></tr></table></figure><h2 id="2-4-启动"><a href="#2-4-启动" class="headerlink" title="2.4.启动"></a>2.4.启动</h2><p>将nacos文件夹复制三份，分别命名为：nacos1、nacos2、nacos3</p><p><img src="image-20230507235830915.png" alt="image-20230507235830915"></p><p>然后分别修改三个文件夹中的application.properties，</p><p>nacos1:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8845</span></span><br></pre></td></tr></table></figure><p>nacos2:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8846</span></span><br></pre></td></tr></table></figure><p>nacos3:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8847</span></span><br></pre></td></tr></table></figure><p>然后分别启动三个nacos节点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup.cmd</span><br></pre></td></tr></table></figure><h2 id="2-5-nginx反向代理"><a href="#2-5-nginx反向代理" class="headerlink" title="2.5.nginx反向代理"></a>2.5.nginx反向代理</h2><p>找到课前资料提供的nginx安装包： </p><p><img src="image-20230507235845720.png" alt="image-20230507235845720"></p><p>解压到任意非中文目录下：</p><p><img src="image-20230507235854726.png" alt="image-20230507235854726"></p><p>修改conf/nginx.conf文件，配置如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> nacos-cluster &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:8845</span>;</span><br><span class="line"><span class="attribute">server</span> <span class="number">127.0.0.1:8846</span>;</span><br><span class="line"><span class="attribute">server</span> <span class="number">127.0.0.1:8847</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /nacos &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://nacos-cluster;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而后在浏览器访问：<a href="http://localhost/nacos即可。">http://localhost/nacos即可。</a></p><p>代码中application.yml文件配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:80</span> <span class="comment"># Nacos地址</span></span><br></pre></td></tr></table></figure><h2 id="2-6-优化"><a href="#2-6-优化" class="headerlink" title="2.6.优化"></a>2.6.优化</h2><ul><li><p>实际部署时，需要给做反向代理的nginx服务器设置一个域名，这样后续如果有服务器迁移nacos的客户端也无需更改配置.</p></li><li><p>Nacos的各个节点应该部署到多个不同服务器，做好容灾和隔离</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Skills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nacos </tag>
            
            <tag> 集群 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ搭建指南</title>
      <link href="/2022/12/20/RabbitMQ%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/"/>
      <url>/2022/12/20/RabbitMQ%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="1-单机部署"><a href="#1-单机部署" class="headerlink" title="1.单机部署"></a>1.单机部署</h1><p>我们在Centos7虚拟机中使用Docker来安装。</p><h2 id="1-1-下载镜像"><a href="#1-1-下载镜像" class="headerlink" title="1.1.下载镜像"></a>1.1.下载镜像</h2><p>方式一：在线拉取</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull rabbitmq:3-management</span><br></pre></td></tr></table></figure><p>方式二：从本地加载</p><p>在课前资料已经提供了镜像包：</p><p><img src="image-20230508000357758.png" alt="image-20230508000357758"></p><p>上传到虚拟机中后，使用命令加载镜像即可：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i mq.tar</span><br></pre></td></tr></table></figure><h2 id="1-2-安装MQ"><a href="#1-2-安装MQ" class="headerlink" title="1.2.安装MQ"></a>1.2.安装MQ</h2><p>执行下面的命令来运行MQ容器：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line"> -e RABBITMQ_DEFAULT_USER=itcast \</span><br><span class="line"> -e RABBITMQ_DEFAULT_PASS=123321 \</span><br><span class="line"> --name mq \</span><br><span class="line"> --hostname mq1 \</span><br><span class="line"> -p 15672:15672 \</span><br><span class="line"> -p 5672:5672 \</span><br><span class="line"> -d \</span><br><span class="line"> rabbitmq:3-management</span><br></pre></td></tr></table></figure><h1 id="2-集群部署"><a href="#2-集群部署" class="headerlink" title="2.集群部署"></a>2.集群部署</h1><p>接下来，我们看看如何安装RabbitMQ的集群。</p><h2 id="2-1-集群分类"><a href="#2-1-集群分类" class="headerlink" title="2.1.集群分类"></a>2.1.集群分类</h2><p>在RabbitMQ的官方文档中，讲述了两种集群的配置方式：</p><ul><li>普通模式：普通模式集群不进行数据同步，每个MQ都有自己的队列、数据信息（其它元数据信息如交换机等会同步）。例如我们有2个MQ：mq1，和mq2，如果你的消息在mq1，而你连接到了mq2，那么mq2会去mq1拉取消息，然后返回给你。如果mq1宕机，消息就会丢失。</li><li>镜像模式：与普通模式不同，队列会在各个mq的镜像节点之间同步，因此你连接到任何一个镜像节点，均可获取到消息。而且如果一个节点宕机，并不会导致数据丢失。不过，这种方式增加了数据同步的带宽消耗。</li></ul><p>我们先来看普通模式集群。</p><h2 id="2-2-设置网络"><a href="#2-2-设置网络" class="headerlink" title="2.2.设置网络"></a>2.2.设置网络</h2><p>首先，我们需要让3台MQ互相知道对方的存在。</p><p>分别在3台机器中，设置 /etc/hosts文件，添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.150.101 mq1</span><br><span class="line">192.168.150.102 mq2</span><br><span class="line">192.168.150.103 mq3</span><br></pre></td></tr></table></figure><p>并在每台机器上测试，是否可以ping通对方：</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Skills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python数据分析</title>
      <link href="/2022/11/20/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
      <url>/2022/11/20/Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="第0章-简介："><a href="#第0章-简介：" class="headerlink" title="第0章 简介："></a>第0章 简介：</h1><h2 id="0-1-必要的Python库"><a href="#0-1-必要的Python库" class="headerlink" title="0.1 必要的Python库"></a>0.1 必要的Python库</h2><h3 id="1-NumPy：-Numerical-Python"><a href="#1-NumPy：-Numerical-Python" class="headerlink" title="1. NumPy： Numerical Python"></a>1. NumPy： <strong><em>Numerical Python</em></strong></h3><p>它提供了大多数涉及 Python 中数值数据的科学应用程序所需的数据结构、算法和库粘合剂。主要包含以下内容：</p><ul><li>一个快速高效的多维数组对象： <strong>ndarry</strong></li><li>使用数组进行元素及计算的方法和数组之间的操作运算符</li><li>将基于数组的数据集读写到磁盘的工具</li><li>线性代数操作、傅里叶变换和随机数生成</li><li>一个成熟的 C API，使 Python 扩展和本机 C 或 C++ 代码能够访问 NumPy的数据机构和计算设施</li></ul><p>在数据分析中的主要作用之一是：作为在算法和库之间传递数据的容器。对于数值数据，NumPy 数组在存储和操作数据方面比其他内置的 Python 数据结构更有效。</p><h3 id="2-Pandas："><a href="#2-Pandas：" class="headerlink" title="2. Pandas："></a>2. Pandas：</h3><p>提供了高级数据结构和函数，旨在使结构化或表格数据的处理变得更直观和灵活。本次学习的 <strong>Pandas</strong> 的主要对象是 <code>DataFrame</code> ：带有行标签和列标签的面向列的表格数据结构。 还有 <code>Series</code> ：一个一维标签的数组对象。</p><p><strong>Pandas</strong> 将 <strong>NumPy</strong> 的数组计算思想与电子表格和关系数据库（如 SQL）中的各种数据操作功能相结合。提供了方便的索引功能，可以进行重塑、切片、切块、执行聚合以及选择数据子集。数据分析的一项重要技能就是：数据操作、准备和清理，因此，Pandas 也非常重要。</p><h3 id="3-matplotlib："><a href="#3-matplotlib：" class="headerlink" title="3. matplotlib："></a>3. matplotlib：</h3><p>用于生成绘图和其他二维数据可视化。</p><h3 id="4-IPython和Jupyter："><a href="#4-IPython和Jupyter：" class="headerlink" title="4. IPython和Jupyter："></a>4. IPython和Jupyter：</h3><p><strong>IPython</strong>： 交互式计算和软件开发。还提供了对操作系统外壳和文件系统的集成访问。</p><p><strong>Jupyter</strong> ：与语言无关的交互式计算工具。基于 Web 的交互式代码“笔记本”。</p><p><strong><em>IPython</em></strong> 和 <strong><em>Jupyter notebook</em></strong> 对数据探索和可视化特别有用。</p><h3 id="5-SciPy："><a href="#5-SciPy：" class="headerlink" title="5. SciPy："></a>5. SciPy：</h3><p>解决科学计算中许多基本问题的软件包的集合。</p><ul><li><code>scipy.integrate</code> 数值积分运算和微分方程求解</li><li><code>scipy.linalg</code> 线性代数运算和超出了 <code>numpy.linalg</code> 范围之外的矩阵的分解</li><li><code>scipy.optimize</code> 函数优化器（最小化器）和求根算法</li><li><code>scipy.signal</code> 信号处理工具</li><li><code>scipy.sparse</code> 稀疏矩阵和稀疏线性系统求解器</li><li><code>scipy.special</code> SPECFUN的包装器，一个实现许多常见数学函数的Fortran库，包括 <code>gamma</code> 函数</li><li><code>scipy.stats</code> 标准连续和离散概率分布（密度函数，样本，连续分布函数），各种统计检验和很多描述性统计</li></ul><h3 id="6-scikit-learn："><a href="#6-scikit-learn：" class="headerlink" title="6. scikit-learn："></a>6. scikit-learn：</h3><p>首选的通用机器学习工具包。包括如下模块：</p><ul><li>分类：SVM、最邻近、随机森林、逻辑回归等</li><li>回归：Lasso、岭回归等</li><li>聚类：k-means、谱聚类等</li><li>降维：PCA、特征选择、矩阵分解等</li><li>模型选择：网格搜索、交叉验证、度量</li><li>预处理：特征提取、归一化</li></ul><h3 id="7-statsmodels："><a href="#7-statsmodels：" class="headerlink" title="7. statsmodels："></a>7. statsmodels：</h3><p>一个统计分析包，实现了许多在 R 语言中流行的回归分析模型。与 <strong>scikit-learn</strong> 相比， <strong>statsmodels</strong> 包含用于经典统计和计量经济学的算法，包括如下模块：</p><ul><li>回归模型：线性回归、广义线性模型、稳健线性模型、线性混合效应模型等</li><li>方差分析（ANOVA）</li><li>时间序列分析：AR、ARMA、ARIMA、VAR等模型</li><li>非参数方法：核密度估计、核回归</li><li>统计模型结果的可视化</li></ul><p><strong>statsmiodels</strong> 更专注于统计推断，为参数提供不确定性估计和 <strong><em>p</em></strong> 值，相比之下， <strong>scikit-learn</strong> 更侧重于预测</p><h3 id="8-社区和会议"><a href="#8-社区和会议" class="headerlink" title="8. 社区和会议"></a>8. 社区和会议</h3><ul><li>pydata：有关用python进行数据分析和pandas的问题列表（谷歌）</li><li>pystatsmodels：有关 <strong>statsmodels</strong> 和 <strong>pandas</strong> 的问题</li><li>numpy-discussion： 有关 <strong>NumPy</strong> 的问题</li><li>scipy-user：有关 <strong>SciPy</strong> 和 科学 python 的问题。</li></ul><h3 id="9-基本过程"><a href="#9-基本过程" class="headerlink" title="9. 基本过程"></a>9. 基本过程</h3><ol><li><p>读入和写入各种文件格式以及数据存储</p></li><li><p>准备：</p><p> 清理、整理、组合、规范化、重塑、切片和切块，以及转换数据以进行分析</p></li><li><p>转换：</p><p> 将数学和统计运算应用于数据集组以派生新的数据集。</p></li><li><p>建模和计算</p><p> 将数据连接到统计模型、机器学习算法或其他计算工具</p></li><li><p>展示：</p><p> 创建交互式或者可视化统计图表或者总结文本</p></li></ol><h1 id="第1章：Python基础、IPython和Jupyter-Notebooks"><a href="#第1章：Python基础、IPython和Jupyter-Notebooks" class="headerlink" title="第1章：Python基础、IPython和Jupyter Notebooks"></a>第1章：Python基础、IPython和Jupyter Notebooks</h1><h2 id="1-1-IPython基础"><a href="#1-1-IPython基础" class="headerlink" title="1.1 IPython基础"></a>1.1 IPython基础</h2><p>相较于常规的 <strong><em>print()</em></strong> 输出，IPython能够更好的格式化输出，展现更易辨识的数据。</p><ol><li><p><strong><em>Tab</em></strong> ： 代码补全：不仅可以补全定义的常量变量，还可以补全函数，或者导入包时也可以补全模块名。 <code>.&lt;Tab&gt;</code> 。</p><p> 更好用的是，自动补全也可以用于任何看起来像文件路径的东西。即使在字符串中。</p><p> 此外还有函数关键字参数的补全等等。</p><p> 但是默认情况下，IPython会自动隐藏以下划线开头的方法和属性，当且仅当输入下划线，然后再按 <code>&lt;Tab&gt;</code> 时会显示。</p></li><li><p><strong>内省</strong></p><p> 在变量之前或之后使用 <code>?</code> 将显示有关对象的一些一般信息</p><p> 比如输入 <code>b?</code> 或者 <code>print?</code>  都会输出一些基本的信息，这成为对象的自省。</p><p> 在应用于自己编写的函数时，如果有文本说明，也将会打印出文本说明。其次如果后面是 <code>??</code> 那么还可以打印出函数的源代码。</p><p> <code>?</code> 与通配符 <code>*</code> 结合使用，可以显示与通配符表达式匹配的所有名称。比如：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">17</span>]: np.*load*?</span><br><span class="line">np.__loader__</span><br><span class="line">np.load</span><br><span class="line">np.loads</span><br><span class="line">np.loadtxt</span><br></pre></td></tr></table></figure></li><li><p><strong><em>%run</em></strong> 命令</p><p> 可以使用这个命令在 IPython 会话环境中将任何文件作为 Python 程序运行。</p><p> 如果要让脚本访问已在交互式 IPython 命名空间中定义的变量，则需要使用 <code>%run -i</code> </p><p> 此外，可以使用 <code>%load [test.py](http://test.py)</code> 将 test.py 文件中的内容导入到代码单元。</p></li><li><p>中断<strong>运行代码</strong></p><p> <code>Ctrl-C</code> 中断所有代码的运行，但有时候可能会需要点时间。</p></li><li><p><strong>终端键盘快捷键</strong></p></li></ol><div class="table-container"><table><thead><tr><th>键盘快捷键</th><th>描述</th></tr></thead><tbody><tr><td>Ctrl-P或向上箭头</td><td>在命令历史记录中向后搜索以当前输入的文本开头的命令</td></tr><tr><td>Ctrl-N或向下箭头</td><td>在命令历史记录中向前搜索以当前输入的文本开头的命令</td></tr><tr><td>Ctrl-R</td><td>Readline风格的逆向历史搜索（部分匹配）</td></tr><tr><td>Ctrl-Shift-V</td><td>从剪贴板粘贴文本</td></tr><tr><td>Ctrl-C</td><td>终端当前正在执行的代码</td></tr><tr><td>Ctrl-A</td><td>将光标移动到行首</td></tr><tr><td>Ctrl-E</td><td>将光标移动到行尾</td></tr><tr><td>Ctrl-K</td><td>从光标删除文本直到行尾</td></tr><tr><td>Ctrl-U</td><td>丢弃当前行的所有文本</td></tr><tr><td>Ctrl-F</td><td>光标前移一个字符</td></tr><tr><td>Ctrl-B</td><td>将光标向后移动一个字符</td></tr><tr><td>Ctrl-L</td><td>清平</td></tr></tbody></table></div><ol><li><p><strong>IPython的特殊指令（魔法指令）</strong></p><p> 魔法指令是以百分号 <code>%</code> 为前缀的任何命令。比如：</p><p> 可以使用 <code>%timeit</code> 来查看任何 Python 语句的执行时间。</p><p> 可以使用 <code>%quickref</code> 来探索所有的特殊指令。</p></li><li><p><strong>Matplotlib集成</strong></p><p> <code>%matplotlib</code> 函数配置 <strong>matplotlib</strong> 与 IPython shell 或 jupyter notebook 的集成。否则，创建的绘图将不会出现。</p><p> 想要在 IPython 中绘制图像，可以先运行 <code>%matplotlib</code> 再运行 matplotlib 绘图命令。</p><p> 而在 Jupyter 中，则需要运行 <code>%matplotlib inline</code> </p></li></ol><h2 id="1-2-Python-语言基础"><a href="#1-2-Python-语言基础" class="headerlink" title="1.2 Python 语言基础"></a>1.2 Python 语言基础</h2><p><code>isinstance</code> 用于检查对象是否为某个特定类型的实例。比如：</p><p><code>isinstance(a,int)</code> 以及如果检查元组： <code>isinstance(a,(int,float))</code></p><h3 id="1-日期和时间"><a href="#1-日期和时间" class="headerlink" title="1. 日期和时间"></a>1. 日期和时间</h3><p>内置在 Python <code>datetime</code> 模块中的 <code>datetime</code> <code>time</code> 和 <code>date</code> 比较常用。</p><h3 id="2-其他函数"><a href="#2-其他函数" class="headerlink" title="2. 其他函数"></a>2. 其他函数</h3><h1 id="第2章：内置数据结构、函数和文件"><a href="#第2章：内置数据结构、函数和文件" class="headerlink" title="第2章：内置数据结构、函数和文件"></a>第2章：内置数据结构、函数和文件</h1><h2 id="2-1-数据结构和序列"><a href="#2-1-数据结构和序列" class="headerlink" title="2.1 数据结构和序列"></a>2.1 数据结构和序列</h2><ol><li><p>元组：不可变类型</p><p> 元组的解包：常见的用法是迭代元组或列表的序列，以及从函数返回多个值。</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">seq = [(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>)]</span><br><span class="line"><span class="keyword">for</span> a,b,c <span class="keyword">in</span> seq:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;a=<span class="subst">&#123;a&#125;</span>,b=<span class="subst">&#123;b&#125;</span>.c=<span class="subst">&#123;c&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p> 一般使用 <code>_</code> 表示不需要的变量。 <code>*args</code> 用于捕获函数中任意长的位置参数。主要发挥作用的是 <code>*</code></p></li><li><p>列表：可变类型</p><p> <code>list</code> 用于实现迭代器或生成器表达式的一种方式</p><p> <code>list.append</code> 添加元素</p><p> <code>list.insert</code> 插入元素</p><p> <code>list.pop</code> 删除并返回特定索引处的元素</p><p> <code>list.remove</code> 删除特定值</p><p> <code>in</code> 检索关键字是否在列表中</p><p> <code>list.extend</code> 将多个元素附加到列表</p><p> <code>list.sort</code> 将列表元素排序，可指定排序方法</p><ul><li><p>内置序列函数：</p><p>  <code>enumerate</code> 返回 <code>(i,value)</code> 键值对，</p><p>  <code>sorted</code> 返回一个有序列表</p><p>  <code>zip</code> 用于压缩序列，两个序列的对应索引处的元素一一对应，</p><p>  同样也可以用于解压缩，但是在多值时，需要在解压缩名称前使用 <code>*</code> ，即： <code>*name</code> 。</p><p>  <code>reversed</code> 以相反的顺序迭代序列的元素</p></li></ul></li><li><p>字典：可变类型，键值对的无序集合</p><p> <code>del</code> 或 <code>pop</code> ： 删除值</p><p> <code>dict.update</code> ：将一个字典合并到另一个字典</p><p> <code>get</code> 和 <code>pop</code> 可以返回一个默认值，例如： <code>value = some_dict.get(key,default_value)</code></p><p> <code>collections</code> 模块中的 <code>defaultdict</code> 很有用。</p></li><li><p>集合：不可变类型</p><p> <code>union</code> 或 <code>|</code> 用于求集合的并集</p><p> <code>intersection</code> 或 <code>&amp;</code> 求交集</p></li><li><p>列表、集合与字典推导式</p><p> 基本形式： <code>[expr for val in collection if condition]</code></p></li></ol><h2 id="2-2-函数"><a href="#2-2-函数" class="headerlink" title="2.2 函数"></a>2.2 函数</h2><ol><li><p>关键字参数必须位于位置参数之后。</p></li><li><p>命名空间：</p><p> 函数可以访问函数内部的变量，也可以访问函数外部的变量。但是函数内部的变量的寿命是：在函数被调用时创建，函数结束运行时销毁。但函数外部的变量会长久存在。</p><p> 使用 <code>global</code> 关键字可以在函数内部创建全局变量。</p><p> 而 <code>nonlocal</code> 关键字可以将函数外部的全局变量声明为本地变量。</p></li><li><p>返回多个值：</p><p> Python 语言支持在函数中返回多个值，如： <code>return a,b,c</code> 最后返回的结果是一个元组，可以利用元组的拆包去获取其中的各个值。</p></li><li><p>迭代工具模块：</p><p> <code>itertools</code> 模块，比较有用的几个迭代函数：</p></li></ol><div class="table-container"><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>groupby</code></td><td style="text-align:left">takes any sequence and a function, grouping consecutive elements in the sequence by return value of the function</td></tr><tr><td style="text-align:left"><code>combinations(iterable,k)</code></td><td style="text-align:left">Generate a sequence of all possible <code>k</code>-tuples of elements in the iterable, ignoring order and without replacement (the companion function: <code>combinations_with_replacement</code></td></tr><tr><td style="text-align:left"><code>permutations(iterable,k)</code></td><td style="text-align:left">Generates a sequence of all possible <code>k</code>-tuples of elements in the iterable, respecting order</td></tr><tr><td style="text-align:left"><code>groupby(iterable[,keyfunc])</code></td><td style="text-align:left">Generates <code>(key,sub-iterator)</code> for each unique key</td></tr><tr><td style="text-align:left"><code>product(*iterables,repeat=1)</code></td><td style="text-align:left">Generates the Cartesian product of the input iterables as tuples, similar to a nested <code>for</code> loop</td></tr></tbody></table></div><ol><li><p>错误和异常</p><p> 可以通过编写异常类型元组来捕获多重异常类型（必须带括号）。</p><p> 可以在 <code>try:</code> 代码块成功时执行 <code>else:</code> 代码块的内容</p></li></ol><h1 id="第3章-NumPy基础：数组和向量化计算"><a href="#第3章-NumPy基础：数组和向量化计算" class="headerlink" title="第3章 NumPy基础：数组和向量化计算"></a>第3章 NumPy基础：数组和向量化计算</h1><p><strong>NumPy</strong>： <strong><em>（Numerical Python），</em></strong> 是 Python 中数值计算最重要的基础包之一。许多提供科学函数的计算包使用 NumPy 的数组对象作为标准接口之一，用于数据交换。</p><ul><li><strong>ndarray</strong>： 一个高效的多维数组，提供快速的面向数组的算术运算和灵活的广播能力。</li><li>无需编写循环即可对整个数据数组进行快速运算的科学函数</li><li>用于将数组数据读/写到磁盘和处理内存映射文件的工具</li><li>线性代数、傅里叶变换和随机数生成函数</li><li>用于将 NumPy 与用 C、C++或 FORTRAN 编写的库连接的C API</li></ul><p>对于大多数的数据分析应用程序，关注的主要领域是：</p><ul><li>基于数组的数据处理、清洗、取子集和过滤、转换以及其他类型的快速运算操作。</li><li>常见的数组算法：如排序、去重和集合操作</li><li>用于合并和连接异构数据集的数据对齐和关系数据操作</li><li>将条件逻辑表示为数组表达式，而不是带有 <code>if-elif-else</code> 分支的循环</li><li>分组数据操作：聚合、变换和函数应用</li></ul><p>NumPy 用于 Python 处理数据的一个重要原因：对大的数据数组处理效率非常高。</p><ul><li>NumPy 将内部数据存储在连续的内存块中，独立于其他内置的 Python对象。用 C 语言编写的 NumPy 算法库可以在此内存上运行，而无需任何类型检查或其他开销， NumPy 数组使用的内存也比内置的 Python 序列少得多</li><li>NumPy 在不需要 Python 的 <code>for</code> 循环下可以对整个数组进行复杂的操作。由于 NumPy 是基于 C 语言的，它避免了常规解释 Python 代码存在的开销，所以比 Python 代码更快。</li></ul><p>NumPy 算法通常比纯 Python 算法快10到100倍，并且使用的内存也要少得多</p><h2 id="3-1-NumPy-ndarray：一个多维数组对象"><a href="#3-1-NumPy-ndarray：一个多维数组对象" class="headerlink" title="3.1 NumPy ndarray：一个多维数组对象"></a>3.1 NumPy ndarray：一个多维数组对象</h2><p><strong>ndarray</strong>： Python 中大型数据集的快速、灵活的容器。可以用类似于标量元素之间的等效运算来处理数组。</p><p><strong>ndarray</strong> 是同类数据的通用多维数组，其元素类型必须一致。每个数组都有一个 <code>shape</code> ：一个指出每个维度大小的元组，还有一个 <code>dtype</code> : 一个描述这个数组的数据类型的对象。</p><h3 id="3-1-1-创建-ndarray"><a href="#3-1-1-创建-ndarray" class="headerlink" title="3.1.1 创建 ndarray"></a>3.1.1 创建 ndarray</h3><p>使用 <code>array</code> 来创建数组，这个方法接受任何序列对象（包括数组）。并返回一个包含被传入数据的新的 NumPy 数组。</p><p>一维序列会被转换成一维数组，等长的嵌套序列则会被转换为多维数组</p><p>可以使用 <code>ndim</code> 和 <code>shape</code> 属性来查看 NumPy 数组对象的维数。</p><p>除非明确指定，否则 <code>np.array</code> 会自动推断一个数据类型并存储在 <code>dtype</code> 元数据对象中。</p><ol><li><p><code>zeros</code> 和 <code>ones</code> 分别创建给定长度或形状的 <code>0</code> 和 <code>1</code> 数组。</p></li><li><p><code>empty</code> 创建任意值类型的数组。此函数返回的是未出世哈的内存。因此可能包含非零的垃圾值</p><p> 可以传入一个元组来创建多维数组。</p></li><li><p><code>arange</code> 是内置 Python <code>range</code> 函数的数组值版本</p></li></ol><p>创建标准数组的函数：</p><div class="table-container"><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">array</td><td style="text-align:left">通过推断 dtype 或显示指定 dtype 将输入数据转换为 ndarray；默认复制输入数据</td></tr><tr><td style="text-align:left">asarray</td><td style="text-align:left">将输入转换为 ndarray，如果输入已经是 ndarray，则不复制</td></tr><tr><td style="text-align:left">arange</td><td style="text-align:left">与内置 range 类似，但返回的是 ndarray 而不是列表</td></tr><tr><td style="text-align:left">ones,ones_like</td><td style="text-align:left">生成具有给定形状和 dtype 的全1数组； ones_like 接受另一个数组并生成一个具有相同形状和 dtype 的全1数组</td></tr><tr><td style="text-align:left">zeros,zeros_like</td><td style="text-align:left">产生全0数组</td></tr><tr><td style="text-align:left">empty,empty_like</td><td style="text-align:left">通过分配新内存来创建新数组，但不填充任何值。</td></tr><tr><td style="text-align:left">full,full_like</td><td style="text-align:left">创建给定形状和dtype的数组，而且数组的值全部为指定的值</td></tr><tr><td style="text-align:left">eye,identity</td><td style="text-align:left">创建 N*N 单位矩阵（对角线元素为1，其他地方为0）</td></tr></tbody></table></div><h3 id="3-1-2-ndarray-的数据类型"><a href="#3-1-2-ndarray-的数据类型" class="headerlink" title="3.1.2 ndarray 的数据类型"></a>3.1.2 ndarray 的数据类型</h3><p><code>dtype</code> 包含了 ndarray 需要将一连串内存解释为特殊类型的数据的信息</p><p>dtype 是 NumPy 与来自其它系统的数据交互灵活性的来源，提供直接到底层磁盘或内存表示的映射。可以在磁盘上读取和写入二进制数据流。</p><p>可以使用 <code>np.astype</code> 方法将一种数据类型的 ndarray 数组转换成另一种数据类型。这个也对字符串数字数组有效。并且还能够使用其他数组的数据类型。</p><p><code>float_arr = arr.astype(np.float64)</code> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">float_arr = arr.astype(np.float64)</span><br><span class="line"></span><br><span class="line">int_arr = np.arrange(<span class="number">10</span>)</span><br><span class="line">calibers = np.array([<span class="number">.22</span>,<span class="number">.270</span>,<span class="number">.357</span>,<span class="number">.380</span>,<span class="number">.44</span>,<span class="number">.50</span>],dtype = np.float64)</span><br><span class="line">int_arr.astype(calibers.dtype)</span><br></pre></td></tr></table></figure><p>如果将浮点数转换为整数，那么小数点后的数字将被截断丢弃。</p><p><code>astype</code> 的调用总会创建一个新的数组，即使新数组的数据类型与原数组的一样。</p><h2 id="3-1-3-使用-NumPy-数组进行算术运算"><a href="#3-1-3-使用-NumPy-数组进行算术运算" class="headerlink" title="3.1.3 使用 NumPy 数组进行算术运算"></a>3.1.3 使用 NumPy 数组进行算术运算</h2><ol><li><p>数组可以使我们在不适用 <code>for</code> 循环的情况下对数据进行批处理操作。NumPy 用户将此称为矢量化。相同大小的数组之间的任何算术运算都按元素来操作。</p><p> 例如： <code>arr*arr</code> , <code>arr-arr</code> 等数组运算。</p></li><li><p>标量算术运算将标量参数用于数组中的每一个元素</p><p> 例如： <code>1/arr</code> , <code>arr ** 0.5</code></p></li><li><p>相同大小的数组之间的比较产生布尔数组</p><p> 例如： <code>arr1&gt;arr2</code></p></li></ol><p>评估不同大小数组的操作称为广播 <strong><em>(broadcasting)</em></strong></p><h3 id="3-1-4-基本的索引和切片"><a href="#3-1-4-基本的索引和切片" class="headerlink" title="3.1.4 基本的索引和切片"></a>3.1.4 基本的索引和切片</h3><ol><li><p>有很多方法去选择子集和单独的元素，一维数组的索引与 Python 列表的操作一样。 <code>arr[5]</code>  <code>arr[5:8]</code></p></li><li><p><code>arr[5:8]=12</code> 意味着将 5-8 的元素全都变为 12。数组和内置类型列表明显的区别在于：数组的切片操作是原数组的视图。即数据不会被复制，对视图的任何修改都会反映在原数组中。</p><p> 如果需要一个 ndarray 切片的副本而不是视图，可以使用 <code>arr[5:8].copy()</code> .</p></li><li><p>对于多维数组，下标索引将变为某一维中的所有数据。</p><p> 例如获取二维数组中的某一元素： <code>arr[0][2]</code> 或者 <code>arr[0,2]</code><img src="image-20230508191549368.png" alt="image-20230508191549368"></p><p> 二维数组各个元素对应的坐标</p><ol><li>在n维数组中，如果忽略了后面的索引，那么返回值将是 n-1 维数组。并且在分配标量值 M 时， n-1 维数组中的所有元素都将被重新赋值为 M</li></ol></li></ol><h3 id="3-1-5-用切片索引"><a href="#3-1-5-用切片索引" class="headerlink" title="3.1.5 用切片索引"></a>3.1.5 用切片索引</h3><ol><li>和一维数组一样，多维数组同样可以进行切片操作，但是返回的将是几行的数据。比如： <code>arr2d[:2]</code> 将返回2维数组的前两行。还可以传入多个切片： <code>arr2d[:2,1:]</code> 这个将返回前两行后几列的所有数据。</li><li>混用整数索引和切片，可以得到低维数组。 <code>:</code> 意味着采用整个轴</li><li>同样的给切片复制将给切片内的所有元素赋值为指定值。</li></ol><h3 id="3-1-6-布尔索引"><a href="#3-1-6-布尔索引" class="headerlink" title="3.1.6 布尔索引"></a>3.1.6 布尔索引</h3><ol><li>当一个列表中含有多个重复值时，可以对数组进行某个值的比对，其返回值为一个布尔数组。</li><li>当给一个数组传入布尔数组时，返回值为以布尔数组中值为 <code>true</code> 的下标作为行号的整行元素。布尔数组的长度应与要索引的数组的大小相同。同时还可以使混用布尔数组和整数索引。 <code>data[names == &#39;Bob&#39;,2:]</code> ，可以使用 <code>!=</code> 或者 <code>~</code> 来选取所有除 Bob 之外的所有数据。 <code>data[names!=&#39;Bob&#39;,2:]</code> , <code>~data[names == &#39;Bob&#39;,2:]</code></li><li>可以使用布尔算术运算符 <code>&amp;</code> 或 <code>|</code> 来获取多个布尔条件： <code>mask = (names==’Bob’) | (names == ‘Will’)</code></li><li>通过布尔索引将数组中所有赋值重新赋值为 0 ： <code>data[data&lt;0]==0</code> </li><li>还可以用一维布尔数组来设置整行或整列的值 ： <code>data[names!=&#39;Joe&#39;]=7</code> </li></ol><h3 id="3-1-7-Fancy-indexing"><a href="#3-1-7-Fancy-indexing" class="headerlink" title="3.1.7 Fancy indexing"></a>3.1.7 Fancy indexing</h3><p><strong><em>Fancy indexing</em></strong> 是 NumPy 用来描述使用整数数组进行索引。</p><ol><li>仅传入一维列表时：代表将列表中标明的所有行全部选出： <code>arr[[4,3,0,6]]</code> ，也可以使用负数，代表从后往前索引。</li><li>传入2维列表时：代表将 [] 行 [] 列 的所有元素选出： <code>arr[[1,5,7,2],[0,3,1,2]]</code> 选中 <code>(1,0) (5,3)  (7,1) (2,2)</code> 元素</li><li>获取数组的子集： <code>arr[[1,5,7,2]][[:,[0,3,1,2]]</code> </li></ol><p><strong><em>Fancy indexing</em></strong> 不像切片，它总是将数据赋值到一个新的数组。</p><h3 id="3-1-8-转置数组和交换轴"><a href="#3-1-8-转置数组和交换轴" class="headerlink" title="3.1.8 转置数组和交换轴"></a>3.1.8 转置数组和交换轴</h3><p>转置：通过直接返回基本数据的视图来重塑形状。通常是利用 <code>transpose</code> 方法 或者 <code>T</code> 属性。这种操作在矩阵中非常常见。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">15</span>).reshape((<span class="number">3</span>,<span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"><span class="built_in">print</span>(arr.T)</span><br></pre></td></tr></table></figure><ol><li>可以用 <code>[np.dot](http://np.dot)</code> 或者中缀运算符 <code>@</code> 来计算两个矩阵的内积。如： <code>np.dot(arr.T,arr)</code>  或 <code>arr.T @ arr</code></li><li>对于高维数组， <code>transpose</code> 需要得到一个由轴编号组成的元组才能对这些轴进行转置。</li><li>还有 <code>swapaxes</code> 方法，需要接受一对轴编号</li></ol><h2 id="3-2-通用函数：快速的元素级数组函数"><a href="#3-2-通用函数：快速的元素级数组函数" class="headerlink" title="3.2 通用函数：快速的元素级数组函数"></a>3.2 通用函数：快速的元素级数组函数</h2><p>通用函数 <strong><em>(ufunc)</em></strong> 一种对 ndarray 中的数组执行元素级运算的函数，可以将其看作简单函数的矢量化包装器。</p><ol><li>许多 ufunc 都是简单的元素级变体：比如 <strong>sqrt</strong> 和 <strong>exp，</strong> 这些都是一元 ufunc。此外还有 <strong>add</strong> 和 <strong>maximum</strong> 二元 ufunc。</li><li><code>modf</code> : 返回浮点数数组的小数和整数部分。</li></ol><p>常见的一元 ufunc：</p><ul><li><code>abs</code> <code>fabs</code> ：计算整数、浮点数或复数的绝对值。对于非负数值，可以使用更快的 <code>fabs</code></li><li><code>sqrt</code> ：计算各元素的平方根。</li><li><code>square</code> ：计算各元素的平方</li><li><code>exp</code> ：计算各元素的指数 $e^x$</li><li><code>log</code> <code>log10</code> <code>log2</code> <code>log1p</code> ：分别为自然对数、底数为10的log、底数为2的log、log(1+x)</li><li><code>sign</code> ：计算个元素的正负号：1（正数）、0（零）、-1（负数）</li><li><code>ceil</code> ：计算各元素的ceiling值，即大于等于该值的最小整数</li><li><code>floor</code> ：计算各元素的floor值，即小于等于该值的最大整数</li><li><code>rint</code> ：将各元素值四舍五入到最接近的整数，保留 dtype</li><li><code>modf</code> ：将数组的小数和整数部分以两个独立数组的形式返回</li><li><code>isnan</code> ：返回一个表示“那些值是 NaN”的布尔类型数组</li><li><code>isfinite</code> <code>isinf</code> ：分别返回一个表示 “哪些元素是有穷的” 或 “哪些元素是无穷的” 的布尔类型</li><li><code>cos</code> <code>cosh</code> <code>sin</code> <code>sinh</code> <code>tan</code> <code>tanh</code>：普通和双曲型三角函数</li><li><code>arccos</code> <code>arccosh</code> <code>arcsin</code> <code>arcsinh</code> <code>arctan</code> <code>arctanh</code> ：反三角函数</li><li><code>logical_not</code> ：计算各元素 not x 的真值，相当于 -arr</li></ul><p>常见的二元 ufunc</p><ul><li><code>add</code> ：将数组中对应的元素相加</li><li><code>subtract</code> ：从第一个数组中减去第二个数组中的元素</li><li><code>multiply</code> ：数组元素相乘</li><li><code>divide</code> <code>floor_divide</code> ：除法或向下圆整除法（丢弃余数）</li><li><code>power</code> ：对第一个数组中的元素A，根据第二个数组中的相应元素B，计算$A^B$</li><li><code>maximum</code> <code>fmax</code> ：元素级的最大值计算，fmax 将忽略 NaN</li><li><code>minimum</code> <code>fmin</code> ：元素级的最小值计算，fmin 将忽略 NaN</li><li><code>mod</code> ：元素级的求模计算（除法的余数）</li><li><code>copysign</code> ：将第二个数组中的值的符号复制给第一个数组中的值</li><li><code>greater</code> <code>greater_equal</code> <code>less</code> <code>less_equal</code> <code>equal</code> <code>not_equal</code> ：执行元素级的比较运算，最终产生布尔型数组。相当于中缀运算符： &gt;、≥ 、&lt; 等等</li><li><code>logical_and</code> <code>logical_or</code> <code>logical_xor</code> 执行元素级的真值逻辑运算。相当于中缀运算符</li></ul><h2 id="3-3-利用数组进行数据处理"><a href="#3-3-利用数组进行数据处理" class="headerlink" title="3.3 利用数组进行数据处理"></a>3.3 利用数组进行数据处理</h2><p>用数组表达式代替循环的做法称为 <strong>矢量化。</strong></p><ol><li><p><code>np.meshgrid</code> 接受两个一维数组，并产生两个二维矩阵（对应于两个数组中所有的 (x,y) 对）</p></li><li><p><code>np.where</code> 是三元表达式 <code>x if condition else y</code> 的矢量化版本。 <code>np.where(cond,xarr,yarr)</code> 若 cond 为真，则选取 xarr 中的值，否则选取 yarr 中的值</p><p> 可以将 <code>np.where</code> 与标量结合，可以很方便的替换数组的值。</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">14</span>]: xarr = np.array([<span class="number">1.1</span>,<span class="number">1.2</span>,<span class="number">1.3</span>,<span class="number">1.4</span>,<span class="number">1.5</span>])</span><br><span class="line">In [<span class="number">15</span>]: yarr = np.array([<span class="number">2.1</span>,<span class="number">2.2</span>,<span class="number">2.3</span>,<span class="number">2.4</span>,<span class="number">2.5</span>])</span><br><span class="line">In [<span class="number">16</span>]: cond = np.array([<span class="literal">True</span>,<span class="literal">False</span>,<span class="literal">True</span>,<span class="literal">True</span>,<span class="literal">False</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: np.where(cond,xarr,yarr)</span><br><span class="line">Out[<span class="number">17</span>]: array([<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">1.3</span>, <span class="number">1.4</span>, <span class="number">2.5</span>])</span><br></pre></td></tr></table></figure><ol><li>常用的数组统计方法</li></ol><pre><code>| 方法            | 说明                           || --------------- | ------------------------------ || np.sum(axis=0)  | 对数组中全部或某轴向的元素求和 || np.mean(axis=1) | 算术平均数                     || np.cumsum       | 所有元素的累计和               || np.cumprod      | 所有元素的累计积               || std  var        | 分别为标准差和方差，自由度可调 || min max         | 最大值和最小值                 || argmin argmax   | 分别为最大和最小元素的索引     |在上面的这些方法中，布尔值会被强制转换，1（True）和 0（False）。此外 `any` 用于检查数组中是否存在一个或多个 True，而 `all` 用于检查数组中的值是否全为 True</code></pre><ol><li><p><code>sort</code> 用于数组的排序，多维数组只需要将轴编号传递给 <code>sort</code> 即可</p></li><li><p><code>unique</code> 将一维数组中重复的值去除，并返回排序后的结果。</p><p> <code>np.in1d</code> 用于测试一个数组中的元素在另一个数组中的成员资格，返回布尔型数组。</p></li></ol><h2 id="3-4-用于数组的文件输入输出"><a href="#3-4-用于数组的文件输入输出" class="headerlink" title="3.4 用于数组的文件输入输出"></a>3.4 用于数组的文件输入输出</h2><ol><li><code>[np.save](http://np.save)</code> 和 <code>np.load</code> 默认情况下，数组以未压缩的原始二进制格式保存在扩展名为 <code>.npy</code> 的文件中。</li><li><code>np.savez</code> 将多个数组保存到一个未压缩文件中。</li><li><code>np.savez_compressed</code> 对数据进行压缩然后保持文件</li></ol><h2 id="3-5-线性代数"><a href="#3-5-线性代数" class="headerlink" title="3.5 线性代数"></a>3.5 线性代数</h2><div class="table-container"><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>diag</td><td>以一维数组的形式返回方阵的对角线（或非对角线）元素，或将一维数组转换为方阵（非对角线元素为0）</td></tr><tr><td>dot</td><td>矩阵乘法</td></tr><tr><td>trace</td><td>计算对角线元素的和</td></tr><tr><td>det</td><td>计算矩阵行列式</td></tr><tr><td>eig</td><td>计算方阵的本征值和本征向量</td></tr><tr><td>inv</td><td>计算方阵的逆</td></tr><tr><td>pinv</td><td>计算矩阵的 Moore-Penrose 伪逆</td></tr><tr><td>qr</td><td>计算QR分解</td></tr><tr><td>svd</td><td>计算奇异值分解</td></tr><tr><td>solve</td><td>解线性方程组 Ax=b，其中A为一个方阵</td></tr><tr><td>lstsq</td><td>计算Ax=b的最小二乘解</td></tr></tbody></table></div><h2 id="3-6-伪随机数生成"><a href="#3-6-伪随机数生成" class="headerlink" title="3.6 伪随机数生成"></a>3.6 伪随机数生成</h2><p><strong>numpy.random</strong> 对python内置的 random 进行了补充，增加了一些用于高效生成多种概率分布的样本值的函数。</p><p>可以使用 <code>numpy.random.RandomState</code> 来创建一个与它隔离的随机数生成器。</p><div class="table-container"><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>seed</td><td>确定随机数生成器的种子</td></tr><tr><td>permutation</td><td>返回一个序列随机排列或返回一个随机排列的范围</td></tr><tr><td>shuffle</td><td>对一个序列就地随机排列</td></tr><tr><td>rand</td><td>产生均匀分布的样本值</td></tr><tr><td>randint</td><td>从给定的上下限范围内随机选取整数</td></tr><tr><td>randn</td><td>产生正态分布（平均值为0，标准差为1）的样本值</td></tr><tr><td>binomial</td><td>产生二项分布的样本值</td></tr><tr><td>normal</td><td>产生正态（高斯）分布的样本值</td></tr><tr><td>beta</td><td>产生Beta分布的样本值</td></tr><tr><td>chisquare</td><td>产生卡方分布的样本值</td></tr><tr><td>gamma</td><td>产生Gamma分布的样本值</td></tr><tr><td>uniform</td><td>产生在 [0,1] 中均匀分布的样本值</td></tr></tbody></table></div><h2 id="3-7-示例：随机漫步"><a href="#3-7-示例：随机漫步" class="headerlink" title="3.7 示例：随机漫步"></a>3.7 示例：随机漫步</h2><h1 id="第4章：开始使用pandas"><a href="#第4章：开始使用pandas" class="headerlink" title="第4章：开始使用pandas"></a>第4章：开始使用pandas</h1><p><strong>pandas</strong>含有使数据清洗和分析工作变得更快更简单的数据结构和操作工具。主要和数值计算工具<strong>Numpy</strong>和<strong>SciPy</strong>，分析库<strong>statsmodels</strong>和<strong>scikit-learn</strong>，数据可视化库<strong>matplotlib</strong>一起使用。<strong>pandas</strong> 是基于 <strong>numpy</strong> 数组构建的。</p><h2 id="4-1：pandas的数据结构介绍"><a href="#4-1：pandas的数据结构介绍" class="headerlink" title="4.1：pandas的数据结构介绍"></a>4.1：pandas的数据结构介绍</h2><p><strong>pandas</strong> 主要有两个数据结构： <strong>Series</strong> 和 <strong>DataFrame</strong> 。</p><ul><li><p><strong>Series</strong>：</p><p>  类似于一维数组的对象，由一组数据（各种 <strong>NumPy</strong> 数据类型）以及一组与之相关的数据标签（即索引）组成。仅由一组数据即可产生最简单的 <strong>Series</strong>：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj=pd.Series([4,7,-5,3])</span><br><span class="line">obj</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><strong>Series</strong> 的字符串表现形式为：索引在左边，值在右边。没有指定索引的情况下，会自动创建一个0到N-1的整数型索引库。可以通过 <strong>Series</strong> 的 <strong>values</strong> 和 <strong>index</strong> 属性来获取值和索引。 <code>obj.values</code> , <code>obj.index</code></li><li>创建对各个数据点进行标记的索引：<code>obj2=pd.Series([4,7,-5,3],index=[&#39;d&#39;,&#39;b&#39;,&#39;a&#39;,&#39;c&#39;])</code></li><li>可以通过索引的方式来访问 <strong>Series</strong> 中的单一或者一组值：<code>obj2[&#39;a&#39;]</code> ，<code>obj2[&#39;d&#39;]=6</code> ，<code>obj2[[&#39;c&#39;,&#39;a&#39;,&#39;d&#39;]]</code></li><li><strong>pandas</strong> 同样可以采用 <strong>NumPy</strong> 中的一些运算，比如函数和标量乘积。<code>obj2[obj&gt;0]</code> , <code>obj2*2</code> , <code>np.exp(obj2)</code></li><li><p>也可以用<strong>Python</strong>字典来创建 <strong>Series</strong>：字典中的键值就是 <strong>Series</strong> 的索引。可以采用传入一个列表来改变 <strong>Series</strong> 的索引顺序和显示的数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sdata = &#123;&#x27;Ohis&#x27;:35000,&#x27;Texas&#x27;:71000,&#x27;Oregon&#x27;:16000,&#x27;Utah&#x27;:5000&#125;</span><br><span class="line">obj3 = pd.Series(sdata)</span><br><span class="line">obj3</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>可以使用 <code>isnull</code> 和 <code>notnull</code> 来检测缺失数据。会根据索引标签来自动对齐数据。</p></li><li><p><strong>Series</strong> 对象本身都有 <strong>name</strong> 属性，可以用来更改或添加描述：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj4.name = &#x27;population&#x27;</span><br><span class="line">obj4.index.name = &#x27;state&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>Series</strong> 索引的值可以通过赋值来更改：<code>obj.index=[&#39;Bob&#39;,&#39;Steve&#39;,&#39;Jeff&#39;,&#39;Ryan&#39;]</code></p></li></ol></li><li><p><strong>DataFrame</strong></p><p>  <strong>DataFrame</strong> 是一个表格型的数据结构，含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔值等）。<strong>DataFrame</strong> 既有行索引也有列索引，它可以被看作由 <strong>Series</strong> 组成的字典（公用一个索引）。<strong>DataFrame</strong> 中的数据是以一个或多个二维块存放的。</p><ol><li><p>建 <strong>DataFrame</strong>：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;<span class="string">&#x27;state&#x27;</span>:[<span class="string">&#x27;Ohio&#x27;</span>,<span class="string">&#x27;Ohio&#x27;</span>,<span class="string">&#x27;Ohio&#x27;</span>,<span class="string">&#x27;Nevada&#x27;</span>,<span class="string">&#x27;Nevada&#x27;</span>,<span class="string">&#x27;Nevada&#x27;</span>],</span><br><span class="line"><span class="string">&#x27;year&#x27;</span>:[<span class="number">2000</span>,<span class="number">2001</span>,<span class="number">2002</span>,<span class="number">2001</span>,<span class="number">2002</span>,<span class="number">2003</span>],</span><br><span class="line"><span class="string">&#x27;pop&#x27;</span>:[<span class="number">1.5</span>,<span class="number">1.7</span>,<span class="number">3.6</span>,<span class="number">2.4</span>,<span class="number">2.9</span>,<span class="number">3.2</span>]&#125;</span><br><span class="line">frame = pd.DataFrame(data)</span><br><span class="line">frame</span><br></pre></td></tr></table></figure><p> 结果会自动加上索引，且当数据太多时， <code>head</code> 方法仅显示前5组数据。且当传入的数据找不到时，就会产生缺失值。</p><p> 如果制定了列序列，那么 <strong>DataFrame</strong> 就会按照指定顺序进行排列。</p></li><li><p>通过类似字典标记或属性的方式，可以将 <strong>DataFrame</strong> 的列获取为一个 <strong>Series</strong> ： <code>frame[&#39;state&#39;]</code>  <code>frame.year</code></p><p> 列可以通过赋值的方式进行修改。例如： <code>frame[&#39;debt&#39;]=16.5</code> ，接受一个或者一组值。</p><p> 赋值时，要么赋值数组长度与 <strong>DataFrame</strong> 的长度相同，要么赋值一个 <strong>Series</strong> ，此时会精确的匹配 <strong>DataFrame</strong> 索引： <code>pd.Series([-1.2,-1.5,-1.7],index=[&#39;two&#39;,&#39;four&#39;,&#39;five&#39;])</code>  。有空位时，将被填上空缺值。</p></li><li><p>可以使用 <code>loc</code> 方法来获取一行值： <code>frame2.loc[&#39;three&#39;]</code></p></li><li><p>为不存在的列赋值会创建一个新列，而用 <code>del</code> 可以删除列。</p></li><li><p>将嵌套字典传给 <strong>DataFrame</strong> ， <strong>pandas</strong> 会解释为：外层字典的键作为列，内层键则作为行索引。此外也可以对其进行转置： <code>frame.T</code> 。</p></li><li><p>可以输入给 <strong>DataFrame</strong> 构造器的数据：   </p></li></ol></li></ul><div class="table-container"><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>二维ndarray</td><td>数据矩阵，还可以传入行标和列标</td></tr><tr><td>由数组、列标或元组组成的字典</td><td>每个序列会变成DataFrame的一列。所有序列的长度必须相同</td></tr><tr><td>NumPy的结构化/记录数组</td><td>类似于”由数组组成的字典“</td></tr><tr><td>由Series组成的字典</td><td>每个Series会称为一列。如果没有显式指定索引，则各个Series的索引会被合并成结果的行索引</td></tr><tr><td>由字典组成的字典</td><td>各内层字典会称为一列。键会被合并为结果的行索引，跟由”Series组成的字典“的情况一样</td></tr><tr><td>字典或Series的列标</td><td>各项将会成为DataFrame的一行。字典键或Series索引的并集将会成为DataFrame的列标</td></tr><tr><td>由列表或元组组成的列表</td><td>类似于”二维ndarray“</td></tr><tr><td>另一个DataFrame</td><td>该DataFrame的索引将会被沿用，除非显式制定了其他索引</td></tr><tr><td>NumPy的MaskedArray</td><td>类似于”二维ndarray“情况，知识掩码值在结果DataFrame会变成NA/缺失值</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据分析 </tag>
            
            <tag> Numpy </tag>
            
            <tag> Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot速通</title>
      <link href="/2022/11/20/SpringBoot%E9%80%9F%E9%80%9A/"/>
      <url>/2022/11/20/SpringBoot%E9%80%9F%E9%80%9A/</url>
      
        <content type="html"><![CDATA[<p>==学习视频：==<a href="https://www.bilibili.com/video/BV15b4y1a7yG?p=4&amp;vd_source=a7a1e61bb0348aaf12b5c40afdecb042">黑马程序员Springboot教程</a></p><p><a href="https://blog.csdn.net/Z__Sheng/article/details/103256464">java图片上传保存至服务器并返回可下载的URL</a></p><h1 id="一、Springboot基础篇"><a href="#一、Springboot基础篇" class="headerlink" title="一、Springboot基础篇"></a>一、Springboot基础篇</h1><h2 id="1-1、Springboot项目的创建"><a href="#1-1、Springboot项目的创建" class="headerlink" title="1.1、Springboot项目的创建"></a>1.1、Springboot项目的创建</h2><h3 id="1-idea联网版"><a href="#1-idea联网版" class="headerlink" title="1.idea联网版"></a>1.idea联网版</h3><ol><li>开发 SpringBoot 程序可以根据向导进行联网快速制作。</li><li>SpringBoot 程序需要基于 JDK8 进行制作。</li><li>SpringBoot 程序中需要使用何种功能通过勾选选择技术。</li><li>运行 SpringBoot 程序通过运行 Application 程序入口进入。</li></ol><h3 id="2-官网版"><a href="#2-官网版" class="headerlink" title="2.官网版"></a>2.官网版</h3><p>直接在 Springboot 官网下边的 <code>Quickstart your project</code> 中点击 <code>Spring initializr</code> 并在里边设置 Springboot 的相关细节，然后将生成的项目模块并入整个项目文件中，最后在 IDEA 中导入这个模块。</p><ol><li>打开 SpringBoot 官网，选择 Quickstart Your Project。</li><li>创建工程，并保存项目。</li><li>解压项目，通过 IDE 导入项目。</li></ol><h3 id="3-阿里云版"><a href="#3-阿里云版" class="headerlink" title="3.阿里云版"></a>3.阿里云版</h3><p>同样是在 IDE 中的 Spring Initializr ，在创建时，选择 <code>Customer</code> 并键入 <a href="https://start.aliyun.com">https://start.aliyun.com</a></p><p><img src="image-20230508175055070.png" alt="image-20230508175055070"></p><ol><li>选择 Server URL 后面的齿轮</li><li>输入阿里云 start 地址</li><li>创建项目。</li></ol><h3 id="4-手工制作版"><a href="#4-手工制作版" class="headerlink" title="4.手工制作版"></a>4.手工制作版</h3><ol><li>创建普通 Maven 工程</li><li>继承 spring-boot-starter-parent</li><li>添加依赖 spring-boot-starter-web</li><li>制作引导类 Application</li></ol><h3 id="5-隐藏-IDE-中的文件或文件夹"><a href="#5-隐藏-IDE-中的文件或文件夹" class="headerlink" title="5.隐藏 IDE 中的文件或文件夹"></a>5.隐藏 IDE 中的文件或文件夹</h3><ol><li>Setting -&gt; File Types -&gt; Ignored Files and Folders</li><li>输入要隐藏的文件名，支持 * 通配符</li><li>回车确认添加。</li></ol><h2 id="1-2、快速上手-SpringBoot"><a href="#1-2、快速上手-SpringBoot" class="headerlink" title="1.2、快速上手 SpringBoot"></a>1.2、快速上手 SpringBoot</h2><h3 id="1-Spring-与-SpringBoot-的比较："><a href="#1-Spring-与-SpringBoot-的比较：" class="headerlink" title="1. Spring 与 SpringBoot 的比较："></a>1. Spring 与 SpringBoot 的比较：</h3><ul><li>Spring 程序的缺点：<ul><li>依赖配置繁琐</li><li>配置繁琐</li></ul></li><li>SpringBoot 程序的优点：<ul><li>起步依赖（简化依赖配置）</li><li>自动配置（简化常用工程相关配置）</li><li>辅助功能（内置服务器，……）</li></ul></li></ul><h3 id="2-入门案例解析"><a href="#2-入门案例解析" class="headerlink" title="2. 入门案例解析"></a>2. 入门案例解析</h3><p>SpringBoot 强大的原因：</p><ul><li>parent：主要是 子pom 文件可以继承 父pom 文件；而且各种jar包的版本都由Boot来调整，不会冲突；通过 pom 文件内的 \<depencies\> 来管理各种依。==定义了若干个坐标版本号（依赖管理，而非依赖），以达到减少依赖冲突的目的==。</depencies\></li><li>starter：在 \<depencies\> 中的 \<artifactId\> 中有很多 starter，对应的 starter 就是包含了很多依赖的 pom 包管理文件。==定义了当前项目使用的所有依赖坐标，以达到减轻依赖配置的目的。== <ul><li>实际开发：<ul><li>使用任意坐标时，仅书写 GAV 中的 G 和 A，V由 SpringBoot 提供，除非 SpringBoot 未提供对应版本V。</li><li>如发生坐标错误，在指定 Version（要小心版本冲突）。</li></ul></li></ul></artifactId\></depencies\></li><li>引导类：以 Application 结尾的类。类中的 <code>SpringApplication.run(Application.class, args);</code> 起检测上下文中的 Bean。 引导类是 Boot 工程的执行入口，运行 main 方法就可以启动项目；工程运行后初始化 Spring 容器，扫描引导类所在包加载 Bean。</li><li>内嵌tomcat：使用 Maven 依赖管理变更起步依赖项：可以使用 \<exclusion\> 将不想用的依赖排除掉，然后再加入自己想用的依赖。==内嵌tomcat的原理：==将Tomcat 服务器作为对象运行，并将该对象交给 Spring 容器管理。SpringBoot 内置了三款服务器：<ul><li>tomcat（默认）：apache 出品，粉丝多，应用面广，负载了若干较重的组件。</li><li>jetty：更轻量级，负载性能远不如 tomcat。</li><li>undertow：负载性能勉强跑赢tomcat。</li></ul></exclusion\></li></ul><h2 id="1-3、REST开发"><a href="#1-3、REST开发" class="headerlink" title="1.3、REST开发"></a>1.3、REST开发</h2><p><strong><em>REST：</em></strong>（Representational State Transfer），表现形式状态转换。即访问网络资源的格式。<img src="image-20230508175210018.png" alt="image-20230508175210018"></p><p>按照 REST 风格访问资源时使用 <strong><em>行为动作</em></strong> 区分对资源的操作。</p><p><img src="image-20230508175222069.png" alt="image-20230508175222069"></p><p>根据 REST 风格对资源进行访问称为：<strong><em>RESTful</em></strong></p><ol><li>设定 http 请求动作</li><li>设定请求参数（路径变量）<img src="image-20230508175233340.png" alt="image-20230508175233340"></li></ol><h3 id="REST-重要的注解"><a href="#REST-重要的注解" class="headerlink" title="REST 重要的注解"></a>REST 重要的注解</h3><ul><li>\@RequestMapping  <ul><li>类型：方法注解</li><li>位置：SpringMVC控制器方法定义上方</li><li>设置当前控制器方法请求访问路径</li><li>属性：<ul><li>value（默认）：请求访问路径</li><li>method：http 请求动作，标准动作（GET/POST/PUT/DELETE）</li></ul></li></ul></li><li>\@PathVariable  <ul><li>类型：形参注解</li><li>位置：SpringMVC控制器方法形参定义前面</li><li>作用：绑定路径参数与处理器方法形参间的关系，要求路径参数名与形参名一一对应。</li></ul></li></ul><h3 id="三种传参注解对比"><a href="#三种传参注解对比" class="headerlink" title="三种传参注解对比"></a>三种传参注解对比</h3><p>\@RequestBody       \@RequestParam       \@PathVariable    </p><ul><li>区别：<ul><li>\@RequestBody 用于接收 json 数据</li><li>\@RequestParam 用于接收 url 地址传参或表单传参</li><li>\@PathVariable 用于接收路径参数，使用 {参数名称} 描述路径参数</li></ul></li><li>应用：<ul><li>后期开发中，发送请求参数超过1个时，以 json 格式为主，\@RequestBody 应用较广。</li><li>如果发送非 json 格式数据，选用 \@RequestParam 接受请求参数。</li><li>采用 RESTful 进行开发，当参数数量较少时，例如 1 个，可以采用 \@PathVariable 接受请求路径变量，通常用于传递 id 值。</li></ul></li></ul><h3 id="REST快速开发的注解"><a href="#REST快速开发的注解" class="headerlink" title="REST快速开发的注解"></a>REST快速开发的注解</h3><p>在快速开发中， \@RequestMapping 可以替换，按照 method 的不同，有下面几个：</p><ul><li>\@RestController  <ul><li>类型：类注解</li><li>位置：基于SpringMVC的 RESTful 开发控制器类定义上方</li><li>作用：设置当前控制器类为 RESTful 风格，等同于 \@Controller 与 \@ResponseBody 两个注解组合功能</li><li>属性：<ul><li>value（默认）：请求访问路径</li></ul></li></ul></li><li>\@GetMapping</li><li>\@PostMapping </li><li>\@PutMapping</li><li>\@DeleteMapping</li></ul><h2 id="1-4、SpringBoot基础配置"><a href="#1-4、SpringBoot基础配置" class="headerlink" title="1.4、SpringBoot基础配置"></a>1.4、SpringBoot基础配置</h2><h3 id="1-复制工程（简化创建模块的步骤，P16）"><a href="#1-复制工程（简化创建模块的步骤，P16）" class="headerlink" title="1.复制工程（简化创建模块的步骤，P16）"></a>1.复制工程（简化创建模块的步骤，P16）</h3><ol><li>原则：<ol><li>保留工程基础结构</li><li>抹掉原始工程痕迹</li></ol></li><li>步骤：<ol><li>在工作空间中复制对应工程，并修改工程名称</li><li>删除与 IDEA 相关配置文件，仅保留 <code>src</code> 目录与 <code>pom.xml</code> 文件</li><li>修改 <code>pom.xml</code> 文件中的 <code>artifactId</code> 与新工程/模块名相同</li><li>删除 <code>name</code> 标签（可选）</li><li>保留备份工程供后期使用。</li></ol></li></ol><h3 id="2-属性配置"><a href="#2-属性配置" class="headerlink" title="2.属性配置"></a>2.属性配置</h3><ol><li>修改服务器端口<ol><li>SpringBoot 默认配置文件位于 <code>resources</code> 文件下的 <code>application.properties</code> 中，通过键值对配置对应属性。</li><li>修改服务端口：直接在文件中写入键值对即可。<img src="image-20230508175253514.png" alt="image-20230508175253514"></li></ol></li><li>关闭运行日志图标：<code>spring.main.banner-mode=off</code></li><li>设置日志相关： <code>logging.level.root=debug</code></li></ol><p>以上这些可以在 <code>application.properties</code> 中配置的所有选项都包含在 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties">Common Application Properties</a> 库中，可以在其中查找相关信息。除此之外，  <code>application.properties</code> 中配置的东西与 <code>starter</code> 关系紧密，必须包含相应的 <code>starter</code> 才能进行配置。书写 SpringBoot 配置采用 <strong><em>关键字+提示</em></strong> 形式书写，不需要背。配置文件的一般格式为：<img src="image-20230508175312671.png" alt="image-20230508175312671"></p><h3 id="3-属性配置的方式"><a href="#3-属性配置的方式" class="headerlink" title="3.属性配置的方式"></a>3.属性配置的方式</h3><ol><li>application.properties 格式： <code>server.port=80</code> </li><li>application.yml 格式：<img src="image-20230508175325583.png" alt="image-20230508175325583"></li><li>application.yaml 格式：<img src="image-20230508175339417.png" alt="image-20230508175339417"></li></ol><p>上述三种方式中，<strong><em>.yml 格式为主流格式</em></strong> 。 而 <code>.properties</code> 格式为默认格式。三种方式共存时， 不同配置文件中相同配置按加载优先级为： <code>.properties</code> &gt; <code>.yml</code> &gt; <code>.yaml</code> 互相覆盖，不同配置文件中不同配置全部保留。</p><h3 id="4-自动提示功能消失的解决方案"><a href="#4-自动提示功能消失的解决方案" class="headerlink" title="4.自动提示功能消失的解决方案"></a>4.自动提示功能消失的解决方案</h3><p>在 <code>Project Structure</code> 中的 <code>Facets</code> 按如下序号操作：<img src="image-20230508175359800.png" alt="image-20230508175359800"></p><h3 id="5-yaml-数据格式"><a href="#5-yaml-数据格式" class="headerlink" title="5.yaml 数据格式"></a>5.yaml 数据格式</h3><p><strong><em>yaml：</em></strong>（YAML Ain’t Markup Language），一种数据序列化格式</p><ul><li>优点：<ul><li>容易阅读</li><li>容易与脚本语言交互</li><li>以数据为核心、重数据轻格式</li></ul></li><li>YAML 文件扩展名：<ul><li><code>.yml</code> <strong>主流</strong></li><li><code>.yaml</code> </li></ul></li><li>语法规则：<ul><li>大小写敏感</li><li>属性层级关系使用多行描述，每行结尾使用冒号结束</li><li>使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用 Tab 键）</li><li>属性值前面添加空格（属性名与属性值之间使用冒号+空格作为分隔）</li><li><code>#</code> 表示注释</li></ul></li><li><strong><em>核心规则：</em></strong> 数据前面要加空格与冒号隔开。</li><li>字面值表示方式：<img src="image-20230508175414859.png" alt="image-20230508175414859"></li><li>数组表示方式：<img src="image-20230508175427134.png" alt="image-20230508175427134"></li></ul><h3 id="6-读取-yaml-中单一属性的数据"><a href="#6-读取-yaml-中单一属性的数据" class="headerlink" title="6.读取 yaml 中单一属性的数据"></a>6.读取 yaml 中单一属性的数据</h3><ol><li>使用 \@Value 配合 SpEL 读取单个数据</li><li>如果数据存在多层级，依次书写层级名称即可<img src="image-20230508175442124.png" alt="image-20230508175442124"></li><li><strong><em>yaml 文件中变量的引用：</em></strong><ol><li>在配置文件中可以使用 ${属性名} 方式引用属性值</li><li>如果属性中出现特殊字符，可以使用双引号包裹起来作为字符解析。<img src="image-20230508175453913.png" alt="image-20230508175453913"></li></ol></li></ol><h3 id="7-读取-yaml-中的全部数据"><a href="#7-读取-yaml-中的全部数据" class="headerlink" title="7.读取 yaml 中的全部数据"></a>7.读取 yaml 中的全部数据</h3><ol><li>使用 Environment 对象封装全部配置信息</li><li>使用 \@Autowired 自动装配数据到 Environment 对象中</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Environment env;</span><br><span class="line">System.out.println(env.getProperty(<span class="string">&quot;person[1].name&quot;</span>)); <span class="comment">//在方法中</span></span><br></pre></td></tr></table></figure><h3 id="8-读取yaml-文件中引用类型属性数据"><a href="#8-读取yaml-文件中引用类型属性数据" class="headerlink" title="8.读取yaml 文件中引用类型属性数据"></a>8.读取yaml 文件中引用类型属性数据</h3><p><strong><em>最常用的读取 yaml 文件中数据的方法</em></strong> </p><ol><li>定义数据模型封装yaml文件中对应的数据</li><li>定义为 Spring 管控的 bean</li><li>指定加载的数据<img src="image-20230508175511484.png" alt="image-20230508175511484"></li></ol><h2 id="1-5、整合第三方技术"><a href="#1-5、整合第三方技术" class="headerlink" title="1.5、整合第三方技术"></a>1.5、整合第三方技术</h2><h3 id="1-整合-JUnit"><a href="#1-整合-JUnit" class="headerlink" title="1.整合 JUnit"></a>1.整合 JUnit</h3><p><strong><em>JUnit：</em></strong> 一个java语言单元测试框架，这个框架最重要的就是 \@SpringBootTest 这个注解：</p><ul><li>\@SpringBootTest<ul><li>名称：<font color="red">测试类注解</font></li><li>位置：测试类定义上方</li><li>作用：设置 JUnit 加载的 SpringBoot 启动类</li></ul></li><li>步骤：<ul><li>导入测试对应的 starter</li><li>测试类使用 \@SpringBootTest 修饰</li><li>使用自动装配的形式添加要测试的对象</li></ul></li><li>classes 属性：<ul><li>作用：精准的指定配置类或者引导类所在的位置，如果不指定，仅能在所在包或副包中找配置类或引导类；如果指定，则可跨包寻找。</li><li>示例：<code>@SpringBootTest(classes=SpringBoot03JUnitApplication.class)</code></li><li>用途：<ul><li>测试类如果存在于引导类所在的包或者子包中，无需指定引导类</li><li>测试类如果不存在于引导类的包或子包中，需要通过 <code>classes</code> 属性指定引导类。</li></ul></li></ul></li></ul><h3 id="2-整合-MyBatis"><a href="#2-整合-MyBatis" class="headerlink" title="2.整合 MyBatis"></a>2.整合 MyBatis</h3><p><strong><em>MyBatis：</em></strong> 一个开源、轻量级的数据持久化框架，是 JDBC 和 Hibernate 的替代方案。</p><ul><li>所需基础：<ul><li>核心配置：数据库连接相关信息（连什么？连谁？什么权限？）</li><li>映射配置：SQL映射（XML/注解）</li></ul></li><li>步骤：<ul><li>选择当前模块需要使用的技术集：（MyBatis、MySQL）【整合技术，导入对应的坐标】<img src="image-20230508175527039.png" alt="image-20230508175527039"></li><li>设置数据源参数：（在 <code>.yml</code> 配置文件中），关键词为 <code>datasource</code> <img src="image-20230508175540755.png" alt="image-20230508175540755"></li><li>定义数据接口与映射配置：<img src="image-20230508175552520.png" alt="image-20230508175552520"></li><li>测试类中注入 <code>dao</code> 接口，测试功能：<img src="image-20230508175605663.png" alt="image-20230508175605663"></li></ul></li><li>常见问题：<ul><li>MySQL 8.X 驱动器强制要求设置时区<ul><li>修改url，添加 <code>serverTimezone</code> 设定</li><li>修改 MySQL 数据库配置</li><li><code>url: jdbc:mysql://localhost:3306/spring_boot?serverTimezone=UTC</code></li></ul></li><li>驱动类过时时，提醒更换为 <code>com.mysql.cj.jdbc.Driver</code></li></ul></li></ul><h3 id="3-整合-MyBatis-Plus"><a href="#3-整合-MyBatis-Plus" class="headerlink" title="3.整合 MyBatis-Plus"></a>3.整合 MyBatis-Plus</h3><ul><li>与 MyBatis 区别：<ul><li>导入坐标不同</li><li>数据层实现简化</li></ul></li><li>步骤：<ul><li>手动添加 SpringBoot 整合 MyBatis-Plus 的坐标，可以通过 mvnrepository 获取。<img src="image-20230508175701807.png" alt="image-20230508175701807"></li><li>定义数据层接口与映射配置，继承 <code>BaseMapper</code> <img src="image-20230508175715768.png" alt="image-20230508175715768"></li></ul></li></ul><h3 id="4-整合-Druid"><a href="#4-整合-Druid" class="headerlink" title="4.整合 Druid"></a>4.整合 Druid</h3><p><strong><em>Druid:</em></strong> Apache Druid是一个实时分析型数据库，旨在对大型数据集进行快速的查询分析。</p><ul><li>指定数据源类型的两种方式：<ul><li><img src="image-20230508175738601.png" alt="image-20230508175738601"></li><li>常规的方法：<img src="image-20230508175759626.png" alt="image-20230508175759626"></li></ul></li><li>步骤：<ul><li>整合 Druid 要导入 Druid 对应的 starter</li><li>根据 Druid 提供的配置方式进行配置</li><li><font color="red">整合第三方技术通用方式：</font><ul><li>导入对应的 <strong><em>starter</em></strong></li><li>根据提供的配置格式，配置非默认值对应的配置项</li></ul></li></ul></li></ul><h2 id="1-6、SSMP-整合案例"><a href="#1-6、SSMP-整合案例" class="headerlink" title="1.6、SSMP 整合案例"></a>1.6、SSMP 整合案例</h2><h3 id="1-整合案例分析"><a href="#1-整合案例分析" class="headerlink" title="1.整合案例分析"></a>1.整合案例分析</h3><p>案例的实现方案：</p><ul><li>实体类开发——使用 LomBok 快速制作实体类</li><li>Dao 开发——整合 MyBatis-Plus，制作数据层测试类</li><li>Service 开发——基于 MyBatis-plus 进行增量开发，制作业务层测试类</li><li>Controller 开发——基于 RESTful 开发，使用 PostMan 测试接口功能</li><li>Controller 开发——前后端开发协议制作</li><li>页面开发——基于 VUE+ElementUI 制作，前后端联调，页面数据处理，页面消息处理<ul><li>列表、新增、修改、删除、分页、查询</li></ul></li><li>项目异常处理</li><li>按条件查询——页面功能调整，Controller 修正功能，Service 修正功能</li></ul><h3 id="2-模块创建"><a href="#2-模块创建" class="headerlink" title="2.模块创建"></a>2.模块创建</h3><ol><li>勾选 SpringMVC 与MySQL 坐标</li><li>在 <code>pom.xml</code> 文件中导入 <code>MyBatis plus</code> 与 <code>Druid</code> 坐标</li><li>修改配置文件为 <code>.yml</code> 格式，并设置端口号为 <code>80</code></li></ol><h3 id="3-实体类快速开发（LomBok）"><a href="#3-实体类快速开发（LomBok）" class="headerlink" title="3.实体类快速开发（LomBok）"></a>3.实体类快速开发（LomBok）</h3><p><strong><em>LomBok：</em></strong> 一个 Java 类库，提供了一组注解，简化 POJO 实体类开发。</p><ol><li>导入 LomBok 依赖：<img src="image-20230508175852017.png" alt="image-20230508175852017"></li><li>可以为当前实体类设置对应的 get/set 方法， toString 方法，hashCode 方法，equals 方法。<img src="image-20230508175901683.png" alt="image-20230508175901683"></li></ol><h3 id="4-数据层标准开发（CURD）"><a href="#4-数据层标准开发（CURD）" class="headerlink" title="4.数据层标准开发（CURD）"></a>4.数据层标准开发（CURD）</h3><ul><li>步骤：<ul><li>手工导入 starter 坐标（两个：MyBatis plus；Druid）</li><li>配置数据源与 MyBatis Plus 对应的配置</li><li>开发 Dao 接口（继承 BaseMapper）</li><li>制作测试类测试 Dao 功能是否有效</li></ul></li><li>具体操作：<ul><li>导入 MyBatis Plus 与 Druid 对应的 starter：<img src="image-20230508175915008.png" alt="image-20230508175915008"></li><li>配置数据源与 MyBatis Plus 对应的基础配置（id生成册罗使用数据库自增策略）：<img src="image-20230508175926852.png" alt="image-20230508175926852"></li><li>Dao 接口：<img src="image-20230508175936897.png" alt="image-20230508175936897"></li></ul></li></ul><h3 id="5-开启-MP-运行日志"><a href="#5-开启-MP-运行日志" class="headerlink" title="5.开启 MP 运行日志"></a>5.开启 MP 运行日志</h3><ul><li>为方便调试可以开启 MyBatis Plus 的日志：在 pom 文件中配置<img src="image-20230508175958948.png" alt="image-20230508175958948"></li><li>实现结果：<img src="image-20230508180012880.png" alt="image-20230508180012880">  <font color="red">上线运行时，不可以开 日志功能</font></li></ul><h3 id="6-数据层开发——分页"><a href="#6-数据层开发——分页" class="headerlink" title="6.数据层开发——分页"></a>6.数据层开发——分页</h3><p><strong><em>MyBatis Plus拦截器：</em></strong> 对 SQL 语句进行拦截，然后修改达到不同的效果</p><ul><li>分页操作需要设定分页对象 <code>IPage</code> <img src="image-20230508180050515.png" alt="image-20230508180050515"></li><li>IPage 对象中封装了分页操作中的所有数据<ul><li>数据、当前页码值、每页数据总量、最大页码值、数据总量</li></ul></li><li>分页操作实在 MyBatis Plus 的常规操作基础上得到的，<font color="red">内部是动态的拼写 SQL 语句</font>，因此需要增强对应的功能，使用 MyBatisPlus 拦截器实现。<img src="image-20230508180100828.png" alt="image-20230508180100828"></li></ul><h3 id="7-数据层开发——条件查询功能"><a href="#7-数据层开发——条件查询功能" class="headerlink" title="7.数据层开发——条件查询功能"></a>7.数据层开发——条件查询功能</h3><p>这个有两种方法：</p><ul><li>使用 QueryWrapper 对象封装查询条件：<img src="image-20230508180113808.png" alt="image-20230508180113808"></li><li>使用 LambdaQueryWrapper 对象封装查询条件：<font color="red">推荐使用</font><img src="image-20230508180126418.png" alt="image-20230508180126418"></li></ul><h3 id="8-业务层标准开发（基础CURD）"><a href="#8-业务层标准开发（基础CURD）" class="headerlink" title="8.业务层标准开发（基础CURD）"></a>8.业务层标准开发（基础CURD）</h3><p><strong><em>业务层开发：</em></strong> service 层接口定义与数据层接口定义有很大差别，一般业务层更注重接口名，而数据层更注重对数据库的操作。</p><ul><li>步骤：<ul><li>接口定义：注意返回值类型 <img src="image-20230508180142344.png" alt="image-20230508180142344"></li><li>实现类定义：业务层注重逻辑规则，将接口定义为操作状态，所以在这里需要写 <code>&gt;0</code> <img src="image-20230508180152895.png" alt="image-20230508180152895"></li><li>测试类定义： <img src="image-20230508180204189.png" alt="image-20230508180204189"></li></ul></li><li>注意点：<ul><li>Service 接口名称定义为业务名称，并与 Dao 接口名称进行区分。</li><li>制作测试类测试 Service 功能是否有效。</li></ul></li></ul><h3 id="9-业务层快速开发——基于MyBatisPlus创建"><a href="#9-业务层快速开发——基于MyBatisPlus创建" class="headerlink" title="9.业务层快速开发——基于MyBatisPlus创建"></a>9.业务层快速开发——基于MyBatisPlus创建</h3><font color="red" size="4">在 IDEA 中，可以用 CTRL+F12 查看该类中所有的方法，包括继承的方法。</font><ul><li>快速开发方案：<ul><li>使用 MyBatisPlus 提供有业务层通用接口（IService\<T\>)与业务层通用实现类（ServiceImpl<M,T>）</M,T></T\></li><li>在通用类基础上做功能重载或功能追加</li><li>注意重载时不要覆盖原始操作，避免原始提供的功能丢失。</li></ul></li><li>主要步骤：<ul><li>接口定义：继承 <code>IService&lt;&gt;</code> 注意加入实体类范型。这里是 <code>Book</code> <img src="image-20230508180239608.png" alt="image-20230508180239608"></li><li>如果所需的功能在继承中没有，可以再手动添加：<img src="image-20230508180249584.png" alt="image-20230508180249584"></li><li>实现类定义：需要继承 <code>ServiceImpl&lt;&gt;</code> ，并且里面包含两个参数。<img src="image-20230508180301502.png" alt="image-20230508180301502"><br>  此外，实现类需实现接口类定义的其他功能。</li></ul></li></ul><h3 id="10-表现层标准开发"><a href="#10-表现层标准开发" class="headerlink" title="10.表现层标准开发"></a>10.表现层标准开发</h3><ul><li>分析<ul><li>基于 RESTful 进行表现层接口开发</li><li>使用 Postman 测试表现层接口功能</li></ul></li><li>步骤：<ul><li>表现层类开发： <img src="image-20230508180343463.png" alt="image-20230508180343463"></li></ul></li><li>基于 RESTful 制作表现层接口<ul><li>新增：POST、删除：DELETE、修改：PUT、查询：GET</li></ul></li><li>接收参数：<ul><li>实体参数：\@RequestBody</li><li>路径变量：\@PathVariable</li></ul></li></ul><h3 id="11-表现层数据一致性处理（R对象）"><a href="#11-表现层数据一致性处理（R对象）" class="headerlink" title="11.表现层数据一致性处理（R对象）"></a>11.表现层数据一致性处理（R对象）</h3><p>如果不进行一致性处理，则前端拿到的数据格式将五花八门，这里，使用 R对象方法进行一致性处理。R 对象： <font color="red">设计表现层返回结果的模型类，用于后端与前端进行数据格式统一。</font> 也成为 <strong><em>前后端数据协议</em></strong>。</p><ul><li>写 R 对象：<img src="image-20230508180412100.png" alt="image-20230508180412100"></li><li>表现层接口统一返回值类型结果：<img src="image-20230508180420954.png" alt="image-20230508180420954"></li></ul><h3 id="12-前后端调用（axios-发送异步请求）"><a href="#12-前后端调用（axios-发送异步请求）" class="headerlink" title="12.前后端调用（axios 发送异步请求）"></a>12.前后端调用（axios 发送异步请求）</h3><font color="red">本节及后续几节都在 book.html 中进行操作，需要掌握 WEB 相关知识。</font><ul><li><strong>前后端协议联调：</strong><ul><li>前后端分离结构设计中页面归属前端服务器</li><li>单体工程中页面放置在 resources 目录下的 static 目录中（建议执行 clean）</li></ul></li><li>在 static/pages/book.html 中实现 <code>getAll()</code> 方法：<ul><li>前端发送异步请求，调用后端接口：<img src="image-20230508180433273.png" alt="image-20230508180433273"><br>  axios 调用请求方法(get/post/put等)。括号里是针对的目标， <code>then</code> 后跟需要进行的操作。</li></ul></li><li>created 钩子函数用于初始化页面时发起调用。<img src="image-20230508180456265.png" alt="image-20230508180456265"></li><li>页面使用 axios 发送异步请求获取数据后确认前后端是否联通。</li></ul><h3 id="13-数据处理——列表功能"><a href="#13-数据处理——列表功能" class="headerlink" title="13.数据处理——列表功能"></a>13.数据处理——列表功能</h3><p>主要将数据库中的数据显示在 book.html 页面中。将查询数据返回到页面，利用前端数据双向绑定进行数据展示。<br>关键代码： <code>this.dataList=res.data.data</code> 。<img src="image-20230508180515055.png" alt="image-20230508180515055"></p><h3 id="14-添加功能"><a href="#14-添加功能" class="headerlink" title="14.添加功能"></a>14.添加功能</h3><p>可以在 book.html 中观察源代码与页面之间的关系，找到加入功能按钮对应的参数名，然后在下边寻找该参数名写入功能。</p><ul><li>弹出添加窗口：<img src="image-20230508180526742.png" alt="image-20230508180526742"></li><li>清除数据：<img src="image-20230508180535136.png" alt="image-20230508180535136"></li><li>添加功能：<img src="image-20230508180545808.png" alt="image-20230508180545808"></li><li>取消添加：页面中的取消键。<img src="image-20230508180556571.png" alt="image-20230508180556571"></li><li>步骤：<ul><li>请求方式使用 POST 调用后台对应操作</li><li>添加操作结束后动态刷新页面加载数据</li><li>根据操作结构不同，显示对应的提示信息</li><li>弹窗时加 Div 时清除表单数据</li></ul></li></ul><h3 id="15-删除功能"><a href="#15-删除功能" class="headerlink" title="15.删除功能"></a>15.删除功能</h3><ul><li>步骤：<ul><li>请求方式使用 delete 调用后台对应操作</li><li>删除操作需要传递当前行数据对应的 id 值到后台</li><li>删除操作结束后动态刷新页面加载数据</li><li>根据操作结果不同，显示对应的提示信息</li><li>删除操作前弹出提示框避免误操作</li></ul></li><li>删除功能：<img src="image-20230508180615137.png" alt="image-20230508180615137"><br>  <code>this.$confirm(&quot;提示信息&quot;,&quot;提示名&quot;,&#123;type:&#39;提示类型&#39;&#125;.then)</code> 为避免误操作的提示框。</li></ul><h3 id="16-修改功能（加载数据）"><a href="#16-修改功能（加载数据）" class="headerlink" title="16.修改功能（加载数据）"></a>16.修改功能（加载数据）</h3><ul><li>弹出修改窗口：<img src="image-20230508180635584.png" alt="image-20230508180635584"><ul><li>加载要修改数据通过传递当前行数据对应的 id 值到后台查询数据</li><li>利用前端数据双向绑定将查询到的数据进行回显</li></ul></li><li>修改功能：<img src="image-20230508180655314.png" alt="image-20230508180655314"></li><li>为了在点击 取消之后，窗口能够关闭，在 <code>cancel()</code> 中加入 <code>this.dialogFormVisible4Edit = false;</code> <ul><li>请求方式用 PUT 调用后台对应操作</li><li>修改操作结束后动态刷新页面加载数据（同新增）</li><li>根据操作结果不同，显示对应的提示信息（同新增）</li></ul></li></ul><h3 id="17-异常消息处理"><a href="#17-异常消息处理" class="headerlink" title="17.异常消息处理"></a>17.异常消息处理</h3><p>当项目异常时，后台得到的数据格式与正常时不一样，此时需要统一格式。<img src="image-20230508180714036.png" alt="image-20230508180714036"></p><ul><li>步骤：<ul><li>使用注解 \@RestControllerAdvice 定义 SpringMVC 异常处理器用来处理异常。</li><li>异常处理器必须被扫描加载，否则无法生效</li><li>表现层返回结果的模型类中添加消息属性用来传递消息到页面。</li></ul></li><li>详细代码<ul><li>对异常进行统一处理，出现异常后，返回指定信息：<img src="image-20230508180730374.png" alt="image-20230508180730374"></li><li>在 R 类中新增构造方法：<img src="image-20230508180739534.png" alt="image-20230508180739534"></li><li>可以在表现层 Controller 中进行消息统一处理：<img src="image-20230508180749916.png" alt="image-20230508180749916"></li><li>页面消息处理：<img src="image-20230508180757900.png" alt="image-20230508180757900"></li></ul></li></ul><h3 id="18-分页"><a href="#18-分页" class="headerlink" title="18.分页"></a>18.分页</h3><ul><li>步骤：<ul><li>使用 el 分页组件</li><li>定义分页组件绑定的数据类型</li><li>异步调用获取分页数据</li><li>分页数据页面回显</li></ul></li><li>具体代码：<ul><li>分页功能：<img src="image-20230508180810009.png" alt="image-20230508180810009"></li><li>切换页码：<img src="image-20230508180818240.png" alt="image-20230508180818240"></li></ul></li><li>上面的 <code>pagination</code> 等具体参数需要参考 <code>page.html</code> 中的参数。</li></ul><h3 id="19-分页功能维护（删除-BUG）"><a href="#19-分页功能维护（删除-BUG）" class="headerlink" title="19.分页功能维护（删除 BUG）"></a>19.分页功能维护（删除 BUG）</h3><p>对查询结果进行校验，如果当前页面值大于最大页面值，那么重新执行查询操作，使用最大页面值作为当前页面值：<img src="image-20230508180836889.png" alt="image-20230508180836889"></p><h3 id="20-条件查询"><a href="#20-条件查询" class="headerlink" title="20.条件查询"></a>20.条件查询</h3><ul><li>查询条件数据封装<ul><li>单独封装</li><li>与分页操作混合封装<img src="image-20230508180846946.png" alt="image-20230508180846946"></li><li>页面数据模型绑定：<img src="image-20230508180900086.png" alt="image-20230508180900086"></li><li>组织数据成为 get 请求发送数据：<img src="image-20230508180910439.png" alt="image-20230508180910439"></li><li>Controller 接收参数：<img src="image-20230508180919875.png" alt="image-20230508180919875"></li><li>条件查询功能：<img src="image-20230508180928709.png" alt="image-20230508180928709"></li></ul></li></ul><h1 id="二、运维实用篇"><a href="#二、运维实用篇" class="headerlink" title="二、运维实用篇"></a>二、运维实用篇</h1><h2 id="1、工程打包与运行"><a href="#1、工程打包与运行" class="headerlink" title="1、工程打包与运行"></a>1、工程打包与运行</h2><ol><li>对 SpringBoot 项目打包（执行 Maven 构建指令 package）<code>mvn package</code></li><li>运行项目（执行启动指令） <code>java -jar springboot.jar</code> 【注】：jar 支持命令启动需要依赖 maven 插件支持，请确认打包时是否具有 SpringBoot 对应的 maven 插件。<img src="image-20230508180939381.png" alt="image-20230508180939381"></li><li>总结：<ol><li>SpringBoot 工程可以基于 java 环境独立运行 jar 文件启动服务</li><li>SpringBoot 工程执行 mvn命令 package 进行打包</li><li>执行 jar 命令： <code>java -jar 工程名.jar</code> </li></ol></li></ol><h2 id="2、命令行启动常见问题及解决方案"><a href="#2、命令行启动常见问题及解决方案" class="headerlink" title="2、命令行启动常见问题及解决方案"></a>2、命令行启动常见问题及解决方案</h2><ul><li>Windows端口被占用<ul><li>查询端口： <code>netstat -ano</code></li><li>查询指定端口： <code>netstat -ano|findstr &quot;端口号&quot;</code></li><li>根据进程 PID 查询进程名称： <code>tasklist |findstr &quot;进程 PID 号&quot;</code></li><li>根据 PID 杀死任务： <code>taskkill /F /PID &quot;进程PID号&quot;</code> </li><li>根据进程名称杀死任务： <code>taskkill -f -t -im &quot;进程名称&quot;</code></li></ul></li></ul><h2 id="3-配置文件分类"><a href="#3-配置文件分类" class="headerlink" title="3.配置文件分类"></a>3.配置文件分类</h2><ol><li>SpringBoot 中4级配置文件<ol><li>1级： file : config/application.yml  <font color="red">最高</font> </li><li>2级： file: application.yml</li><li>3级： classpath: config/application.yml</li><li>4级： classpath: application.yml <font color="red">最低</font> </li></ol></li><li>作用：<ol><li>1级与2级留做系统打包后设置通用属性，1级常用于运维经理进行线上整体项目部署方案调控</li><li>3级与4级用于系统开发阶段设置通用属性，3级常用于项目经理进行整体项目属性调控。</li></ol></li><li>配置文件分为四种：<img src="image-20230508181002048.png" alt="image-20230508181002048"></li><li>多层级配置文件的属性采用叠加并覆盖的形式作用域程序。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双目视觉综述</title>
      <link href="/2022/11/11/%E5%8F%8C%E7%9B%AE%E8%A7%86%E8%A7%89%E7%BB%BC%E8%BF%B0/"/>
      <url>/2022/11/11/%E5%8F%8C%E7%9B%AE%E8%A7%86%E8%A7%89%E7%BB%BC%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一篇：双目视觉的匹配算法综述"><a href="#第一篇：双目视觉的匹配算法综述" class="headerlink" title="第一篇：双目视觉的匹配算法综述"></a>第一篇：双目视觉的匹配算法综述</h1><p><a href="attachments/双目视觉的匹配算法综述_陈炎.pdf">双目视觉的匹配算法综述_陈炎.pdf</a></p><ol><li>立体视觉的工作流程：双目标定、图像校正、立体匹配和三维重建。</li></ol><p><strong>影响因素</strong>： 光照不均匀、遮挡、模糊以及噪声。在一些领域中，需要具备实时、准确的深度估计，</p><p>由双目相机的成像原理：只需要计算处于同一水平线上的左右图像的像素相似值。 <strong>极约束</strong>。</p><h2 id="1、基于人工特征的匹配算法"><a href="#1、基于人工特征的匹配算法" class="headerlink" title="1、基于人工特征的匹配算法"></a>1、基于人工特征的匹配算法</h2><p><strong>立体匹配算法的实现流程：</strong> 代价计算、代价聚合、视差计算和视差求精。<img src="image-20230508184340403.png" alt="image-20230508184340403"></p><ul><li>代价计算：对匹配区域像素点和参考区域进行相似度计算</li><li>代价聚合：通过设置能量函数，将中心像素点的相似度值用某个范围内的像素点代价计算结果替代。（绝对差之和【SAD】，平方差之和【SSD】，归一化互相关【NCC】，秩变换【RT】，普查变换【CT】）</li><li>视差计算：选取参考区域内相似度最高的像素点来计算。</li><li>视差求精：减少错误匹配的像素点，优化视差图。（优化步骤：正则化和遮挡填充或插值）</li></ul><h3 id="1-1-全局立体匹配算法"><a href="#1-1-全局立体匹配算法" class="headerlink" title="1.1 全局立体匹配算法"></a>1.1 全局立体匹配算法</h3><p>其能量函数整合了图像中的所有像素，以尽可能多的获得全局信息。</p><p>通常是先找出图像中显著的特征点、特征线或者扫描线，初步匹配得出一个初始的视差值，然后使用全局能量函数进行约束，通过匹配算法不断地对分配的视差值迭代优化，直到最优。此迭代优化的过程以全局能量函数最小化为目的。</p><p>$E<em>d=E</em>{data}(D)+\lambda·E_{smooth}(D)$ </p><h3 id="1-2-局部立体匹配算法"><a href="#1-2-局部立体匹配算法" class="headerlink" title="1.2 局部立体匹配算法"></a>1.2 局部立体匹配算法</h3><p>将参考图像分为若干图像块，再求取匹配图像内预期相似度最高的图像块，生成深度图。</p><h2 id="2、基于深度学习的匹配算法"><a href="#2、基于深度学习的匹配算法" class="headerlink" title="2、基于深度学习的匹配算法"></a>2、基于深度学习的匹配算法</h2><p>深度学习通过卷积、池化、全连接等操作，对图像进行非线性变换，提取图像的多层特征用于代价计算。深度学习的方法更多地利用了图像的全局信息，通过预训练获得模型参数，提高了算法地鲁棒性。用于立体匹配地图像网络主要可分为<strong>金字塔网络、孪生网络和生成对抗网络。</strong></p><h3 id="2-1-图像金字塔网络"><a href="#2-1-图像金字塔网络" class="headerlink" title="2.1 图像金字塔网络"></a>2.1 图像金字塔网络</h3><ol><li>为了保持输入尺寸的一致性，再卷积层和全连接层之间设置了空间金字塔池化层，将不同尺寸的图片特征转化为固定长度地表示，避免了卷积地重复计算。</li><li>将金字塔池化模块引入到特征提取中，使用<strong>多尺度分析和3D-CNN</strong>结构，有效的解决了梯度消失和梯度爆炸地问题，在弱纹理、遮挡、光照不均匀等条件下获得了良好的效果。</li></ol><h3 id="2-2-孪生网络"><a href="#2-2-孪生网络" class="headerlink" title="2.2 孪生网络"></a>2.2 孪生网络</h3><p>通过设置两个权重共享地卷积神经网络，分别输入左、右图像，通过映射函数将卷积得到地特征转化为特征向量，衡量2个特征向量间地L1距离就可以拟合2张图片地相似度。<img src="image-20230508184359454.png" alt="image-20230508184359454"></p><h3 id="3-2-生成对抗网络"><a href="#3-2-生成对抗网络" class="headerlink" title="3.2 生成对抗网络"></a>3.2 生成对抗网络</h3><p>网络由生成模型和判别模型构成。生成模型学习样本特征，生成图像与原图像相似，而判别模型则用来分辨“生成”图片与真实图片。这个过程不断迭代运行，最终判别结果达到纳什均衡，即真假概念均为0.5。</p><p><strong>立体匹配算法主要有 <em>Midelebury</em> 和 <em>KITTI</em> 两个测评数据集。</strong><img src="image-20230508184421772.png" alt="image-20230508184421772"></p><h1 id="第二篇：双目立体视觉匹配技术综述"><a href="#第二篇：双目立体视觉匹配技术综述" class="headerlink" title="第二篇：双目立体视觉匹配技术综述"></a>第二篇：双目立体视觉匹配技术综述</h1><p><a href="https://kns.cnki.net/KXReader/Detail?invoice=pjwQwwYK41e5EKT4zJW9JHxYoQIscWnyz8pbuHetH%2F5MoV3upqfTl%2B9IoJ4rYImXHLTxg7CBIGr5sCfAvV9RDT%2BZa9aE%2BM3%2BUDAGFjAT%2Bx0d6pkmQSq2kFk4GEQalfAh%2F%2BHtP08cqMDpHuLz3PWrdPAeoK63oNPxVDO5M%2FmAZd0%3D&amp;DBCODE=CJFD&amp;FileName=CGGL201502014&amp;TABLEName=cjfdlast2015&amp;nonce=38451E42A6914432AFFBD0C9CC76C701&amp;uid=&amp;TIMESTAMP=1649997495336">中国知网-登录</a></p><h2 id="1、双目立体视觉系统"><a href="#1、双目立体视觉系统" class="headerlink" title="1、双目立体视觉系统"></a>1、双目立体视觉系统</h2><p><img src="image-20230508184435344.png" alt="image-20230508184435344"></p><p>$O_l$和$O_r$为相机位置，P为观测点，则第三维（深度）的测量为：$<strong>Z=\frac{b·f}{d}</strong>$ ，其中 $f$ 为焦距，$d$ 为视差，即 $P_l$ 和 $P_r$ 两图像在 X 轴方向上的差值，深度为 Z。基线 b 和焦距 f 可在双目标定时计算得出。因此，双目立体视觉定位的核心内容是对视差 d 的计算。视差 d 由立体匹配得出。</p><h3 id="1-1-立体匹配约束"><a href="#1-1-立体匹配约束" class="headerlink" title="1.1 立体匹配约束"></a>1.1 立体匹配约束</h3><ol><li>唯一性约束：三维空间中的点映射到左右摄像头时，只会在图像上映射出唯一的对应点。在匹配时左右图像只有唯一一点相匹配</li><li>连续性约束：三维空间中的物体一般是连续光滑的，在映射到左右摄像头时这种特性也被保留下来。在连续的图像上，其视差也一般是连续的。</li><li>极线约束：对于一个图像上的映射点来说，其匹配点必定落在另一副图像的极线上。点在图像中的坐标 y 值相等</li><li>顺序一致性约束：三维空间中点的位置关系会在映射到成像平面时保留下来，即原物体的位置顺序在两幅图像中不会改变。</li></ol><h3 id="1-2-立体匹配的匹配基元"><a href="#1-2-立体匹配的匹配基元" class="headerlink" title="1.2 立体匹配的匹配基元"></a>1.2 立体匹配的匹配基元</h3><p>匹配基元是立体匹配中的单位匹配对象，也就是立体匹配中的匹配特征对象。最常用的特征就是点特征，例如像素点的灰度、颜色值、Harris角点、SIFT特征点等。  <strong>点、块、线</strong>。 线一般为边缘线。</p><p><img src="image-20230508184451840.png" alt="image-20230508184451840"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双目视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch网络结构、训练过程、可视化工具汇总</title>
      <link href="/2022/11/08/PyTorch%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E3%80%81%E8%AE%AD%E7%BB%83%E8%BF%87%E7%A8%8B%E3%80%81%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB/"/>
      <url>/2022/11/08/PyTorch%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E3%80%81%E8%AE%AD%E7%BB%83%E8%BF%87%E7%A8%8B%E3%80%81%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="一、网络结构的可视化"><a href="#一、网络结构的可视化" class="headerlink" title="一、网络结构的可视化"></a>一、网络结构的可视化</h1><p>我们训练神经网络时，除了随着 step 或者 epoch 观察损失函数的走势，从而建立对目前网络优化的基本认知外，也可以通过一些额外的可视化库来可视化我们的神经网络结构图。这将更加地高效地向读者展现目前的网络结构。<br>为了可视化神经网络，我们先建立一个简单的卷积层神经网络：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch  </span><br><span class="line"> <span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn  </span><br><span class="line">   </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">ConvNet</span>(nn.Module):  </span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):  </span><br><span class="line">         <span class="built_in">super</span>(ConvNet, self).__init__()  </span><br><span class="line">   </span><br><span class="line">         self.conv1 = nn.Sequential(  </span><br><span class="line">             nn.Conv2d(<span class="number">1</span>, <span class="number">16</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>),  </span><br><span class="line">             nn.ReLU(),  </span><br><span class="line">             nn.AvgPool2d(<span class="number">2</span>, <span class="number">2</span>)  </span><br><span class="line">         )  </span><br><span class="line">   </span><br><span class="line">         self.conv2 = nn.Sequential(  </span><br><span class="line">             nn.Conv2d(<span class="number">16</span>, <span class="number">32</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>),  </span><br><span class="line">             nn.ReLU(),  </span><br><span class="line">             nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>)  </span><br><span class="line">         )  </span><br><span class="line">   </span><br><span class="line">         self.fc = nn.Sequential(  </span><br><span class="line">             nn.Linear(<span class="number">32</span> * <span class="number">7</span> * <span class="number">7</span>, <span class="number">128</span>),  </span><br><span class="line">             nn.ReLU(),  </span><br><span class="line">             nn.Linear(<span class="number">128</span>, <span class="number">64</span>),  </span><br><span class="line">             nn.ReLU()  </span><br><span class="line">         )  </span><br><span class="line">   </span><br><span class="line">         self.out = nn.Linear(<span class="number">64</span>, <span class="number">10</span>)  </span><br><span class="line">   </span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):  </span><br><span class="line">         x = self.conv1(x)  </span><br><span class="line">         x = self.conv2(x)  </span><br><span class="line">         x = x.view(x.size(<span class="number">0</span>), -<span class="number">1</span>)  </span><br><span class="line">         x = self.fc(x)  </span><br><span class="line">         output = self.out(x)  </span><br><span class="line">         <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><p>输出网络结构：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> MyConvNet = ConvNet()  </span><br><span class="line"> <span class="built_in">print</span>(MyConvNet)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> ConvNet(  </span><br><span class="line">   (conv1): Sequential(  </span><br><span class="line">     (<span class="number">0</span>): Conv2d(<span class="number">1</span>, <span class="number">16</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), stride=(<span class="number">1</span>, <span class="number">1</span>), padding=(<span class="number">1</span>, <span class="number">1</span>))  </span><br><span class="line">     (<span class="number">1</span>): ReLU()  </span><br><span class="line">     (<span class="number">2</span>): AvgPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>, padding=<span class="number">0</span>)  </span><br><span class="line">   )  </span><br><span class="line">   (conv2): Sequential(  </span><br><span class="line">     (<span class="number">0</span>): Conv2d(<span class="number">16</span>, <span class="number">32</span>, kernel_size=(<span class="number">3</span>, <span class="number">3</span>), stride=(<span class="number">1</span>, <span class="number">1</span>), padding=(<span class="number">1</span>, <span class="number">1</span>))  </span><br><span class="line">     (<span class="number">1</span>): ReLU()  </span><br><span class="line">     (<span class="number">2</span>): MaxPool2d(kernel_size=<span class="number">2</span>, stride=<span class="number">2</span>, padding=<span class="number">0</span>, dilation=<span class="number">1</span>, ceil_mode=<span class="literal">False</span>)  </span><br><span class="line">   )  </span><br><span class="line">   (fc): Sequential(  </span><br><span class="line">     (<span class="number">0</span>): Linear(in_features=<span class="number">1568</span>, out_features=<span class="number">128</span>, bias=<span class="literal">True</span>)  </span><br><span class="line">     (<span class="number">1</span>): ReLU()  </span><br><span class="line">     (<span class="number">2</span>): Linear(in_features=<span class="number">128</span>, out_features=<span class="number">64</span>, bias=<span class="literal">True</span>)  </span><br><span class="line">     (<span class="number">3</span>): ReLU()  </span><br><span class="line">   )  </span><br><span class="line">   (out): Linear(in_features=<span class="number">64</span>, out_features=<span class="number">10</span>, bias=<span class="literal">True</span>)  </span><br><span class="line"> )</span><br></pre></td></tr></table></figure><p>有了基本的神经网络后，我们分别通过 <code>HiddenLayer</code> 和 <code>PyTorchViz</code> 库来可视化上述的卷积层神经网络。</p><blockquote><p>需要说明的是，这两个库都是基于 Graphviz 开发的，因此倘若你的电脑上没有安装并且没有添加环境变量，请自行安装 Graphviz 工具，安装教程</p></blockquote><h2 id="1-1-通过-HiddenLayer-可视化网络"><a href="#1-1-通过-HiddenLayer-可视化网络" class="headerlink" title="1.1 通过 HiddenLayer 可视化网络"></a>1.1 通过 HiddenLayer 可视化网络</h2><p>首先当然是安装库啦，打开 cmd，输入：<code>pip install hiddenlayer</code><br>绘制的基本程序如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> hiddenlayer <span class="keyword">as</span> h  </span><br><span class="line"> vis_graph = h.build_graph(MyConvNet, torch.zeros([<span class="number">1</span> ,<span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>]))   <span class="comment"># 获取绘制图像的对象  </span></span><br><span class="line"> vis_graph.theme = h.graph.THEMES[<span class="string">&quot;blue&quot;</span>].copy()     <span class="comment"># 指定主题颜色  </span></span><br><span class="line"> vis_graph.save(<span class="string">&quot;./demo1.png&quot;</span>)   <span class="comment"># 保存图像的路径</span></span><br></pre></td></tr></table></figure><p>效果如下：<img src="image-20230508170702874.png" alt="image-20230508170702874"></p><h2 id="1-2-通过-PyTorchViz-可视化网络"><a href="#1-2-通过-PyTorchViz-可视化网络" class="headerlink" title="1.2 通过 PyTorchViz 可视化网络"></a>1.2 通过 PyTorchViz 可视化网络</h2><p>先安装库：<code>pip install torchviz</code><br>这里我们只使用可视化函数 <code>make_dot()</code> 来获取绘图对象，基本使用和 <code>HiddenLayer</code> 差不多，不同的地方在于 <code>PyTorch</code> 绘图之前可以指定一个网络的输入值和预测值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">from</span> torchviz <span class="keyword">import</span> make_dot  </span><br><span class="line"> x = torch.randn(<span class="number">1</span>, <span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>).requires_grad_(<span class="literal">True</span>)  <span class="comment"># 定义一个网络的输入值  </span></span><br><span class="line"> y = MyConvNet(x)    <span class="comment"># 获取网络的预测值  </span></span><br><span class="line">   </span><br><span class="line"> MyConvNetVis = make_dot(y, params=<span class="built_in">dict</span>(<span class="built_in">list</span>(MyConvNet.named_parameters()) + [(<span class="string">&#x27;x&#x27;</span>, x)]))  </span><br><span class="line"> MyConvNetVis.<span class="built_in">format</span> = <span class="string">&quot;png&quot;</span>  </span><br><span class="line"> <span class="comment"># 指定文件生成的文件夹  </span></span><br><span class="line"> MyConvNetVis.directory = <span class="string">&quot;data&quot;</span>  </span><br><span class="line"> <span class="comment"># 生成文件  </span></span><br><span class="line"> MyConvNetVis.view()</span><br></pre></td></tr></table></figure><p>打开与上述代码相同根目录下的 data 文件夹，里面会有一个 <code>.gv</code> 文件和一个 <code>.png</code> 文件，其中的 <code>.gv</code> 文件是 Graphviz 工具生成图片的脚本代码，<code>.png</code> 是 <code>.gv</code> 文件编译生成的图片，直接打开 <code>.png</code> 文件就行。</p><blockquote><p>默认情况下，上述程序运行后会自动打开. png 文件</p></blockquote><p>生成图片：<img src="image-20230508170715537.png" alt="image-20230508170715537"></p><h1 id="二、训练过程可视化"><a href="#二、训练过程可视化" class="headerlink" title="二、训练过程可视化"></a>二、训练过程可视化</h1><p>观察我们的网络的每一步的损失函数或准确率的变化可以有效地帮助我们判断当前训练过程的优劣。如果能将这些过程可视化，那么我们判断的准确性和舒适性都会有所增加。</p><p>此处主要讲通过可视化神器<code>tensorboardX</code>和刚刚用到的<code>HiddenLayer</code>来实现训练过程的可视化。</p><p>为了训练网络，我们先导入训练网络需要的数据，此处就导入 MNIST 数据集，并做训练前的一些基本的数据处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> torchvision  </span><br><span class="line"> <span class="keyword">import</span> torch.utils.data <span class="keyword">as</span> Data  </span><br><span class="line"> <span class="comment"># 准备训练用的MNIST数据集  </span></span><br><span class="line"> train_data = torchvision.datasets.MNIST(  </span><br><span class="line">     root = <span class="string">&quot;./data/MNIST&quot;</span>,  <span class="comment"># 提取数据的路径  </span></span><br><span class="line">     train=<span class="literal">True</span>, <span class="comment"># 使用MNIST内的训练数据  </span></span><br><span class="line">     transform=torchvision.transforms.ToTensor(),    <span class="comment"># 转换成torch.tensor  </span></span><br><span class="line">     download=<span class="literal">False</span>   <span class="comment"># 如果是第一次运行的话，置为True，表示下载数据集到root目录  </span></span><br><span class="line"> )  </span><br><span class="line">   </span><br><span class="line"> <span class="comment"># 定义loader  </span></span><br><span class="line"> train_loader = Data.DataLoader(  </span><br><span class="line">     dataset=train_data,  </span><br><span class="line">     batch_size=<span class="number">128</span>,  </span><br><span class="line">     shuffle=<span class="literal">True</span>,  </span><br><span class="line">     num_workers=<span class="number">0</span>  </span><br><span class="line"> )  </span><br><span class="line">   </span><br><span class="line"> test_data = torchvision.datasets.MNIST(  </span><br><span class="line">     root=<span class="string">&quot;./data/MNIST&quot;</span>,  </span><br><span class="line">     train=<span class="literal">False</span>,    <span class="comment"># 使用测试数据  </span></span><br><span class="line">     download=<span class="literal">False</span>  </span><br><span class="line"> )  </span><br><span class="line">   </span><br><span class="line"> <span class="comment"># 将测试数据压缩到0-1  </span></span><br><span class="line"> test_data_x = test_data.data.<span class="built_in">type</span>(torch.FloatTensor) / <span class="number">255.0</span>  </span><br><span class="line"> test_data_x = torch.unsqueeze(test_data_x, dim=<span class="number">1</span>)  </span><br><span class="line"> test_data_y = test_data.targets  </span><br><span class="line">   </span><br><span class="line"> <span class="comment"># 打印一下测试数据和训练数据的shape  </span></span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;test_data_x.shape:&quot;</span>, test_data_x.shape)  </span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;test_data_y.shape:&quot;</span>, test_data_y.shape)  </span><br><span class="line">   </span><br><span class="line"> <span class="keyword">for</span> x, y <span class="keyword">in</span> train_loader:  </span><br><span class="line">     <span class="built_in">print</span>(x.shape)  </span><br><span class="line">     <span class="built_in">print</span>(y.shape)  </span><br><span class="line">     <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> test_data_x.shape: torch.Size([<span class="number">10000</span>, <span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>])  </span><br><span class="line"> test_data_y.shape: torch.Size([<span class="number">10000</span>])  </span><br><span class="line"> torch.Size([<span class="number">128</span>, <span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>])  </span><br><span class="line"> torch.Size([<span class="number">128</span>])</span><br></pre></td></tr></table></figure><h2 id="2-1-通过-tensorboardX-可视化训练过程"><a href="#2-1-通过-tensorboardX-可视化训练过程" class="headerlink" title="2.1 通过 tensorboardX 可视化训练过程"></a>2.1 通过 tensorboardX 可视化训练过程</h2><p><code>tensorboard</code> 是谷歌开发的深度学习框架 tensorflow 的一套深度学习可视化神器，在 pytorch 团队的努力下，他们开发出了 tensorboardX 来让 pytorch 的玩家也能享受 tensorboard 的福利。<br>先安装相关的库：<code>pip install tensorboardX tensorboard</code></p><p>并将 tensorboard. exe 所在的文件夹路径加入环境变量 path 中（比如我的 tensorboard. exe 的路径为 <code>D:\Python376\Scripts\tensorboard.exe</code>，那么就在 path 中加入 <code>D:\Python376\Scripts</code>）</p><p>下面是 <code>tensorboardX</code> 的使用过程。基本使用为，先通过 <code>tensorboardX</code> 下的 <code>SummaryWriter</code> 类获取一个日志编写器对象。然后通过这个对象的一组方法往日志中添加事件，即生成相应的图片，最后启动前端服务器，在 localhost 中就可以看到最终的结果了。</p><p>训练网络，并可视化网络训练过程的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorboardX <span class="keyword">import</span> SummaryWriter  </span><br><span class="line"> logger = SummaryWriter(log_dir=<span class="string">&quot;data/log&quot;</span>)  </span><br><span class="line">   </span><br><span class="line"> <span class="comment"># 获取优化器和损失函数  </span></span><br><span class="line"> optimizer = torch.optim.Adam(MyConvNet.parameters(), lr=<span class="number">3e-4</span>)  </span><br><span class="line"> loss_func = nn.CrossEntropyLoss()  </span><br><span class="line"> log_step_interval = <span class="number">100</span>      <span class="comment"># 记录的步数间隔  </span></span><br><span class="line">   </span><br><span class="line"> <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):  </span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&quot;epoch:&quot;</span>, epoch)  </span><br><span class="line">     <span class="comment"># 每一轮都遍历一遍数据加载器  </span></span><br><span class="line">     <span class="keyword">for</span> step, (x, y) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):  </span><br><span class="line">         <span class="comment"># 前向计算-&gt;计算损失函数-&gt;(从损失函数)反向传播-&gt;更新网络  </span></span><br><span class="line">         predict = MyConvNet(x)  </span><br><span class="line">         loss = loss_func(predict, y)  </span><br><span class="line">         optimizer.zero_grad()   <span class="comment"># 清空梯度（可以不写）  </span></span><br><span class="line">         loss.backward()     <span class="comment"># 反向传播计算梯度  </span></span><br><span class="line">         optimizer.step()    <span class="comment"># 更新网络  </span></span><br><span class="line">         global_iter_num = epoch * <span class="built_in">len</span>(train_loader) + step + <span class="number">1</span>  <span class="comment"># 计算当前是从训练开始时的第几步(全局迭代次数)  </span></span><br><span class="line">         <span class="keyword">if</span> global_iter_num % log_step_interval == <span class="number">0</span>:  </span><br><span class="line">             <span class="comment"># 控制台输出一下  </span></span><br><span class="line">             <span class="built_in">print</span>(<span class="string">&quot;global_step:&#123;&#125;, loss:&#123;:.2&#125;&quot;</span>.<span class="built_in">format</span>(global_iter_num, loss.item()))  </span><br><span class="line">             <span class="comment"># 添加的第一条日志：损失函数-全局迭代次数  </span></span><br><span class="line">             logger.add_scalar(<span class="string">&quot;train loss&quot;</span>, loss.item() ,global_step=global_iter_num)  </span><br><span class="line">             <span class="comment"># 在测试集上预测并计算正确率  </span></span><br><span class="line">             test_predict = MyConvNet(test_data_x)  </span><br><span class="line">             _, predict_idx = torch.<span class="built_in">max</span>(test_predict, <span class="number">1</span>)     <span class="comment"># 计算softmax后的最大值的索引，即预测结果  </span></span><br><span class="line">             acc = accuracy_score(test_data_y, predict_idx)  </span><br><span class="line">             <span class="comment"># 添加第二条日志：正确率-全局迭代次数  </span></span><br><span class="line">             logger.add_scalar(<span class="string">&quot;test accuary&quot;</span>, acc.item(), global_step=global_iter_num)  </span><br><span class="line">             <span class="comment"># 添加第三条日志：这个batch下的128张图像  </span></span><br><span class="line">             img = vutils.make_grid(x, nrow=<span class="number">12</span>)  </span><br><span class="line">             logger.add_image(<span class="string">&quot;train image sample&quot;</span>, img, global_step=global_iter_num)  </span><br><span class="line">             <span class="comment"># 添加第三条日志：网络中的参数分布直方图  </span></span><br><span class="line">             <span class="keyword">for</span> name, param <span class="keyword">in</span> MyConvNet.named_parameters():  </span><br><span class="line">                 logger.add_histogram(name, param.data.numpy(), global_step=global_iter_num)</span><br></pre></td></tr></table></figure><p>运行完后，我们通过 cmd 来到与代码同一级的目录（如果你使用的是 pycharm，可以通过 pycharm 中的终端）输入指令 <code>tensorboard --logdir=&quot;./data/log&quot;</code>，启动服务器。<img src="image-20230508170733748.png" alt="image-20230508170733748"></p><blockquote><p>logdir 后面的参数是日志文件的文件夹的路径</p></blockquote><p>然后在谷歌浏览器中访问红框框中的 url，便可得到可视化界面，点击上面的页面控件，可以查看我们通过 <code>add_scalar</code>、<code>add_image</code> 和 <code>add_histogram</code> 得到的图像，而且各方面做得都很丝滑。</p><p><img src="image-20230508170745824.png" alt="image-20230508170745824"></p><p><img src="image-20230508170805510.png" alt="image-20230508170805510"></p><p><img src="image-20230508170817934.png" alt="image-20230508170817934"></p><blockquote><p>以下是一切安装时候的错误</p></blockquote><p>好，作为一名<strong>没有装过 TensorFlow</strong>的 windows 玩家，笔者下面开始踩坑。踩完后，直接把几个可能的错误呈上。</p><p><strong>第一个错误，运行<code>tensorboard --logdir=&quot;./data/log&quot;</code>，遇到报错，内容为有重复的tensorboard的包。</strong></p><p>解决方法：找到 site-packages（如果你是像我一样全局安装的，那么找到解释器那一级目录的 site-packages，如果是在项目虚拟环境中安装的，那么找到项目中的 site-packages），删去下图中红框框标出来的文件夹。</p><p><img src="image-20230508170831622.png" alt="image-20230508170831622"></p><p><strong>第二个错误，在解决第一个错误后，再次运行命令，还是报错，内容为编码出错。</strong> 由于笔者做过一点前端，在学习 webpack 项目时，曾经被告知项目路径不能含有中文，否则会有编码错误，而刚才的报错中涉及到了前端服务器的启动，因此，笔者想到从文件名入手。</p><p><strong>解决方法：</strong> 确保命令涉及的文件路径、所有程序涉及到文件不含中文。笔者是计算机名字含有中文，然后 tensorboard 的日志文件是以本地计算机名为后缀的，所以笔者将计算机名修改成了英文，重启后再输入指令就 ok 了。</p><h2 id="2-2-HiddenLayer-可视化训练过程"><a href="#2-2-HiddenLayer-可视化训练过程" class="headerlink" title="2.2 HiddenLayer 可视化训练过程"></a>2.2 HiddenLayer 可视化训练过程</h2><p>tensorboard 的图像很华丽，但是使用过程相较于其他的工具包较为繁琐，所以小网络一般没必要使用 tensorboard。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> hiddenlayer <span class="keyword">as</span> hl  </span><br><span class="line"> <span class="keyword">import</span> time  </span><br><span class="line">   </span><br><span class="line"> <span class="comment"># 记录训练过程的指标  </span></span><br><span class="line"> history = hl.History()  </span><br><span class="line"> <span class="comment"># 使用canvas进行可视化  </span></span><br><span class="line"> canvas = hl.Canvas()  </span><br><span class="line">   </span><br><span class="line"> <span class="comment"># 获取优化器和损失函数  </span></span><br><span class="line"> optimizer = torch.optim.Adam(MyConvNet.parameters(), lr=<span class="number">3e-4</span>)  </span><br><span class="line"> loss_func = nn.CrossEntropyLoss()  </span><br><span class="line"> log_step_interval = <span class="number">100</span>      <span class="comment"># 记录的步数间隔  </span></span><br><span class="line">   </span><br><span class="line"> <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):  </span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&quot;epoch:&quot;</span>, epoch)  </span><br><span class="line">     <span class="comment"># 每一轮都遍历一遍数据加载器  </span></span><br><span class="line">     <span class="keyword">for</span> step, (x, y) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_loader):  </span><br><span class="line">         <span class="comment"># 前向计算-&gt;计算损失函数-&gt;(从损失函数)反向传播-&gt;更新网络  </span></span><br><span class="line">         predict = MyConvNet(x)  </span><br><span class="line">         loss = loss_func(predict, y)  </span><br><span class="line">         optimizer.zero_grad()   <span class="comment"># 清空梯度（可以不写）  </span></span><br><span class="line">         loss.backward()     <span class="comment"># 反向传播计算梯度  </span></span><br><span class="line">         optimizer.step()    <span class="comment"># 更新网络  </span></span><br><span class="line">         global_iter_num = epoch * <span class="built_in">len</span>(train_loader) + step + <span class="number">1</span>  <span class="comment"># 计算当前是从训练开始时的第几步(全局迭代次数)  </span></span><br><span class="line">         <span class="keyword">if</span> global_iter_num % log_step_interval == <span class="number">0</span>:  </span><br><span class="line">             <span class="comment"># 控制台输出一下  </span></span><br><span class="line">             <span class="built_in">print</span>(<span class="string">&quot;global_step:&#123;&#125;, loss:&#123;:.2&#125;&quot;</span>.<span class="built_in">format</span>(global_iter_num, loss.item()))  </span><br><span class="line">             <span class="comment"># 在测试集上预测并计算正确率  </span></span><br><span class="line">             test_predict = MyConvNet(test_data_x)  </span><br><span class="line">             _, predict_idx = torch.<span class="built_in">max</span>(test_predict, <span class="number">1</span>)  <span class="comment"># 计算softmax后的最大值的索引，即预测结果  </span></span><br><span class="line">             acc = accuracy_score(test_data_y, predict_idx)  </span><br><span class="line">   </span><br><span class="line">             <span class="comment"># 以epoch和step为索引，创建日志字典  </span></span><br><span class="line">             history.log((epoch, step),  </span><br><span class="line">                         train_loss=loss,  </span><br><span class="line">                         test_acc=acc,  </span><br><span class="line">                         hidden_weight=MyConvNet.fc[<span class="number">2</span>].weight)  </span><br><span class="line">   </span><br><span class="line">             <span class="comment"># 可视化  </span></span><br><span class="line">             <span class="keyword">with</span> canvas:  </span><br><span class="line">                 canvas.draw_plot(history[<span class="string">&quot;train_loss&quot;</span>])  </span><br><span class="line">                 canvas.draw_plot(history[<span class="string">&quot;test_acc&quot;</span>])  </span><br><span class="line">                 canvas.draw_image(history[<span class="string">&quot;hidden_weight&quot;</span>])</span><br></pre></td></tr></table></figure><blockquote><p>不同于 tensorboard，hiddenlayer 会在程序运行的过程中动态生成图像，而不是模型训练完后</p></blockquote><p>下面为模型训练的某一时刻的截图：<img src="image-20230508170848014.png" alt="image-20230508170848014"></p><h1 id="三、使用-Visdom-进行可视化"><a href="#三、使用-Visdom-进行可视化" class="headerlink" title="三、使用 Visdom 进行可视化"></a>三、使用 Visdom 进行可视化</h1><p>Visdom 是 Facebook 为 pytorch 开发的一块可视化工具。类似于 tensorboard，visdom 也是通过在本地启动前端服务器来实现可视化的，而在具体操作上，visdom 又类似于 matplotlib. pyplot。所以使用起来很灵活。</p><p>首先先安装visdom库，然后补坑。由于启动前端服务器需要大量依赖项，所以在第一次启动时可能会很慢（需要下载前端三板斧的依赖项），解决方法请见这里。</p><p>先导入需要的第三方库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">from</span> visdom <span class="keyword">import</span> Visdom  </span><br><span class="line"> <span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span>  load_iris  </span><br><span class="line"> <span class="keyword">import</span> torch  </span><br><span class="line"> <span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"> <span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br></pre></td></tr></table></figure><p>matplotlib 里，用户绘图可以通过 plt 这个对象来绘图，在 visdom 中，同样需要一个绘图对象，我们通过 <code>vis = Visdom()</code> 来获取。具体绘制时，由于我们会一次画好几张图，所以 visdom 要求用户在绘制时指定当前绘制图像的窗口名字（也就是 <code>win</code> 这个参数）；除此之外，为了到时候显示的分块，用户还需要指定绘图环境 <code>env</code>，这个参数相同的图像，最后会显示在同一张页面上。</p><p>绘制线图（相当于 matplotlib 中的 <code>plt.plot</code>）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 绘制图像需要的数据  </span></span><br><span class="line"> iris_x, iris_y = load_iris(return_X_y=<span class="literal">True</span>)  </span><br><span class="line">   </span><br><span class="line"> <span class="comment"># 获取绘图对象，相当于plt  </span></span><br><span class="line"> vis = Visdom()  </span><br><span class="line">   </span><br><span class="line"> <span class="comment"># 添加折线图  </span></span><br><span class="line"> x = torch.linspace(-<span class="number">6</span>, <span class="number">6</span>, <span class="number">100</span>).view([-<span class="number">1</span>, <span class="number">1</span>])  </span><br><span class="line"> sigmoid = torch.nn.Sigmoid()  </span><br><span class="line"> sigmoid_y = sigmoid(x)  </span><br><span class="line"> tanh = torch.nn.Tanh()  </span><br><span class="line"> tanh_y = tanh(x)  </span><br><span class="line"> relu = torch.nn.ReLU()  </span><br><span class="line"> relu_y = relu(x)  </span><br><span class="line"> <span class="comment"># 连接三个张量  </span></span><br><span class="line"> plot_x = torch.cat([x, x, x], dim=<span class="number">1</span>)  </span><br><span class="line"> plot_y = torch.cat([sigmoid_y, tanh_y, relu_y], dim=<span class="number">1</span>)  </span><br><span class="line"> <span class="comment"># 绘制线性图  </span></span><br><span class="line"> vis.line(X=plot_x, Y=plot_y, win=<span class="string">&quot;line plot&quot;</span>, env=<span class="string">&quot;main&quot;</span>,  </span><br><span class="line">          opts=&#123;  </span><br><span class="line">              <span class="string">&quot;dash&quot;</span> : np.array([<span class="string">&quot;solid&quot;</span>, <span class="string">&quot;dash&quot;</span>, <span class="string">&quot;dashdot&quot;</span>]),  </span><br><span class="line">              <span class="string">&quot;legend&quot;</span> : [<span class="string">&quot;Sigmoid&quot;</span>, <span class="string">&quot;Tanh&quot;</span>, <span class="string">&quot;ReLU&quot;</span>]  </span><br><span class="line">          &#125;)</span><br></pre></td></tr></table></figure><p>绘制散点图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 添加茎叶图  </span></span><br><span class="line"> x = torch.linspace(-<span class="number">6</span>, <span class="number">6</span>, <span class="number">100</span>).view([-<span class="number">1</span>, <span class="number">1</span>])  </span><br><span class="line"> y1 = torch.sin(x)  </span><br><span class="line"> y2 = torch.cos(x)  </span><br><span class="line">   </span><br><span class="line"> <span class="comment"># 连接张量  </span></span><br><span class="line"> plot_x = torch.cat([x, x], dim=<span class="number">1</span>)  </span><br><span class="line"> plot_y = torch.cat([y1, y2], dim=<span class="number">1</span>)  </span><br><span class="line"> <span class="comment"># 绘制茎叶图  </span></span><br><span class="line"> vis.stem(X=plot_x, Y=plot_y, win=<span class="string">&quot;stem plot&quot;</span>, env=<span class="string">&quot;main&quot;</span>,  </span><br><span class="line">          opts=&#123;  </span><br><span class="line">              <span class="string">&quot;legend&quot;</span> : [<span class="string">&quot;sin&quot;</span>, <span class="string">&quot;cos&quot;</span>],  </span><br><span class="line">              <span class="string">&quot;title&quot;</span> : <span class="string">&quot;茎叶图&quot;</span>  </span><br><span class="line">          &#125;)</span><br></pre></td></tr></table></figure><p>绘制热力图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 计算鸢尾花数据集特征向量的相关系数矩阵  </span></span><br><span class="line"> iris_corr = torch.from_numpy(np.corrcoef(iris_x, rowvar=<span class="literal">False</span>))  </span><br><span class="line"> <span class="comment"># 绘制热力图  </span></span><br><span class="line"> vis.heatmap(iris_corr, win=<span class="string">&quot;heatmap&quot;</span>, env=<span class="string">&quot;main&quot;</span>,  </span><br><span class="line">             opts=&#123;  </span><br><span class="line">                 <span class="string">&quot;rownames&quot;</span> : [<span class="string">&quot;x1&quot;</span>, <span class="string">&quot;x2&quot;</span>, <span class="string">&quot;x3&quot;</span>, <span class="string">&quot;x4&quot;</span>],  </span><br><span class="line">                 <span class="string">&quot;columnnames&quot;</span> : [<span class="string">&quot;x1&quot;</span>, <span class="string">&quot;x2&quot;</span>, <span class="string">&quot;x3&quot;</span>, <span class="string">&quot;x4&quot;</span>],  </span><br><span class="line">                 <span class="string">&quot;title&quot;</span> : <span class="string">&quot;热力图&quot;</span>  </span><br><span class="line">             &#125;)</span><br></pre></td></tr></table></figure><p>可视化图片，这里我们使用自定义的 env 名 MyPlotEnv</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 可视化图片  </span></span><br><span class="line"> img_Image = Image.<span class="built_in">open</span>(<span class="string">&quot;./example.jpg&quot;</span>)  </span><br><span class="line"> img_array = np.array(img_Image.convert(<span class="string">&quot;L&quot;</span>), dtype=np.float32)  </span><br><span class="line"> img_tensor = torch.from_numpy(img_array)  </span><br><span class="line"> <span class="built_in">print</span>(img_tensor.shape)  </span><br><span class="line">   </span><br><span class="line"> <span class="comment"># 这次env自定义  </span></span><br><span class="line"> vis.image(img_tensor, win=<span class="string">&quot;one image&quot;</span>, env=<span class="string">&quot;MyPlotEnv&quot;</span>,  </span><br><span class="line">           opts=&#123;  </span><br><span class="line">               <span class="string">&quot;title&quot;</span> : <span class="string">&quot;一张图像&quot;</span>  </span><br><span class="line">           &#125;)</span><br></pre></td></tr></table></figure><p>可视化文本，同样在 MyPlotEnv 中绘制：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># 可视化文本  </span></span><br><span class="line"> text = <span class="string">&quot;hello world&quot;</span>  </span><br><span class="line"> vis.text(text=text, win=<span class="string">&quot;text plot&quot;</span>, env=<span class="string">&quot;MyPlotEnv&quot;</span>,  </span><br><span class="line">          opts=&#123;  </span><br><span class="line">              <span class="string">&quot;title&quot;</span> : <span class="string">&quot;可视化文本&quot;</span>  </span><br><span class="line">          &#125;)</span><br></pre></td></tr></table></figure><p>运行上述代码，再通过在终端中输入 <code>python3 -m visdom.server</code> 启动服务器，然后根据终端返回的 URL，在谷歌浏览器中访问这个 URL，就可以看到图像了。<img src="image-20230508170904960.png" alt="image-20230508170904960"></p><p><img src="image-20230508170910418.png" alt="image-20230508170910418"></p><blockquote><p>在 Environment 中输入不同的 env 参数可以看到我们在不同环境下绘制的图片。对于分类图集特别有用。</p></blockquote><p>在终端中按下 Ctrl+C 可以终止前端服务器。</p><h1 id="进一步"><a href="#进一步" class="headerlink" title="进一步"></a>进一步</h1><p>需要注意，如果你的前端服务器停掉了，那么所有的图片都会丢失，因为此时的图像的数据都是驻留在内存中，而并没有 dump 到本地磁盘。那么如何保存当前 visdom 中的可视化结果，并在将来复用呢？其实很简单，比如我现在有一堆来之不易的 Mel 频谱图：<img src="image-20230508170923964.png" alt="image-20230508170923964"></p><p>点击 Manage Views</p><p><img src="image-20230508170938623.png" alt="image-20230508170938623"></p><p>点击 fork-&gt;save:（此处我只保存名为 normal 的 env）</p><p><img src="image-20230508170948224.png" alt="image-20230508170948224"></p><p>接着，在你的 User 目录下（Windows 是 C:\Users\账户. visdom 文件夹，Linux 是在~. visdom 文件夹下），可以看到保存好的 env：</p><p><img src="image-20230508170958347.png" alt="image-20230508170958347"></p><p>它是以 json 文件格式保存的，那么如果你保存完后再 shut down 当前的前端服务器，图像数据便不会丢失。</p><p>好的，现在在保存完你珍贵的数据后，请关闭你的visdom前端服务器。然后再启动它。</p><p>如何查看保存的数据呢？很简答，下次打开visdom前端后，visdom会在.visdom文件夹下读取所有的保存数据完成初始化，这意味着，你直接启动visdom，其他什么也不用做就可以看到之前保存的数据啦！</p><p>那么如何服用保存的数据呢？既然你都知道了 visdom 保存的数据在哪里，那么直接通过 python 的 json 包来读取这个数据文件，然后做解析就可以了，这是方法一，演示如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&quot;...\.visdom\normal.json&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">    dataset : <span class="built_in">dict</span> = json.load(f)  </span><br><span class="line">  </span><br><span class="line">jsons : <span class="built_in">dict</span> = dataset[<span class="string">&quot;jsons&quot;</span>]      <span class="comment"># 这里存着你想要恢复的数据  </span></span><br><span class="line">reload : <span class="built_in">dict</span> = dataset[<span class="string">&quot;reload&quot;</span>]    <span class="comment"># 这里存着有关窗口尺寸的数据   </span></span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(jsons.keys())     <span class="comment"># 查看所有的win</span></span><br></pre></td></tr></table></figure><p>out:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dict_keys([<span class="string">&#x27;jsons&#x27;</span>, <span class="string">&#x27;reload&#x27;</span>])  </span><br><span class="line">dict_keys([<span class="string">&#x27;1.wav&#x27;</span>, <span class="string">&#x27;2.wav&#x27;</span>, <span class="string">&#x27;3.wav&#x27;</span>, <span class="string">&#x27;4.wav&#x27;</span>, <span class="string">&#x27;5.wav&#x27;</span>, <span class="string">&#x27;6.wav&#x27;</span>, <span class="string">&#x27;7.wav&#x27;</span>, <span class="string">&#x27;8.wav&#x27;</span>, <span class="string">&#x27;9.wav&#x27;</span>, <span class="string">&#x27;10.wav&#x27;</span>, <span class="string">&#x27;11.wav&#x27;</span>, <span class="string">&#x27;12.wav&#x27;</span>, <span class="string">&#x27;13.wav&#x27;</span>, <span class="string">&#x27;14.wav&#x27;</span>])</span><br></pre></td></tr></table></figure><p>但这么做不是很优雅，所以 visdom 封装了第二种方法。你当然可以通过访问文件夹. visdom 来查看当前可用的 env，但是也可以这么做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> visdom <span class="keyword">import</span> Visdom  </span><br><span class="line">  </span><br><span class="line">vis = Visdom()  </span><br><span class="line"><span class="built_in">print</span>(vis.get_env_list())</span><br></pre></td></tr></table></figure><p>在获取了可用的环境名后，你可以通过 get_window_data 方法来获取指定 env、指定 win 下的图像数据。请注意，该方法返回 str，故需要通过 json 来解析：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> visdom <span class="keyword">import</span> Visdom  </span><br><span class="line"><span class="keyword">import</span> json  </span><br><span class="line">  </span><br><span class="line">vis = Visdom()  </span><br><span class="line">  </span><br><span class="line">window = vis.get_window_data(win=<span class="string">&quot;1.wav&quot;</span>, env=<span class="string">&quot;normal&quot;</span>)      </span><br><span class="line">window = json.loads(window)         <span class="comment"># window 是 str，需要解析为字典  </span></span><br><span class="line">  </span><br><span class="line">content = window[<span class="string">&quot;content&quot;</span>]  </span><br><span class="line">data = content[<span class="string">&quot;data&quot;</span>][<span class="number">0</span>]  </span><br><span class="line"><span class="built_in">print</span>(data.keys())</span><br></pre></td></tr></table></figure><p>out:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Setting up a new session...  </span><br><span class="line">dict_keys([<span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;zmin&#x27;</span>, <span class="string">&#x27;zmax&#x27;</span>, <span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;colorscale&#x27;</span>])</span><br></pre></td></tr></table></figure><p>通过索引这些 keys，相信想复用原本的图像数据并不困难。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> PyTorch </tag>
            
            <tag> 可视化工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动手学深度学习（PyTorch框架）</title>
      <link href="/2022/10/08/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%88PyTorch%E6%A1%86%E6%9E%B6%EF%BC%89/"/>
      <url>/2022/10/08/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%88PyTorch%E6%A1%86%E6%9E%B6%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="阅读指南："><a href="#阅读指南：" class="headerlink" title="阅读指南："></a>阅读指南：</h1><p>• 第一部分（第1章至第3章）涵盖预备工作和基础知识。第1章介绍深度学习的背景。第2章提供动手学深度学习所需要的预备知识。第3章包括深度学习最基础的概念和技术，如多层感知机和模型正则化。如果读者时间有限，并且只想了解深度学习最基础的概念和技术，那么只需阅读第一部分。</p><p>• 第二部分（第4章至第6章）关注现代深度学习技术。第4章描述深度学习计算的各个重要组成部分，并为实现后续更复杂的模型打下基础。第5章解释近年来令深度学习在计算机视觉领域大获成功的卷积神经网络。第6章阐述近年来常用于处理序列数据的循环神经网络。阅读第二部分有助于掌握现代深度学习技术。</p><p>• 第三部分（第7章至第10章）讨论计算性能和应用。第7章评价各种用来训练深度学习模型的优化算法。第8章检验影响深度学习计算性能的几个重要因素。第9章和第10章分别列举深度学习在计算机视觉和自然语言处理中的重要应用。这部分内容读者可根据兴趣选择阅读。</p><p><img src="image-20230508184808366.png" alt="image-20230508184808366"></p><p>上图中由甲章指向乙章的箭头表明甲章的知识有助于理解乙章的内容。如果读者想短时间了解深度学习最基础的概念和技术，只需阅读第1章至第3章；如果读者希望掌握现代深度学习技术，还需阅读第4章至第6章。第7章至第10章读者可以根据兴趣选择阅读。</p><h1 id="深度学习简介"><a href="#深度学习简介" class="headerlink" title="深度学习简介"></a>深度学习简介</h1><p>逆向思考，与其涉及一个解决问题的程序，不如从嘴中的需求入手来找寻一个解决方案。即不用去想如何解决问题，而是以人的观点去输入一些数据，让计算机学习。</p><p>通俗来说，机器学习是一门讨论各式各样的适用于不同问题的函数形式，以及如何使用数据来有效地获取函数参数具体值的学科。深度学习是指机器学习中的一类函数，它们的形式通常为多层神经网络。</p><h1 id="第一章：前言"><a href="#第一章：前言" class="headerlink" title="第一章：前言"></a>第一章：前言</h1><p>训练过程通常包含如下步骤：</p><ol><li>从一个随机初始化参数的模型开始，这个模型基本毫不“智能”。</li><li>获取一些数据样本（比如：音频片段以及对应的{是，否}标签）。</li><li>调整参数，使模型在这些样本中表现得更好。</li><li>重复第2步和第3步，直到模型在任务中的表现令人满意。</li></ol><p><img src="image-20230508184821041.png" alt="image-20230508184821041"></p><h2 id="1-2-关键组件"><a href="#1-2-关键组件" class="headerlink" title="1.2. 关键组件"></a>1.2. 关键组件</h2><ol><li>我们可以学习的 <strong><em>数据</em>（data）</strong></li><li>如何转换数据的 <strong><em>模型</em>（model）</strong></li><li>一个 <strong><em>目标函数</em>（objective function）</strong>， 用来量化模型的有效性。</li><li>调整模型参数以优化目标函数的 <em>算法**</em>（algorithm）**。</li></ol><h3 id="1-2-1-数据"><a href="#1-2-1-数据" class="headerlink" title="1.2.1.数据"></a>1.2.1.数据</h3><p>每个数据集由一个个 <strong><em>样本（sample）</em></strong> 组成，大多时候，他们遵循独立同分布（independently and identically distributed）。样本有时候也叫做 <strong><em>数据点（data point）</em></strong> 或者 <strong><em>数据实例（data instance）</em></strong> 。</p><p>当每个样本的特征类别数量都是相同的时候，其特征向量是固定长度的，这个长度被称为数据的 <strong><em>维数（dimensionality）</em></strong> 。</p><blockquote><p>输入的是垃圾，输出的也是垃圾 （Garbage in ，Garbage out）</p></blockquote><p>如果数据不具有充分的代表性，甚至包含了一些社会的偏见时，那么模型就很有可能有偏见。</p><h3 id="1-2-2-模型"><a href="#1-2-2-模型" class="headerlink" title="1.2.2.模型"></a>1.2.2.模型</h3><p>深度学习与经典方法的区别主要在于：前者关注的功能强大的模型，这些模型由神经网络错综复杂的交织在一起，包含层层数据转换，因此被称为 <strong><em>深度学习</em></strong> （deep learning）。</p><h3 id="1-2-3-目标函数"><a href="#1-2-3-目标函数" class="headerlink" title="1.2.3.目标函数"></a>1.2.3.目标函数</h3><p>对模型优略程度的度量，这个度量在大多数情况下是可优化的，我们称之为 <strong><em>目标函数</em></strong> （objective function）。希望将这个函数优化至最低点，因为越低越好，所以这些函数有时候也被称为 <strong><em>损失函数</em></strong> （loss function）。 常见的损失函数是 <strong><em>平方误差</em></strong> （squared error），即预测值与实际值只差的平方。</p><p>可以将数据集分为两部分：<strong><em>训练数据集 ：</em></strong> 用于拟合模型参数，<strong><em>测试数据集：</em></strong>用于评估拟合的模型。</p><p>当一个模型在训练集上表现良好，但不能推广到测试集时，我们说这个模型是 <strong><em>过拟合</em></strong> （overfitting）。</p><h3 id="1-2-4-优化算法"><a href="#1-2-4-优化算法" class="headerlink" title="1.2.4.优化算法"></a>1.2.4.优化算法</h3><p>用于搜索出最佳参数，以最小化损失函数，深度学习中，大多流行的优化算法通常基于一种基本方法—— <strong><em>梯度下降</em>  （gradient descent）。</strong>在每个步骤中，梯度下降法都会检查每个参数，看看如果你仅对该参数进行少量变动，训练集损失会朝哪个方向移动。然后，他在可以减少损失的方向上优化参数。</p><h2 id="1-3-各种机器学习问题"><a href="#1-3-各种机器学习问题" class="headerlink" title="1.3.各种机器学习问题"></a>1.3.各种机器学习问题</h2><h3 id="1-3-1-监督学习"><a href="#1-3-1-监督学习" class="headerlink" title="1.3.1.监督学习"></a>1.3.1.监督学习</h3><p><strong><em>监督学习</em></strong> （supervised learning）擅长在“给定输入特征”的情况下预测标签。每个 “特征-标签”都称为一个样本。目的是生成一个模型，能够将任何输入特征映射到标签，即预测。</p><p>监督学习的过程为：首先，从已知大量数据样本中随机选取一个子集，为每个样本获取基本的真实标签。这些输入和相应的标签一起构成了训练数据集。随后，利用有监督学习算法，将训练数据集作为输入，并输出一个“完成学习模型”。之后用于测试集，评测这个模型。</p><blockquote><p>定量输出称为 <strong>回归</strong> ，或者说是连续变量预测。<br>定性输出称为 <strong>分类</strong> ，或者说是离散变量预测。</p></blockquote><ol><li><p><strong><em>回归</em></strong></p><p> 从一组数据出发，确定某些变量之间的定量关系式；即建立数学模型并估计未知参数。解决的是“有多少”的问题。</p><p> <strong>训练对象是</strong>：回归函数</p></li><li><p><strong><em>分类</em></strong></p><p> 从一组数据出发，预测样本属于哪个类别。解决的是“哪一个”的问题。</p><p> <strong>训练对象是：</strong>分类器</p></li><li><p><strong><em>标记问题</em></strong></p><p> 学习预测不相互排斥的类别问题称为 <strong><em>多标签分类</em></strong> （multi-label classification）。</p></li><li><p><strong><em>搜索</em></strong></p></li><li><p><strong><em>推荐系统</em></strong></p></li><li><p><strong><em>序列学习</em></strong></p></li></ol><h3 id="1-3-2-无监督学习"><a href="#1-3-2-无监督学习" class="headerlink" title="1.3.2.无监督学习"></a>1.3.2.无监督学习</h3><p>数据中不含有“目标”的机器学习问题为 <strong><em>无监督学习</em></strong> （unsupervised learning）</p><ul><li><strong><em>聚类</em></strong> （clustering）问题：在没有标签的情况下给数据分类。</li><li><strong><em>主成分分析</em></strong> （principal component analysis）问题：找到少量的参数来准确的捕捉数据的线性相关属性。</li><li><em>因果关系</em> 和 <em>概率图模型</em> 问题：</li><li><strong><em>生成对抗行网络 ：</em></strong></li></ul><h1 id="第2章：预备知识"><a href="#第2章：预备知识" class="headerlink" title="第2章：预备知识"></a>第2章：预备知识</h1><h2 id="2-1-数据操作"><a href="#2-1-数据操作" class="headerlink" title="2.1.数据操作"></a>2.1.数据操作</h2><p>类似于 <strong>NumPy</strong> 中的 <strong>ndarray</strong> ，在 <strong>Pytorch</strong> 中称为 <strong><em>张量</em></strong> （tensor）</p><h3 id="2-1-1-入门"><a href="#2-1-1-入门" class="headerlink" title="2.1.1.入门"></a>2.1.1.入门</h3><p>首先导入torch包： <code>import torch</code> </p><p><code>torch.arange</code> ：创建张量数组。 <code>x.shape</code> ：访问张量的形状。</p><p><code>x.reshape</code> ：改变张量的形状，可以输入 <code>-1</code> 来自动计算维度。</p><p><code>torch.zeros</code> ：创建全0张量。 <code>torch.ones</code> ：创建全1张量。</p><p><code>torch.randn</code> ：从均值为0、标准差为1的标准高斯分布中随机采样。</p><p><code>torch.tensor</code> ：将Python内置列标转换为对应的张量。</p><h3 id="2-1-2-运算符"><a href="#2-1-2-运算符" class="headerlink" title="2.1.2.运算符"></a>2.1.2.运算符</h3><p>常见的标准运算符： +、-、<em>、/ 和 *</em>  全部被转化为按元素运算。</p><p>利用 <code>.cat((X,Y),dim=0)</code> 可以将两个矩阵连接在一起。</p><h3 id="2-1-3-广播机制"><a href="#2-1-3-广播机制" class="headerlink" title="2.1.3.广播机制"></a>2.1.3.广播机制</h3><p>当形状不同时，可以调用广播机制来进行按元素操作。工作方式如下：首先，通过适当复制元素来扩展一个或两个数组，以便在转换之后，两个张量具有相同的形状。其次，对生成的数组执行按元素操作。</p><h3 id="2-1-4-索引和切片"><a href="#2-1-4-索引和切片" class="headerlink" title="2.1.4.索引和切片"></a>2.1.4.索引和切片</h3><p><code>0</code> 为第一个元素， <code>-1</code> 为最后一个元素</p><h3 id="2-1-5-节省内存"><a href="#2-1-5-节省内存" class="headerlink" title="2.1.5.节省内存"></a>2.1.5.节省内存</h3><h3 id="2-1-6-转换为其他Python对象"><a href="#2-1-6-转换为其他Python对象" class="headerlink" title="2.1.6.转换为其他Python对象"></a>2.1.6.转换为其他Python对象</h3><p><code>A = X.numpy()</code>  <code>B=torch.tensor(A)</code></p><h2 id="2-2-数据预处理"><a href="#2-2-数据预处理" class="headerlink" title="2.2.数据预处理"></a>2.2.数据预处理</h2><h3 id="2-2-1-读取数据"><a href="#2-2-1-读取数据" class="headerlink" title="2.2.1.读取数据"></a>2.2.1.读取数据</h3><p>调用 <strong>Pandas</strong> 读取 csv 文件： <code>pandas.read_csv()</code> </p><h3 id="2-2-2-处理缺失值"><a href="#2-2-2-处理缺失值" class="headerlink" title="2.2.2.处理缺失值"></a>2.2.2.处理缺失值</h3><p>典型的方法为 <strong><em>插值法</em></strong> 和 <strong><em>删除法</em></strong> 。 <code>fillna()</code> 函数</p><h3 id="2-2-3-转换为张量格式"><a href="#2-2-3-转换为张量格式" class="headerlink" title="2.2.3.转换为张量格式"></a>2.2.3.转换为张量格式</h3><p><code>torch.tensor</code></p><h2 id="2-3-线性代数"><a href="#2-3-线性代数" class="headerlink" title="2.3.线性代数"></a>2.3.线性代数</h2><p><code>torch.mv(A,x)</code> : 计算矩阵-向量积。</p><p><code>torch.mm(A,B)</code> ：计算矩阵-矩阵积</p><h3 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h3><p>一个向量的范数告诉我们一个向量有多大。这里的大小不涉及维度，而是分量的大小。</p><p>在线性代数中，向量范数是将向量映射到标量的函数$f$。 给定任意向量x，向量范数要满足一些属性。 第一个性质是：如果我们按常数因子$\alpha$缩放向量的所有元素， 其范数也会按相同常数因子的<em>绝对值</em>缩放：$f(\alpha x)=|\alpha|f(x)$<br>第二个性质时三角不等式：$f(x+y)\le f(x)+f(y)$<br>第三个性质为非负性：$f(x)\ge 0$</p><p><code>torch.norm(x)</code> 计算向量的 $L_2$ 范数</p><p><code>torch.abs(u).sum()</code> 计算向量的$L_1$ 范数。</p><h2 id="2-4-微积分"><a href="#2-4-微积分" class="headerlink" title="2.4.微积分"></a>2.4.微积分</h2><h3 id="2-4-3-梯度"><a href="#2-4-3-梯度" class="headerlink" title="2.4.3.梯度"></a>2.4.3.梯度</h3><p>可以连结一个多元函数对其所有变量的偏导数，以得到该函数的 <strong><em>梯度</em></strong> 向量。函数 $f(x)$相对于$x$的梯度是一个包含$n$个偏导数的向量：</p><p>$\bigtriangledown_x f(x)=[{\frac{\partial f(x)}{\partial x_1},\frac{\partial f(x)}{\partial x_2},…,\frac{\partial f(x)}{\partial x_n} }]^T$ </p><p>假设$x$为$n$维向量，在微分多元函数时经常使用以下规则：</p><ul><li>对于所有的$\mathrm{A} \in \mathbb{R}^{m\times n}$，都有$\bigtriangledown _x \mathrm{Ax}=\mathrm{A}^T$</li><li>对于所有的$\mathrm{A} \in \mathbb{R}^{n\times m}$，都有$\bigtriangledown _x \mathrm{x}^T\mathrm{A}=\mathrm{A}$</li><li>对于所有的$\mathrm{A} \in \mathbb{R}^{n\times n}$，都有$\bigtriangledown _x \mathrm{x}^T\mathrm{Ax}=(\mathrm{A+A^T})\mathrm{x}$</li><li>$\bigtriangledown _x||\mathrm{x}||^2 = \bigtriangledown _x\mathrm{x^Tx}=2\mathrm{x}$</li></ul><h2 id="2-5-自动微分"><a href="#2-5-自动微分" class="headerlink" title="2.5.自动微分"></a>2.5.自动微分</h2><p>深度学习框架通过自动计算导数，即<em>自动微分</em>（automatic differentiation）来加快求导。 实际中，根据我们设计的模型，系统会构建一个<em>计算图</em>（computational graph）， 来跟踪计算是哪些数据通过哪些操作组合起来产生输出。 自动微分使系统能够随后反向传播梯度。 这里，<em>反向传播</em>（backpropagate）意味着跟踪整个计算图，填充关于每个参数的偏导数。</p><p>利用<strong><em>反向传播函数</em></strong> 来计算微分： <code>y.backward()</code>  输出 <code>x.grad</code></p><h2 id="2-6-概率"><a href="#2-6-概率" class="headerlink" title="2.6.概率"></a>2.6.概率</h2><h1 id="第3章：线性神经网络"><a href="#第3章：线性神经网络" class="headerlink" title="第3章：线性神经网络"></a>第3章：线性神经网络</h1><h2 id="3-1-线性回归"><a href="#3-1-线性回归" class="headerlink" title="3.1.线性回归"></a>3.1.线性回归</h2><p>常见的例子：预测价格、预测住院时间、预测需求等</p><h3 id="3-1-1-线性回归的基本元素"><a href="#3-1-1-线性回归的基本元素" class="headerlink" title="3.1.1.线性回归的基本元素"></a>3.1.1.线性回归的基本元素</h3><p><strong><em>线性回归</em></strong> ：假设自变量 $x$ 和因变量 $y$ 之间的关系是线性的，即 $y$  可以表示为 $x$ 中元素的加权和。这里通常允许包含观测值的一些噪声；其次，假设任何噪声都是比较正常的，如噪声遵循正态分布。</p><ol><li><p><strong><em>线性模型</em></strong>：</p><p> 如：$price=\omega<em>{area}·area+\omega</em>{age}·age+b$</p><p> 其中 $\omega<em>{area}和\omega</em>{age}$ 称为权重，权重决定了每个特征对预测值的影响， $b$ 称为 <strong><em>偏置</em></strong>、<strong><em>偏移量</em></strong> 或 <strong><em>截距</em></strong> 。偏置是指：所有的特征都取0时，预测值应为多少。</p><p> 给定一个数据集，目标即为寻找权重 $\omega$ 和偏置 $b$ 。</p><p> 在机器学习领域，通常是好几个特征：$\hat{y}=\omega_1·x_1+…+\omega_d·x_d+b$ </p></li><li><p><strong><em>损失函数</em></strong>：</p><p> 用于度量模型质量的方式。能够量化目标的实际值和预测值之间的差距。</p><p> 常用的损失函数是：平方误差函数</p></li><li><p><strong><em>解析解</em></strong>：</p><p> 线性回归的解可以用一个公式简单地表达出来。这类解叫做解析解。</p></li><li><p><strong><em>随机梯度下降</em></strong>：</p><p> <strong><em>梯度下降法</em></strong> 几乎可以优化所有的深度学习模型。通过不断地在损失函数递减的方向上更新参数来降低误差。</p><p> 最简单的用法是计算损失函数关于模型参数的导数。这种做法可能会很慢，因此，通常会在每次需要计算更新的时候随机抽取一小批样本，称为 <strong><em>小批量随机梯度下降</em></strong>。</p><p> <strong>算法的步骤为</strong>：</p><ol><li>初始化模型参数的值，如随机初始化；</li><li>从数据集中随机抽取小批量样本且在负梯度的方向上更新参数，并不断迭代这一步骤。</li></ol></li></ol><h3 id="3-1-2-矢量化加速"><a href="#3-1-2-矢量化加速" class="headerlink" title="3.1.2.矢量化加速"></a>3.1.2.矢量化加速</h3><p>同时处理整个小批量的样本。不用按元素级运算，直接对两个向量变量名进行加减等运算操作。</p><h3 id="3-1-3-正态分布与平方损失"><a href="#3-1-3-正态分布与平方损失" class="headerlink" title="3.1.3.正态分布与平方损失"></a>3.1.3.正态分布与平方损失</h3><p>正态分布：也称为 高斯分布。 简单说：若随机变量 $x$ 具有均值 $\mu$ 和方差 $\sigma^2$ （标准差为 $\sigma$），其正态分布概率密度函数如下：$p(x)=\frac{1}{\sqrt{2\pi \sigma ^2} } (-\frac{1}{2\sigma ^2} (x-\mu )^2)$</p><h3 id="3-1-4-从线性回归到深度网络"><a href="#3-1-4-从线性回归到深度网络" class="headerlink" title="3.1.4.从线性回归到深度网络"></a>3.1.4.从线性回归到深度网络</h3><ol><li><strong><em>神经网络图</em></strong>：<img src="image-20230508184843519.png" alt="image-20230508184843519"></li></ol><p>通常会忽略网络的输入层，因此，这个模型为单层神经网络。</p><p>对于线性回归，每个输入都与每个输出相连，我们将这种变换称为 <strong><em>全连接层</em></strong> 或 <strong><em>稠密层</em></strong>。</p><h2 id="3-2-线性回归的从零开始实现"><a href="#3-2-线性回归的从零开始实现" class="headerlink" title="3.2.线性回归的从零开始实现"></a>3.2.线性回归的从零开始实现</h2><h2 id="3-3-线性回归的简洁实现"><a href="#3-3-线性回归的简洁实现" class="headerlink" title="3.3.线性回归的简洁实现"></a>3.3.线性回归的简洁实现</h2><h2 id="3-4-softmax回归"><a href="#3-4-softmax回归" class="headerlink" title="3.4.softmax回归"></a>3.4.softmax回归</h2><h3 id="3-4-1-分类问题"><a href="#3-4-1-分类问题" class="headerlink" title="3.4.1.分类问题"></a>3.4.1.分类问题</h3><p><strong><em>独热编码</em></strong>： 表示分类数据的简单方法，它是一个向量，分量和类别一样多，类别对应的分量设置为1，其他所有分量设置为0。</p><h3 id="3-4-2-网络架构"><a href="#3-4-2-网络架构" class="headerlink" title="3.4.2.网络架构"></a>3.4.2.网络架构</h3><p><img src="image-20230508184909710.png" alt="image-20230508184909710"></p><p>与线性回归一样，softmax回归也是一个单层神经网络。并且其输出也是全连接层。</p><h3 id="3-4-3-全连接层的参数开销"><a href="#3-4-3-全连接层的参数开销" class="headerlink" title="3.4.3.全连接层的参数开销"></a>3.4.3.全连接层的参数开销</h3><p>对于任何具有 $d$ 个输入和 $q$ 个输出的全连接层，参数开销为： $\Theta(dq)$ ，可以减小成本：将$d$ 个输入转换为 $q$ 个输出的成本可以减少到 $\Theta(\frac{dq}{n} )$。</p><h3 id="3-4-4-softmax运算"><a href="#3-4-4-softmax运算" class="headerlink" title="3.4.4.softmax运算"></a>3.4.4.softmax运算</h3><p>需要一个训练目标，来鼓励模型精准地估计概率。在分类器输出0.5的所有样本中，希望这些样本有一半shi’jia</p><p>实现softmax的步骤：</p><ol><li><p>对每个项求幂（使用exp）；</p></li><li><p>对每一行求和（小批量中每个样本是一行），得到每个样本的规范化常数；</p></li><li><p>将每一行除以其规范化常数，确保结果的和为1.</p><p> $softmax(X)<em>{ij}=\frac{exp(X</em>{ij})}{\sum<em>kexp(X</em>{ik})}$  </p></li></ol><h3 id="交叉熵损失函数"><a href="#交叉熵损失函数" class="headerlink" title="交叉熵损失函数"></a>交叉熵损失函数</h3><p><a href="https://zhuanlan.zhihu.com/p/35709485">损失函数｜交叉熵损失函数</a></p><ol><li><p><strong><em>表达式</em></strong>：</p><ol><li><p><strong>二分类</strong></p><p> 在二分的情况下，模型最后需要预测的结果只有两种情况，对于每个类别我们的预测得到的概率为 $p$ 和 $1-p$ 。此时表达式为：</p><p> $L=\frac{1}{N} \sum _iL_i=\frac{1}{N} \sum _i-[y_i·log(p_i)+(1-y_i)·log(1-p_i)]$ </p><p> 其中：</p><p> $y_i$ ——表示样本 $i$ 的label，正类为1，负类为0</p><p> $p_i$ ——表示样本  $i$ 预测为正类的概率。 </p></li><li><p><strong>多分类</strong></p><p> $L =\frac{1}{N} \sum <em>iL_i=-\frac{1}{N} \sum _i\sum </em>{c=1}^My<em>{ic}log(p</em>{ic})$ </p><p> 其中：</p><p> $M$ ——类别的数量</p><p> $y_{ic}$ ——符号函数（0或1）</p><p> $p_{ic}$  ——观测样本  $i$ 属于类别 $c$ 的预测概率</p></li></ol></li></ol><h2 id="3-5-图像分类数据集"><a href="#3-5-图像分类数据集" class="headerlink" title="3.5.图像分类数据集"></a>3.5.图像分类数据集</h2><p><strong><em>MNIST数据集</em></strong> 是图像分类中广泛使用的数据集之一。 还有 <strong><em>Fashion-MNIST数据集</em></strong>。</p><h1 id="第4章：多层感知机"><a href="#第4章：多层感知机" class="headerlink" title="第4章：多层感知机"></a>第4章：多层感知机</h1><h2 id="4-1-多层感知机"><a href="#4-1-多层感知机" class="headerlink" title="4.1.多层感知机"></a>4.1.多层感知机</h2><h3 id="4-1-4-隐藏层"><a href="#4-1-4-隐藏层" class="headerlink" title="4.1.4.隐藏层"></a>4.1.4.隐藏层</h3><ol><li><p><strong><em>线性模型可能会出错</em></strong></p><p> you</p></li><li><p><strong><em>在网络中加入隐藏层</em></strong>：</p><p> 可以在输入与输出之间加入一个或几个隐藏层：将许多全连接层堆叠在一起。每一层都输出到上面的层，直到生成最后的输出。</p><p> <strong><em>多层感知机</em></strong>： 将前 $L-1$ 层看作表示，把最后一层看作线性预测器。<img src="image-20230508184926274.png" alt="image-20230508184926274"></p><p> 这个多层感知机有4个输入，3个输出，其隐藏层包含了5个隐藏单元。其层数为2层，且都是全连接层。</p></li><li><p><strong><em>从线性到非线性</em></strong>：</p><p> $\mathrm {H}^{(1)} =\sigma _1(\mathrm{XW^{(1)}+b^{(1)})}$  和  $\mathrm {H}^{(2)} =\sigma _2(\mathrm{H^{(1)}W^{(2)}+b^{(2)})}$ </p></li><li><p><strong><em>通用近似定理</em></strong>：</p><p> 多层感知机可以通过隐藏神经元，捕捉到输入之间复杂的相互作用，这些神经元依赖于每个输入的值。</p></li></ol><h3 id="4-1-2-激活函数"><a href="#4-1-2-激活函数" class="headerlink" title="4.1.2.激活函数"></a>4.1.2.激活函数</h3><p><strong><em>激活函数</em></strong> 通过计算加权和并加上偏置来确定神经元是否应该被激活，他们将输入信号转换为输出的可微运算。</p><ol><li><p><strong><em>ReLU函数</em></strong>：</p><p> <strong><em>修正线性单元（ReLU）</em></strong> ：该元素与 0 的最大值。$ReLU(x)=max(x,0)$  </p><p> 通过将相应的活性值设为 0 ，仅保留正元素并丢弃所有的负元素。</p><p> 当输入为负时，ReLU函数的导数为0，而当输入为正时，ReLU函数的导数为1。</p><p> ReLU函数的有点：求导表现特别好：要么让参数消失，要么让参数通过。并且减轻了困扰神经网络的梯度消失问题。</p></li><li><p><strong><em>sigmoid函数</em></strong>：</p><p> 将实数 $\mathbb{R}$ 上的输入转变为 $（0，1）$上的输出，也称为 <strong><em>挤压函数</em></strong>。</p><p> $sigmoid(x)=\frac{1}{1+exp(-x)}$  </p><p> 常用用途：利用 sigmoid单元 来控制时序信息流的架构</p></li><li><p><strong><em>tanh函数</em></strong></p><p> 同样是压缩到 $（-1，1）$上：$tanh(x)=\frac{1-exp(-2x)}{1+exp(-2x)}$  </p></li></ol><h2 id="4-2-模型选择、欠拟合和过拟合"><a href="#4-2-模型选择、欠拟合和过拟合" class="headerlink" title="4.2.模型选择、欠拟合和过拟合"></a>4.2.模型选择、欠拟合和过拟合</h2><p>将模型在训练数据上拟合的比潜在分布中更接近的现象称为 <strong><em>过拟合</em></strong>。 用于对抗过拟合的技术称为 <strong>*正则化</strong>。 </p><h3 id="4-2-1-训练误差和泛化误差"><a href="#4-2-1-训练误差和泛化误差" class="headerlink" title="4.2.1.训练误差和泛化误差"></a>4.2.1.训练误差和泛化误差</h3><p><strong><em>训练误差：</em></strong> 模型在训练数据集上得到的误差。</p><p><strong><em>泛化误差：</em></strong> 模型应用在同样从原始样本的分布中抽取的无限多数据样本时，模型误差的期望。</p><ol><li><strong>统计学习理论</strong>：</li><li><strong>模型复杂性</strong></li></ol><h3 id="4-2-2-模型选择"><a href="#4-2-2-模型选择" class="headerlink" title="4.2.2.模型选择"></a>4.2.2.模型选择</h3><ol><li><p><strong><em>验证集</em></strong></p><p> 将数据集分为三份，训练集、验证集和测试集。但是验证集和测试集之间的边界却很模糊。</p></li><li><p><strong><em>K折交叉验证</em></strong></p><p> 原始训练数据被分成 K 个不重叠的子集。然后执行 K 次模型训练和验证，每次在 K-1 个子集上进行训练，并在剩余的一个子集上进行验证。最后，通过对 K 次实验结果取平均值来估计训练和验证误差。</p></li></ol><h2 id="4-3-权重衰减"><a href="#4-3-权重衰减" class="headerlink" title="4.3.权重衰减"></a>4.3.权重衰减</h2><p>正则化模型的技术。在训练集的损失函数中加入惩罚项，以降低学习到的模型的复杂度</p><h3 id="4-3-1-范数与权重衰减"><a href="#4-3-1-范数与权重衰减" class="headerlink" title="4.3.1.范数与权重衰减"></a>4.3.1.范数与权重衰减</h3><p>$L(w,b)=\frac{1}{n} \sum _{i=1}^n\frac{1}{2} (w^Tx^{(i)}+b-y^{(i)})^2$。 </p><p>$L(w,b)+\frac{(\lambda )}{2} ||w||^2$。  </p><p>$w\gets (1-\eta \lambda )w-\frac{\eta }{\mathcal{B} } \sum _{i\in \mathcal{B} }x^{(i)}(w^Tx^{(i)}+b-y^{(i)})$  </p><h2 id="4-4-暂退法"><a href="#4-4-暂退法" class="headerlink" title="4.4.暂退法"></a>4.4.暂退法</h2><h2 id="4-5-前向传播、反向传播和计算图"><a href="#4-5-前向传播、反向传播和计算图" class="headerlink" title="4.5.前向传播、反向传播和计算图"></a>4.5.前向传播、反向传播和计算图</h2><h2 id="4-6-数值稳定性和模型初始化"><a href="#4-6-数值稳定性和模型初始化" class="headerlink" title="4.6.数值稳定性和模型初始化"></a>4.6.数值稳定性和模型初始化</h2><h3 id="4-6-1-梯度消失和梯度爆炸"><a href="#4-6-1-梯度消失和梯度爆炸" class="headerlink" title="4.6.1.梯度消失和梯度爆炸"></a>4.6.1.梯度消失和梯度爆炸</h3><h1 id="第6章：卷积神经网络（CNN）"><a href="#第6章：卷积神经网络（CNN）" class="headerlink" title="第6章：卷积神经网络（CNN）"></a>第6章：卷积神经网络（CNN）</h1><h2 id="6-1-从全连接层到卷积"><a href="#6-1-从全连接层到卷积" class="headerlink" title="6.1.从全连接层到卷积"></a>6.1.从全连接层到卷积</h2><h3 id="6-1-1-不变性"><a href="#6-1-1-不变性" class="headerlink" title="6.1.1.不变性"></a>6.1.1.不变性</h3><p>合理的假设：无论哪种方法找到这个物体，都应该和物体的位置无关。 <strong><em>卷积神经网络</em></strong> 正是将 空间不变性 这一概念系统化。</p><p>适合于计算机视觉的神经网络架构：</p><ol><li><strong><em>平移不变性</em></strong>： 不管检测对象出现在图像的哪个位置，神经网络的前面几层应该对相同的图像区域具有相似的反应。</li><li><strong><em>局部性：</em></strong> 神经网络前面几层应该只探索输入图像的局部区域，而不过度在意图像中相隔较远区域的关系。</li></ol><h3 id="6-1-2-多层感知机的限制"><a href="#6-1-2-多层感知机的限制" class="headerlink" title="6.1.2.多层感知机的限制"></a>6.1.2.多层感知机的限制</h3><p>多层感知机的输入是二维图像 $\mathrm{X}$ ，其隐藏表示 $\mathrm{H}$ 在数学上是一个矩阵，在代码中表示为二维张量。</p><p>$[\mathrm{H}<em>{i,j}] = [\mathrm{U}]</em>{i,j} +\sum <em>k \sum _l  [W]</em>{i,j,k,l}[\mathrm{X}] <em>{k,l} \ =[\mathrm{U}]</em>{i,j} + \sum <em>a^k\sum _b^l[\mathrm{V}]</em>{i,j,a,b}[\mathrm{X} ]_{i+a,j+b}$</p><ol><li><p><strong>平移不变性：</strong> 意味着检测对象在输入 $\mathrm{X}$ 中的平移，应该仅导致隐藏表示 $\mathrm{H}$ 中的平移。即 $U$ 和 $V$ 实际上不依赖于 $（i，j）$的值，即 $[V]<em>{i,j,a,b}=[V]</em>{a,b}$ ，并且 $U$ 是一个常数，此时，我们可以简化 $H$  的定义为：</p><p> $[\mathrm{H}]<em>{i,j}=u+\sum _a\sum _b[V]</em>{a,b}[X]_{i+a.j+b}$  </p><p> 这就是 <em>卷积</em> </p></li><li><p><strong>局部性</strong></p><p> 在距离 $（i，j）$很远的地方，可以设置 $[V]_{a,b}=0$ 。因此，可以重写为：</p><p> $[\mathrm{H}]<em>{i,j}=u+\sum _a^\bigtriangleup \sum _b^\bigtriangleup [V]</em>{a,b}[X]_{i+a.j+b}$  </p><p> 此为一个卷积层， $\mathrm{V}$ 被称为 <em>卷积核</em>  或者 <em>滤波器  ，</em>或者称为该<em>卷积层的权重。</em> </p></li></ol><h3 id="6-1-3-卷积"><a href="#6-1-3-卷积" class="headerlink" title="6.1.3.卷积"></a>6.1.3.卷积</h3><p>卷积是当把一个函数“翻转”并位移 $x$ 时，测量 $f和g$ 之间的重叠。</p><h3 id="6-1-4-“沃尔多在哪里”"><a href="#6-1-4-“沃尔多在哪里”" class="headerlink" title="6.1.4.“沃尔多在哪里”"></a>6.1.4.“沃尔多在哪里”</h3><ol><li><p><strong><em>通道：</em></strong></p><p> 一般图像包含三个通道/三种原色（红、绿、蓝），而且图像是由高度、宽度和颜色组成的三维张量。此时将 $X$ 索引为： $[X]<em>{i,j,k}$ ，卷积相应调整为： $[V]</em>{a,b,c}$ . </p></li></ol><h2 id="6-2-图像卷积"><a href="#6-2-图像卷积" class="headerlink" title="6.2.图像卷积"></a>6.2.图像卷积</h2><h3 id="6-2-1-互相关运算"><a href="#6-2-1-互相关运算" class="headerlink" title="6.2.1.互相关运算"></a>6.2.1.互相关运算</h3><h3 id="6-2-2-卷积层"><a href="#6-2-2-卷积层" class="headerlink" title="6.2.2.卷积层"></a>6.2.2.卷积层</h3><p>卷积层对输入和卷积核权重进行互相关运算，并在添加标量偏置后产生输出。所以卷积层中的两个被训练的参数就是卷积核权重和标量偏置。</p><p>对图像进行边缘检测：利用卷积核找出相邻元素之间不一样的部分，即为边缘。</p><h3 id="6-2-4-学习卷积核"><a href="#6-2-4-学习卷积核" class="headerlink" title="6.2.4.学习卷积核"></a>6.2.4.学习卷积核</h3><h3 id="6-2-5-互相关和卷积"><a href="#6-2-5-互相关和卷积" class="headerlink" title="6.2.5.互相关和卷积"></a>6.2.5.互相关和卷积</h3><h2 id="6-3-填充和步幅"><a href="#6-3-填充和步幅" class="headerlink" title="6.3.填充和步幅"></a>6.3.填充和步幅</h2><p>填充卷积图像，防止原图像经过卷积之后图像尺寸变小。</p><p>而步幅则是为了减小图像的大小，因为有时候图像的分辨率十分冗余，需要进行缩小。</p><h3 id="6-3-1-填充"><a href="#6-3-1-填充" class="headerlink" title="6.3.1.填充"></a>6.3.1.填充</h3><p>在许多情况下，我们需要设置 $p_h=k_h-1 和p_w=k_w-1$ ，使输入和输出具有相同的高度和宽度。假设 $k_h$ 使奇数，我们将在高度的两侧填充 $\frac{p_h}{2}$ 行，如果 $k_h$ 使偶数，则一种可能性是在输入的顶部和底部填充 $\frac{p_h}{2}$行。</p><p>卷积神经网络中的卷积核的高度和宽度通常为奇数。</p><h3 id="6-3-2-步幅"><a href="#6-3-2-步幅" class="headerlink" title="6.3.2.步幅"></a>6.3.2.步幅</h3><p>通常情况下，卷积窗口在输入张量的左上角开始，向下、向右滑动，每次滑动一个元素。但是，为了高效计算或是缩减采样次数，卷积窗口可以跳过中间位置，每次滑动多个元素。</p><p>通常，当垂直步幅为 $s_h$、水平步幅为 $s_w$ 时，其输出形状为：</p><p>$\lfloor (n_h-k_h+p_h+s_h)/s_h\rfloor \times \lfloor (n_w-k_w+p_w+s_w)/s_w\rfloor$ </p><h2 id="6-4-多输入多输出通道"><a href="#6-4-多输入多输出通道" class="headerlink" title="6.4.多输入多输出通道"></a>6.4.多输入多输出通道</h2><h3 id="6-4-1-多输入通道"><a href="#6-4-1-多输入通道" class="headerlink" title="6.4.1.多输入通道"></a>6.4.1.多输入通道</h3><p>当输入包含多个通道时，需要构造一个与输入数据具有相同输入通道数的卷积核，以便于输入数据进行互相关运算。</p><p>基本上，我们将每个通道输入的二维张量和卷积核的二维张量进行互相关运算，再对通道求和得到二维张量。</p><h3 id="6-4-2-多输出通道"><a href="#6-4-2-多输出通道" class="headerlink" title="6.4.2.多输出通道"></a>6.4.2.多输出通道</h3><p>由于上面得到的是一个二维张量，但是多通道的输出又是至关重要的，在最流行的神经网络架构中，随着神经网络层数的加深，我们通常会增加通道的维数，通过减少空间分辨率以获得更大的通道深度。只管来说：我们可以将每个通道看作是对不同特征的响应。</p><p>为了获得多通道的输出，我们可以为每个输出通道创建一个与输入通道数相同，与卷积核大小相同的卷积核张量，在互相关运算中，每个输出通道先获取所有输入通道，再以对应该输出通道的卷积核计算结果。</p><h2 id="6-5-汇聚层"><a href="#6-5-汇聚层" class="headerlink" title="6.5.汇聚层"></a>6.5.汇聚层</h2><p><strong><em>汇聚层的目的：</em></strong> 降低卷积层对位置的敏感性；同时降低对空间采样表示的敏感性。</p><h3 id="6-5-1-最大汇聚层和平均汇聚层"><a href="#6-5-1-最大汇聚层和平均汇聚层" class="headerlink" title="6.5.1.最大汇聚层和平均汇聚层"></a>6.5.1.最大汇聚层和平均汇聚层</h3><p>汇聚层与卷积层类似，但是不涉及互相关运算，而是计算汇聚窗口中所有元素的最大值或平均值，其分别被称为： <strong><em>最大汇聚层</em></strong> 和 <strong><em>平均汇聚层</em></strong>。</p><p>汇聚窗口形状为 $p\times q$ 的汇聚层称为 $p\times q$ 汇聚层，汇聚操作称为 $p\times q$ 汇聚。</p><h3 id="6-5-2-填充和步幅"><a href="#6-5-2-填充和步幅" class="headerlink" title="6.5.2.填充和步幅"></a>6.5.2.填充和步幅</h3><p>和卷积层一样，汇聚层同样可以进行填充以及更改步幅。</p><h3 id="6-5-3-多个通道"><a href="#6-5-3-多个通道" class="headerlink" title="6.5.3.多个通道"></a>6.5.3.多个通道</h3><p>在处理多通道输入数据时，汇聚层在每个输入通道上单独运算，而不是像卷积层一样在通道上对输入进行汇总。这意味着汇聚层的输出通道数与输入通道数相同。</p><h2 id="6-6-卷积神经网络（LeNet）"><a href="#6-6-卷积神经网络（LeNet）" class="headerlink" title="6.6.卷积神经网络（LeNet）"></a>6.6.卷积神经网络（LeNet）</h2><h3 id="6-6-1-LeNet"><a href="#6-6-1-LeNet" class="headerlink" title="6.6.1.LeNet"></a>6.6.1.LeNet</h3><p>总体来看，LeNet由两个部分组成：</p><ul><li>卷积编码器：由两个卷积层组成</li><li>全连接层密集块：由三个全连接层组成。</li></ul><p><img src="image-20230508185050913.png" alt="image-20230508185050913"></p><p>每个卷积快中的基本单元是一个卷积层、一个sigmoid激活函数和平均汇聚层。</p><h1 id="第8章：循环神经网络"><a href="#第8章：循环神经网络" class="headerlink" title="第8章：循环神经网络"></a>第8章：循环神经网络</h1><h2 id="8-1-序列模型"><a href="#8-1-序列模型" class="headerlink" title="8.1.序列模型"></a>8.1.序列模型</h2><h3 id="8-1-1-统计工具"><a href="#8-1-1-统计工具" class="headerlink" title="8.1.1.统计工具"></a>8.1.1.统计工具</h3><ol><li><strong><em>自回归模型</em></strong>：<ol><li>通过截取固定长度的时间序列来观测数值，因此，参数的数量总是不变的，这种模型被称为 <strong>自回归模型</strong> ，因为他们是对自己执行回归。</li><li>保留一些对过去观测的总结，并且同时更新预测和总结，在此过程中，有一部分从未被观测到，因此，这个模型被称为 <strong>隐变量自回归模型</strong>。</li></ol></li><li><strong><em>马尔可夫模型</em></strong>：</li><li><strong><em>因果关系：</em></strong></li></ol><h2 id="8-2-文本预处理"><a href="#8-2-文本预处理" class="headerlink" title="8.2.文本预处理"></a>8.2.文本预处理</h2><p>通常的步骤为：</p><ol><li>将文本作为字符串加载到内存中</li><li>将字符串拆分为词元（如单词和字符）</li><li>建立一个词表，将拆分的词元映射到数字索引</li><li>将文本转换为数字索引序列，方便模型操作。</li></ol><h2 id="8-3-语言模型和数据集"><a href="#8-3-语言模型和数据集" class="headerlink" title="8.3.语言模型和数据集"></a>8.3.语言模型和数据集</h2><h3 id="8-3-1-学习语言模型"><a href="#8-3-1-学习语言模型" class="headerlink" title="8.3.1.学习语言模型"></a>8.3.1.学习语言模型</h3>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3网络爬虫开发实战</title>
      <link href="/2022/05/08/Python3%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/"/>
      <url>/2022/05/08/Python3%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章：爬虫基础"><a href="#第一章：爬虫基础" class="headerlink" title="第一章：爬虫基础"></a>第一章：爬虫基础</h1><h2 id="1-1-HTTP基本原理"><a href="#1-1-HTTP基本原理" class="headerlink" title="1.1.HTTP基本原理"></a>1.1.HTTP基本原理</h2><h3 id="http的请求过程"><a href="#http的请求过程" class="headerlink" title="http的请求过程"></a>http的请求过程</h3><p>==请求== 主要分为四部分：请求方法、请求的网址、请求头和请求体。<br>==请求体：== 一般承载的内容是 POST 请求中的表单数据，GET 的请求体为空<br>常见的 Content-Type 和 POST 提交数据方式的关系：</p><div class="table-container"><table><thead><tr><th>Content-Typ</th><th>POST 提交数据的方式</th></tr></thead><tbody><tr><td>application/x-www-from-urlencded</td><td>表单数据</td></tr><tr><td>multipart/form-data</td><td>表单文件上传</td></tr><tr><td>application/json</td><td>序列化 JSON 数据</td></tr><tr><td>text/xml</td><td>XML 数据</td></tr></tbody></table></div><hr><h3 id="多进程和多线程"><a href="#多进程和多线程" class="headerlink" title="多进程和多线程"></a>多进程和多线程</h3><p>Python 多线程的用法：<a href="https://setup.scrape.center/python-threading">https://setup.scrape.center/python-threading</a><br>Python 多进程的用法：<a href="https://setup.scrape.center/python-multiprocessing">https://setup.scrape.center/python-multiprocessing</a><br>多线程适用场景：如果任务不全是<strong>计算密集型</strong>任务，就可以使用多线程来提高程序整体的执行效率。尤其是对于爬虫这种 <strong>IO密集型</strong> 任务，使用多线程能够大大提高程序整体的爬取效率。</p><p>Python中<strong>GIL</strong>（Global Interpreter Lock,全局解释器锁）的限制导致不论是在单核还是多核条件下,同一时刻都只能运行一个线程这使得Python多线程无法发挥多核并行的优势。从整体来看, Python的多进程比多线程更有优势。所以,如果条件允许的话,尽量用多进程。</p><h2 id="1-2-无状态-HTTP"><a href="#1-2-无状态-HTTP" class="headerlink" title="1.2 无状态 HTTP"></a>1.2 无状态 HTTP</h2><p>用于保持 HTTP 连接状态的技术：Session 和 Cookie，其中 Session 在服务端，用来保存用户的 Session 信息；Cookie 在客户端。</p><ol><li>会话 Cookie：将 Cookie 放在浏览器内存中，关闭浏览器后，Cookie 即失效。</li><li>持久 Cookie：将 Cookie 保存到客户端的硬盘中，下次还可以继续使用，用于长久保存用户的登陆状态。</li></ol><p><img src="image-20230508165248527.png" alt="image-20230508165248527"></p><h2 id="1-3-代理的基本原理"><a href="#1-3-代理的基本原理" class="headerlink" title="1.3 代理的基本原理"></a>1.3 代理的基本原理</h2><p>如果一个 IP 在短时间内大量访问服务，就会被封 IP，即服务器会检测某个 IP 在单位时间内的请求次数，如果请求次数超过设定的阈值，就会直接拒绝提供服务，并返回一些错误信息。</p><h1 id="第2章-基本库的使用"><a href="#第2章-基本库的使用" class="headerlink" title="第2章 基本库的使用"></a>第2章 基本库的使用</h1><h2 id="2-1-urllib-的使用"><a href="#2-1-urllib-的使用" class="headerlink" title="2.1 urllib 的使用"></a>2.1 urllib 的使用</h2><hr><hr><ol><li>常用的 <code>urllib.parse</code> 方法： <code>urlencode</code> 、<code>urlunencode</code>  <code>urlparse</code></li><li>响应码以及相应的查询条件：<strong><em>P54</em></strong><img src="image-20230508165310241.png" alt="image-20230508165310241"></li><li>SSL 证书验证  <code>requests.get(url,verify=False)</code> 即可，但是此时会报一个警告，建议指定证书，可以通过设置忽略警告的方式来屏蔽这个警告：<code>from requests.packages import urllib3  urllib3.disable_warnings()</code>  。或者通过捕获警告日志的方式忽略警告： <code>import logging  logging.captureWarnings(True)</code>   <strong><em>P60</em></strong></li><li>身份认证：  </li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> requests.auto <span class="keyword">import</span> HTTPBasicAuth</span><br><span class="line">r=requests.get(url,auth=HTTPBasicAuth(<span class="string">&#x27;username&#x27;</span>,<span class="string">&#x27;password&#x27;</span>))</span><br><span class="line"><span class="comment"># 或者一种更简单的写法：</span></span><br><span class="line">r=requests.get(url,auth=(<span class="string">&#x27;username&#x27;</span>,<span class="string">&#x27;password&#x27;</span>))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">***代理设置：*** 针对本机设置：</span><br><span class="line">```python</span><br><span class="line">proxies=&#123;&#x27;https&#x27;:&#x27;http://127.0.0.1:7890&#x27;&#125;</span><br><span class="line">r=requests.get(url,proxies=proxies)</span><br></pre></td></tr></table></figure><hr><p><strong><em>正则表达式：</em></strong> </p><ul><li><p><code>match(re,content)</code>   从字符串的开头开始匹配。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result=re.<span class="keyword">match</span>(<span class="string">&#x27;^Hello\s\d\d\d\s\d&#123;4&#125;\s\w&#123;10&#125;&#x27;</span>,content)  </span><br><span class="line"><span class="built_in">print</span>(result)  </span><br><span class="line"><span class="built_in">print</span>(result.group())  <span class="comment"># 输出匹配到的内容。</span></span><br><span class="line"><span class="built_in">print</span>(result.span())   <span class="comment"># 输出匹配的范围。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  <strong>贪婪匹配：</strong> <code>.*</code>   <strong>非贪婪匹配：</strong> <code>.*?</code>  在做匹配的时候，字符串中间尽量使用非贪婪匹配，以免出现匹配结果缺失的情况；如果匹配的结果在字符串结尾，非贪婪匹配有可能匹配不到任何内容，因为它会匹配尽可能少的字符。<br>  <strong>修饰符：</strong> <code>re.S</code> 使匹配内容包括换行符在内的所有字符。</p><p>  <img src="Pasted%20image%2020221102151427.png" alt></p><ul><li><code>search(re,content)</code> 匹配时扫描整个字符串，返回 <strong>第一个</strong> 匹配成的结果。</li><li><code>findall(re,content)</code>  对应于 search ，返回全部匹配到的字符串。</li><li><code>sub(re,replaceCha,content)</code> 修改文本，比如去除文本中的数字。<code>content=re.sub(&#39;\d+&#39;,&#39;&#39;,content)</code></li><li><code>compile(re)</code> 将正则字符串编译为正则表达式，目前感觉没啥用。</li></ul><hr><p>  <strong><em>httpx ：</em></strong> 用于访问那些使用 <strong>HTTP/2.0</strong> 的网站，而 <code>urllib</code> 和 <code>requests</code> 仅支持 <strong>HTTP/1.1</strong> 。  </p><ul><li>使用代理：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    proxies=&#123;</span><br><span class="line">     <span class="string">&#x27;https://&#x27;</span>:<span class="string">&#x27;http://127.0.0.1:7890&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">+ httpx 默认使用的是 **HTTP/<span class="number">1.1</span>** ，**HTTP/<span class="number">2.0</span>** 需要开启，通常与上下文管理器结合使用</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="keyword">import</span> httpx</span><br><span class="line">client=httpx.Client(http2=<span class="literal">True</span>)</span><br><span class="line">response=client.get(url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上下文管理器</span></span><br><span class="line"><span class="keyword">with</span> httpx.Client(http2=<span class="literal">True</span>,proxies=proxies) <span class="keyword">as</span> client:</span><br><span class="line">response=client.get(url)</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>其中，<code>httpx.Client</code> 相当于 <code>requests.Session</code>  此外 httpx 还支持一部请求。</p><hr><h1 id="第三章-解析库"><a href="#第三章-解析库" class="headerlink" title="第三章 解析库"></a>第三章 解析库</h1><p><strong><em>XPath:</em></strong> XML路径语言</p><ul><li>常用规则：<img src="image-20230508165702696.png" alt="image-20230508165702696"></li><li><strong>属性多值匹配</strong>， <code>contains</code> 当属性中有多个值时：<code>contains(属性名称，属性值)</code> </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">text=<span class="string">&#x27;&#x27;&#x27;&lt;li class=&quot;li li-first&quot;&gt;&lt;a href=&quot;link.html&quot;&gt;first item&lt;/a&gt;&lt;/li&gt;&#x27;&#x27;&#x27;</span></span><br><span class="line">html=etree.parse(text,etrcc.HTMLparser())</span><br><span class="line">result = html.xpath(<span class="string">&#x27;//li[contains(@class &quot;li&quot;)]/a/text()&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>多属性匹配</strong>，用多个属性确定一个点，运算符之间用 <code>and</code> 连接</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;li li-first&quot;</span> <span class="attr">name</span>=<span class="string">&quot;item&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;link.html&quot;</span>&gt;</span>first item<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">result=html.xpath(&#x27;//li[contains(@class &quot;li&quot;) and @name=&quot;item&quot;]/a/text()&#x27;)</span><br></pre></td></tr></table></figure><p>除了 <code>and</code> 之外，XPath 还有其他的运算符：<img src="image-20230508165838714.png" alt="image-20230508165838714"></p><ul><li><strong>按序选择：</strong> 往中括号中传入值来选取</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result=html.xpath(<span class="string">&#x27;//li[1]/a/text()&#x27;</span>) // 选取第一个节点</span><br><span class="line">result=html.xpath(<span class="string">&#x27;//li[last()]/a/text()&#x27;</span>) // 最后一个</span><br><span class="line">result=html.xpath(<span class="string">&#x27;//li[position()&lt;3]/a/text()&#x27;</span>) //前两个</span><br><span class="line">result=html.xpath(<span class="string">&#x27;//li[last()-2]/a/text()&#x27;</span>) //倒数第三个</span><br></pre></td></tr></table></figure><hr><p><strong><em>Beautiful Soup:</em></strong></p><ul><li><p><code>beautufil soup</code> 依赖解析器,通常有 <code>html.parser</code>    <code>lxml</code>    <code>xml</code>   <code>html5lib</code>  这四种, 不过比较推荐使用 <strong><em>lxml</em></strong> <img src="image-20230508165854714.png" alt="image-20230508165854714"></p></li><li><p><code>soup.prettify()</code> 把要解析的字符串以标准的缩进格式输出.</p></li><li>选择器输出的都是<code>bs4.element.Tag</code>类型,可以进行嵌套选择 </li><li><strong>关联选择:</strong> <ul><li><code>children</code> 或者 <code>contents</code> 选择所有的子节点  contents 返回列表 children 返回生成器</li><li><code>descendants</code> 选择所有的子孙节点   返回类型为 生成器类型</li><li><code>parent</code> 选择节点的父节点(仅获取直接父节点,不包含其他父节点)</li><li><code>parents</code> 获取当前节点的所有父节点  返回生成器</li><li><code>next_sibling</code> 和 <code>previous_sibling</code> 获取下一个和上一个兄弟节点</li><li><code>next_siblings</code> 和 <code>previous_siblings</code> 获取后面和前面所有的兄弟节点</li></ul></li><li><strong>方法选择器:</strong> <ul><li><code>find_all(name,attrs,recursive,text,**kwargs)</code> <ul><li><code>name</code>  找出所有 ul 标签 <code>soup.find_all(name=&#39;ul&#39;)</code>   返回结果是列表类型,其中的每个元素依然是 <code>bs4.element.Tag</code> 类型.</li><li><code>attrs</code> 根据属性查询: <code>soup.find_all(attrs=&#123;&#39;id&#39;:&#39;list-1&#39;&#125;)</code>  返回结果为列表. 也可以直接用 <code>soup.find_all(id=&#39;list-1&#39;)</code>  <code>soup.find_all(class_=&#39;element&#39;)</code></li><li><code>text</code> 用来匹配节点的文本, </li></ul></li><li><code>find</code> 同 <code>find_all</code> 不过进返回第一个匹配到的元素.</li><li>其他的方法:  <img src="image-20230508165915758.png" alt="image-20230508165915758"></li></ul></li><li><strong>CSS选择器:</strong> 调用 <code>select</code> 方法,传入相应的 CSS选择器即可. <code>soup.select(&#39;ul li&#39;)</code></li></ul><hr><hr><p><strong><em>pyquery:</em></strong> 功能强大的 CSS 选择器</p><ul><li><strong>查找节点:</strong> <ul><li><code>find</code>  查找所有的子孙节点</li><li><code>children</code> 只查找子节点</li><li><code>parent</code> 查找直接父节点 <code>parents</code> 查找所有祖先节点</li><li><code>siblings</code> 查找所有兄弟节点  <code>l.siblings(&#39;.active&#39;)</code></li></ul></li><li><strong>获取信息</strong><ul><li><code>attr</code> 获取属性值</li><li><code>text</code> 获取内部文本</li><li><code>html</code> 获取节点内部的 HTML 文本</li></ul></li><li><strong>节点操作:</strong><ul><li><code>addClass</code> <code>removeClass</code> 添加或者删除一个 class <code>li.addClass(&#39;active&#39;)</code> </li><li><code>attr</code> <code>text</code> <code>html</code> 对属性进行操作</li></ul></li></ul><h1 id="第四章-数据的存储"><a href="#第四章-数据的存储" class="headerlink" title="第四章 数据的存储"></a>第四章 数据的存储</h1><hr><p><strong><em>MySQL存储：</em></strong><br>标准的写入格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line">db = pymysql.connect(host=<span class="string">&#x27;121.4.79.246&#x27;</span>,user=<span class="string">&#x27;root&#x27;</span>,password=<span class="string">&#x27;Shadow99!&#x27;</span>,port=<span class="number">3306</span>,db=<span class="string">&#x27;db_python&#x27;</span>)  </span><br><span class="line">data=&#123;  </span><br><span class="line">    <span class="string">&#x27;id&#x27;</span>:<span class="string">&#x27;2021214094&#x27;</span>,  </span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;张伟&#x27;</span>,  </span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>:<span class="number">20</span>  </span><br><span class="line">&#125;  </span><br><span class="line">table=<span class="string">&#x27;student&#x27;</span>  </span><br><span class="line">keys = <span class="string">&#x27;,&#x27;</span>.join(data.keys())  </span><br><span class="line">values=<span class="string">&#x27;,&#x27;</span>.join([<span class="string">&#x27;%s&#x27;</span>]*<span class="built_in">len</span>(data))  </span><br><span class="line">sql = <span class="string">&#x27;INSERT INTO &#123;table&#125;(&#123;keys&#125;) VALUES (&#123;values&#125;)&#x27;</span>.<span class="built_in">format</span>(table=table,keys=keys,values=values)  </span><br><span class="line"></span><br><span class="line">cursor = db.cursor()  </span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    <span class="keyword">if</span>(cursor.execute(sql,<span class="built_in">tuple</span>(data.values()))):  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Successful&#x27;</span>)  </span><br><span class="line">        db.commit()  </span><br><span class="line"><span class="keyword">except</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed&#x27;</span>)  </span><br><span class="line">    db.rollback()  </span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure><p><strong>标准的更新格式：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">db = pymysql.connect(host=<span class="string">&#x27;121.4.79.246&#x27;</span>,user=<span class="string">&#x27;root&#x27;</span>,password=<span class="string">&#x27;Shadow99!&#x27;</span>,port=<span class="number">3306</span>,db=<span class="string">&#x27;db_python&#x27;</span>)  </span><br><span class="line"><span class="comment"># 标准的更新数据方法  </span></span><br><span class="line">data=&#123;  </span><br><span class="line">    <span class="string">&#x27;id&#x27;</span>:<span class="string">&#x27;2021214094&#x27;</span>,  </span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;张伟&#x27;</span>,  </span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>:<span class="number">24</span>  </span><br><span class="line">&#125;  </span><br><span class="line">table=<span class="string">&#x27;student&#x27;</span>  </span><br><span class="line">keys=<span class="string">&#x27;,&#x27;</span>.join(data.keys())  </span><br><span class="line">values=<span class="string">&#x27;,&#x27;</span>.join([<span class="string">&#x27;%s&#x27;</span>]*<span class="built_in">len</span>(data))  </span><br><span class="line">  </span><br><span class="line">cursor=db.cursor()  </span><br><span class="line">sql = <span class="string">&#x27;INSERT INTO &#123;table&#125;(&#123;keys&#125;) values(&#123;values&#125;) ON DUPLICATE KEY UPDATE &#x27;</span>.<span class="built_in">format</span>(table=table,keys=keys,values=values)  </span><br><span class="line">update=<span class="string">&#x27;,&#x27;</span>.join([<span class="string">&quot;&#123;key&#125;=%s&quot;</span>.<span class="built_in">format</span>(key=key) <span class="keyword">for</span> key <span class="keyword">in</span> data])  </span><br><span class="line">sql += update  </span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    <span class="keyword">if</span> cursor.execute(sql,<span class="built_in">tuple</span>(data.values())*<span class="number">2</span>):  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Successful&#x27;</span>)  </span><br><span class="line">        db.commit()  </span><br><span class="line"><span class="keyword">except</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed&#x27;</span>)  </span><br><span class="line">    db.rollback()  </span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure><hr><hr><p><strong><em>MongoDB:</em></strong><br>比较符号：<img src="image-20230508170029989.png" alt="image-20230508170029989"></p><p>适用写法： <code>collection.find(&#123;&#39;age&#39;:&#123;&#39;$gt&#39;:20&#125;&#125;)</code> </p><p>或者正则匹配查询：<img src="image-20230508170039776.png" alt="image-20230508170039776"></p><p>操作方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line">client = pymongo.MongoClient(host=<span class="string">&#x27;localhost&#x27;</span>,port=<span class="number">27017</span>)</span><br><span class="line">db=client.test <span class="comment"># 指定数据库</span></span><br><span class="line">collection=db.student  <span class="comment"># 指定集合</span></span><br></pre></td></tr></table></figure><hr><p><strong><em>Redis缓存存储：</em></strong>  $P_{151}$<br>本机设置的密码为： <code>Shadow99!</code><br>连接 Redis</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> StrictRedis</span><br><span class="line">redis=StrictRedis(host=<span class="string">&#x27;localhost&#x27;</span>,port=<span class="number">6379</span>,db=<span class="number">0</span>,password=<span class="string">&#x27;Shadow99!&#x27;</span>)</span><br><span class="line">reids.<span class="built_in">set</span>(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;Bob&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(redis.get(<span class="string">&#x27;name&#x27;</span>))</span><br></pre></td></tr></table></figure><p>主要就是熟悉各种操作：键操作、字符串操作、列表操作、集合操作、有序集合操作、散列操作。</p><hr><p><strong><em>Elasticsearch搜索引擎存储：</em></strong> $P_{159}$<br>Elasticsearch 和传统关系型数据库的对比：<img src="image-20230508170100208.png" alt="image-20230508170100208"></p><p>没装好。。。。运行不通。。后面再试吧</p><hr><p><strong><em>RabbitMQ的使用：</em></strong> $P_{166}$<br>在爬取数据的过程中，实现进程之间的通信。 它是一个开源的消息队列系统。</p><hr><p><strong><em>异步爬虫：</em></strong><br><code>asyncio</code> 结合 <code>aiohttp</code> 实现异步爬虫：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 aiohttp 结合 asyncio 实现异步  </span></span><br><span class="line"><span class="keyword">import</span> asyncio  </span><br><span class="line"><span class="keyword">import</span> aiohttp  </span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line">  </span><br><span class="line">start_time=time.time()  </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">url</span>):  </span><br><span class="line">    session = aiohttp.ClientSession()  </span><br><span class="line">    response = <span class="keyword">await</span> session.get(url)  </span><br><span class="line">    <span class="keyword">await</span> response.text()  </span><br><span class="line">    <span class="keyword">await</span> session.close()  </span><br><span class="line">    <span class="keyword">return</span> response  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">request</span>():  </span><br><span class="line">    url=<span class="string">&#x27;https://www.httpbin.org/delay/5&#x27;</span>  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Waiting for &#x27;</span>,url)  </span><br><span class="line">    response=<span class="keyword">await</span> get(url)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Get response from&#x27;</span>,url,<span class="string">&#x27;response &#x27;</span>,response)  </span><br><span class="line">  </span><br><span class="line">tasks = [asyncio.ensure_future(request()) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]  </span><br><span class="line">loop = asyncio.get_event_loop()  </span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))  </span><br><span class="line">  </span><br><span class="line">end_time=time.time()  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Cost time:&#x27;</span>,end_time-start_time)</span><br></pre></td></tr></table></figure><p><strong>并发限制：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 并发限制  </span></span><br><span class="line"><span class="keyword">import</span> asyncio  </span><br><span class="line"><span class="keyword">import</span> aiohttp  </span><br><span class="line">  </span><br><span class="line">CONCURRENCY = <span class="number">5</span>  </span><br><span class="line">URL=<span class="string">&#x27;https://www.baidu.com&#x27;</span>  </span><br><span class="line">  </span><br><span class="line">semaphone = asyncio.Semaphore(CONCURRENCY)  </span><br><span class="line">session=<span class="literal">None</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">scrape_api</span>():  </span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> semaphone:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Scraping &quot;</span>,URL)  </span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(URL) <span class="keyword">as</span> response:  </span><br><span class="line">            <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> response.text()  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():  </span><br><span class="line">    <span class="keyword">global</span> session  </span><br><span class="line">    session=aiohttp.ClientSession()  </span><br><span class="line">    scrape_index_tasks = [asyncio.ensure_future(scrape_api()) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>)]  </span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(*scrape_index_tasks)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:  </span><br><span class="line">    asyncio.get_event_loop().run_until_complete(main())</span><br></pre></td></tr></table></figure><hr><h2 id="第7章-自动化软件"><a href="#第7章-自动化软件" class="headerlink" title="第7章 自动化软件"></a>第7章 自动化软件</h2><p><strong><em>Selenium:</em></strong><br>当使用 <code>wait.until(EC.***)</code>时的判断条件<img src="image-20230508170125607.png" alt="image-20230508170125607"></p><p>如 <code>wait.until(EC.title_is())</code></p><hr><p><strong><em>Splash：</em></strong></p><ol><li><strong>Splash Lua 脚本：</strong><br> <a href="https://www.runoob.com/lua/lua-tutorial.html">Lua 教程 | 菜鸟教程</a>  </li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
